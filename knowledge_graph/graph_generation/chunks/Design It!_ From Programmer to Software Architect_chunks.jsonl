{"text": "This book covers the essentials of design and software architecture that all devel-: opment teams need to know. It is definitely going on the recommended reading\nlist for all my teams and anyone we bring on board! \u27a4J\u00f8rn \u00d8lmheim\nLeading Advisor Software Architecture, Statoil ASA\nWhat sets Design It! apart for me is its fresh perspective\u2014that the technical un-\ndertaking of building software is an intensely social activity. Michael manages to\nuniquely fuse the mechanics of software architecture together with the chemistry\nof design thinking. You\u2019ll learn to move from architecture viewpoints into design\nmindsets and from managing architecture life cycles into telling architecture sto-\nries. This is a must-have reference book on modern software architecting. \u27a4Amine Chigani\nChief Architect, GE Digital\nThis book is timely, valuable, accessible, and excellent. It is a clear, informed,\nand practical guide to the principles and practice of software architecture, for the\naspiring architect as well as the established practitioner who wants to deepen\nand refresh his or her skills. Michael Keeling takes the reader on a clear and re-\nsults-oriented journey, from the fundamentals of the field to the state of the art. \u27a4Eoin Woods\nCTO of Endava, editor of IEEE Software\u2019s Pragmatic Architect column, and\nauthor of Software Systems Architecture\nInvaluable for growing your career and your team! The perfect balance between\ndesign theory and practical activities. \u27a4Joseph Kramer\nSoftware Engineering Manager, IBM", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 4", "position": 4, "chunk_type": "semantic", "token_estimate": 231}
{"text": "Contents: Acknowledgments\n. . . . . . . . . . . xi\nForeword\n. . . . . . . . . . . . . xiii\nWelcome! . . . . . . . . . . . . . xv\nPart I \u2014 Introducing Software Architecture\n1. Become a Software Architect\n. . . . . . . . . 3\nWhat Software Architects Do\n3\nWhat Is Software Architecture? 7\nBecome an Architect for Your Team\n11\nBuild Amazing Software\n12\nCase Study: Project Lionheart\n14\nNext Up\n14\n2. Design Thinking Fundamentals\n. . . . . . . . 15\nThe Four Principles of Design Thinking\n15\nAdopt a Design Mindset\n18\nThink, Do, Check\n21\nNext Up\n24\nPart II \u2014 Architecture Design Fundamentals\n3. Devise a Design Strategy . . . . . . . . . . 27\nFind a Design That Satisfices\n27\nDecide How Much to Design Up Front\n29\nLet Risk Be Your Guide\n32\nCreate a Design Plan\n36\nProject Lionheart: The Story So Far\u2026\n38\nNext Up\n38", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 7", "position": 7, "chunk_type": "semantic", "token_estimate": 183}
{"text": "4.: Empathize with Stakeholders\n. . . . . . . . 39\nTalk to the Right People\n39\nCreate a Stakeholder Map\n41\nDiscover the Business Goals\n43\nProject Lionheart: The Story So Far\u2026\n46\nNext Up\n47\n5. Dig for Architecturally Significant Requirements . . . . 49\nLimit Design Options with Constraints\n49\nDefine the Quality Attributes\n51\nLook for Classes of Functional Requirements\n56\nFind Out What Else Influences the Architecture\n58\nDig for the Information You Need\n59\nBuild an ASR Workbook\n60\nProject Lionheart: The Story So Far\u2026\n62\nNext Up\n62\n6. Choose an Architecture (Before It Chooses You) . . . . 63\nDiverge to See Options, Converge to Decide\n63\nAccept Constraints\n66\nPromote Desired Quality Attributes\n68\nAssign Functional Responsibilities to Elements\n73\nDesign for Change\n75\nProject Lionheart: The Story So Far\u2026\n77\nNext Up\n77\n7. Create a Foundation with Patterns\n. . . . . . . 79\nWhat Is an Architecture Pattern? 79\nLayers Pattern\n80\nPorts and Adapters Pattern\n82\nPipe-and-Filter Pattern\n84\nService-Oriented Architecture Pattern\n86\nPublish-Subscribe Pattern\n88\nShared-Data Pattern\n90\nMulti-Tier Pattern\n92\nCenter of Competence Pattern\n93\nOpen Source Contribution Pattern\n95\nBig Ball of Mud Pattern\n96\nDiscover New Patterns\n96\nProject Lionheart: The Story So Far\u2026\n97\nNext Up\n98\nContents \u2022 vi", "domains": ["Architectural Patterns and Styles", "Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 8", "position": 8, "chunk_type": "semantic", "token_estimate": 224}
{"text": "Create Opportunities for Safe Practice: 179\nDelegate Design Authority\n181\nDesign Architecture Together\n185\nProject Lionheart: The Epic Conclusion\n186\nNext Up\n187\nPart III \u2014 The Architect\u2019s Toolbox\n14. Activities to Understand the Problem\n. . . . . . 191\nChoose One Thing\n192\nActivity 1. Activity 2. Empathy Map\n195\nActivity 3. Goal-Question-Metric (GQM) Workshop\n199\nActivity 4. Interview Stakeholders\n202\nActivity 5. List Assumptions\n205\nActivity 6. Quality Attribute Web\n207\nActivity 7. Mini-Quality Attribute Workshop\n210\nActivity 8. Point-of-View Mad Lib\n215\nActivity 9. Response Measure Straw Man\n219\nActivity 10. Stakeholder Map\n221\n15. Activities to Explore Potential Solutions\n. . . . . 225\nPersonify the Architecture\n226\nActivity 11. Activity 12. Architecture Flipbook\n228\nActivity 13. Component Responsibility Collaborator Cards\n232\nActivity 14. Concept Map\n236\nActivity 15. Divide and Conquer\n239\nActivity 16. Event Storming\n244\nActivity 17. Group Posters\n249\nActivity 18. Round-Robin Design\n252\nActivity 19. Whiteboard Jam\n255\n16. Activities to Make the Design Tangible\n. . . . . . 259\nArchitecture Decision Records\n260\nActivity 20. Activity 21. Architecture Haiku\n263\nActivity 22. Context Diagram\n265\nActivity 23. Greatest Hits Reading List\n267\nActivity 24. Inception Deck\n269\nActivity 25. Modular Decomposition Diagram\n272\nActivity 26. Paths Not Taken\n274\nActivity 27. Prototype to Learn or Decide\n276\nContents \u2022 viii", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 10", "position": 10, "chunk_type": "semantic", "token_estimate": 225}
{"text": "glance at Part III, \u201cThe Architect\u2019s Toolbox,\u201d you will not see \u201cArchitect chisels: stone tablets for the team.\u201d You will see activities that fit within even week-\nlong iterations, encourage team ownership of the design, and promote the\ndesign as a first-class concern of the team. It also has pictures of teams\nactually applying these techniques. The same thought leaders who overthrew bureaucratic software processes\nalso cautioned us that Agile was not a disguise for undisciplined cowboy\ncoding. Those bureaucratic pre-Agile processes were, for the most part, disci-\nplined, and you knew which design activities you should do and when. Despite\nteams self-reporting that they are following Agile processes, my experience is\nthat there is a lot of undisciplined cowboy coding happening today. Now that this book exists, the question is: what happens next? It is hard to\nmake predictions, especially about the future, but here is what I foresee. We\nare on the cusp of a transition to a stable state of software development where\nwe have learned to blend agility and discipline. Our processes will use the\nquick feedback loops popularized by Agile and will guide us to design tech-\nniques that drive quality. Unmistakably, they will be software processes, with\nactivities and techniques uniquely appropriate for software development. We are not there yet, but this book moves us in that direction. Let\u2019s go build\nthe future we want to live in. George Fairbanks\nAuthor of Just Enough Software Architecture\nForeword \u2022 xiv\nreport erratum  \u2022  discuss", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 14", "position": 14, "chunk_type": "semantic", "token_estimate": 249}
{"text": "play set positions. Playing positions is important since it lets the coach: create a game strategy, which increases the team\u2019s likelihood of scoring. Some software systems are designed like a children\u2019s soccer team: one great\nbig clump of software chasing after a release. Software development, similar\nto soccer games, goes smoother when the software is divided into pieces and\neach piece is assigned a responsibility, a position to play. Architects partition (a fancy word for divide into pieces) the software system\nso they can develop a strategy for achieving quality attributes and other system\nrequirements. For example, you might assign functional responsibilities by\ndesigning one component to register users and another to identify pictures\nof cats. Or you could assign different teams to develop different modules. Or\nyou might split things that read data from things that write data so the soft-\nware system will be more reliable, available, and scalable. Partitioning a system is important not just because it lets you develop a strategy\nfor achieving quality attributes. Smaller things are easier to reason about, easier\nto test, and easier to design. Of course, since you broke the system into pieces,\nyou\u2019ll also have to make sure everything can come back together again. Keep an Eye on the Bigger Picture\nEvery software system lives in the context of a bigger world. The world in\nwhich software lives includes the users who interact with it, the team who\nbuilds it, the hardware it runs on, and even the purpose for developing the\nsoftware in the first place. Ideally, the architecture lives harmoniously within\nthis broader context. fn main() {\n    let mut n = 1;\n    while n < 100 {\n        if n % 15 == 0 { println! (\"fizzbuzz\"); }\n        else if n % 3 == 0 { println! (\"fizz\"); }\n        else if n % 5 == 0 { println! (\"buzz\"); }\n        else { println! (\"{}\", n); }\n        n += 1;\n    }\n}\nSoftware\nDevelops\nTeam\nRuns on\nHardware\nUsers\nFun and \nProfit! Company\nWants\nUse\nDirects\nSoftware always lives in the context of a system. Picks\nHelps\nWant\nreport erratum  \u2022  discuss\nWhat Software Architects Do \u2022 5", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 21", "position": 21, "chunk_type": "semantic", "token_estimate": 358}
{"text": "Thinking about the system as a whole means architects deal with more than: just technology. People, processes, business needs, and many other technical\nand nontechnical factors play a part in the final software system. Even simple\ndesign decisions can have far-reaching consequences. Architects must look\nbeyond a small neighborhood of design decisions and think about the system\nas a whole. Software design is a constant struggle to find the right balance between the\nthings you want and the reality you must accept. This means you must think\nabout and make trade-offs. Decide Trade-offs among Quality Attributes\nSay high availability is an important quality attribute for your stakeholders and\nyou need your software to respond to 99.9 percent of requests. One way to\npromote availability is to introduce redundant elements. Designing for this is\nsimple, but there\u2019s a catch. You now must purchase twice the hardware, which\ndoubles your costs. In this case, you traded costs to get higher availability. It is common in software development to give up something you want to get\nsomething you need. Architects identify the trade-offs and work with stake-\nholders to decide which compromises make the most sense. Software systems are never partitioned perfectly. You\u2019ll make compromises. You\u2019ll make mistakes. As you build the system, you\u2019ll introduce technical\ndebt into the architecture. Manage Technical Debt\nSoftware architects know the details about how the system is partitioned. They keep an eye on the big picture and guide how everything comes together. They also connect technology decisions with business needs. Knowing all this\nputs architects in the perfect position to manage technical debt. Technical debt is the gap between your software system\u2019s current design and\nthe design you need it to have so you can continue to deliver value. You can\nmeasure the amount of technical debt by estimating the effort required to\nclose that gap. All software has technical debt. Technical debt is an inevitable\nbyproduct of success. The best software development teams use technical\ndebt strategically to ship faster and regularly pay debt down so they can\ncontinue shipping value over time. Architects make technical debt visible and help stakeholders decide which\nactions to take to manage it. Chapter 1. Become a Software Architect \u2022 6\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 22", "position": 22, "chunk_type": "semantic", "token_estimate": 375}
{"text": "To create a structure, take any element and connect it to another element: using a relation. Think of elements and relations like the bricks and mortar\nof software. The bread and peanut butter. The duct tape and\u2026well, you get\nthe idea. Elements are the fundamental building blocks of software. Relations\ndescribe how elements work together to accomplish some task. It\u2019s easy to design an architecture on paper with no bearing on reality. To\navoid this trap, you\u2019ll build architectures using three types of elements and\nrelations. Software Architecture in Practice [BCK12] defines these three types\nas module, component and connector (C&C for short), and allocation. To create\na structure, combine elements and relations of the same type. Here are some example elements and relations of each type. Example Relations\nExample Elements\nuses, allowed to use,\ndepends on\nclass, package, layer, stored\nprocedure, module, configura-\ntion file, database table\nModule\ncall, subscribe, pipe,\npublish, return\nobject, connection, thread,\nprocess, tier, filter\nComponent and\nConnector\nruns in or on, responsi-\nble for, develops, stores,\npays for\nserver, sensor, laptop, load\nbalancer, team, Owen (a per-\nson), Docker container\nAllocation\nModule structures exist at design time. You interact with module structures\nwhen you write code. Module structures live on the file system and stick\naround even when the software is not running. Component and connector structures come into existence at runtime. At run-\ntime, components can create connections to other components, spawn new\nprocesses, and instantiate new objects. Unlike module structures, C&C\nstructures cease to exist when the system is not running. You might only\nknow a C&C structure existed from the artifacts it left behind, such as a log\nfile or database entry. Allocation structures are created by showing how module and C&C elements\ncorrespond with each other and the physical elements that exist in real\nlife. Allocation structures are sometimes called mapping structures since\nthey show how different elements map to one another. Does an element\nrun on the client machine or the server? Which teams are building which\nparts of the system? Allocation structures help us answer questions like\nthese. Chapter 1. Become a Software Architect \u2022 8\nreport erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 24", "position": 24, "chunk_type": "semantic", "token_estimate": 362}
{"text": "Joe asks:: Are Components and Modules Different Things? In your software development career you may have heard the words module and\ncomponent used interchangeably and in different contexts. Technically a component\nis a different concept from a module. A module refers to a design time element\nwhereas a component is a runtime idea. Sometimes this precision in language is important. Using a term with specific\nmeaning to describe something general can create confusion. Anytime you want to\ndescribe a generic building block of an architecture instead of using component or\nmodule, use the word element. All that said, arguing about semantics is not the best way to get your ideas across. While I encourage you to use proper and precise terminology, your ideas will sometimes\nget better mileage by adapting your language so others understand you. Different kinds of structures are useful for thinking about different properties\nyou want in your system. For example, you can think about testability and\nmaintainability using a module structure. A C&C structure helps us think\nabout runtime concerns such as availability or performance. You also might\nknow there\u2019s a gap in our understanding if you see mixed structures such as\na static element using a dynamic relation. Structures determine the shape of our system. The shape is important since\nit decides the quality attributes and other properties your users will experience. In the next section you\u2019ll see how to use structures to reason about quality\nattributes, but first, it\u2019s time get your hands dirty with a quick exercise. Get Your Hands Dirty: Elements, Relations, and Structures\nFind a few teammates from a recent project. Working alone, list or sketch\nmodule, component and connector, and allocation structures from that project. Share your lists with one another. How do they compare? Are there structures\nyour teammates identified that you didn\u2019t? Discuss the similarities and differ-\nences in the structures different teammates identified. Here are some things to think about:\n\u2022 Be specific when naming the elements. Don\u2019t forget about the relations! \u2022 Think about the module structures: What methods or classes are used? Do the classes live in different packages or namespaces? What dependen-\ncies are included in package managers or build scripts? report erratum  \u2022  discuss\nWhat Is Software Architecture? \u2022 9", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 25", "position": 25, "chunk_type": "semantic", "token_estimate": 377}
{"text": "\u2022 Think about the C&C structures: Does the software interact with other: processes or systems at runtime? Who calls the system and how does it\nchange in response? \u2022 Think about the allocation structures: Who is responsible for building\ndifferent parts of the software? How is the software deployed? Reason about Quality Attributes (and Other System Properties)\nSay you\u2019re building a calculator app and you want to add two numbers\ntogether. Sounds easy, right? ? What if \n=\n2 + 2\nIt takes 10 minutes to get an answer? Sometimes you get the wrong answer? You have to rewrite it to enable subtraction? This calculator \nstinks! My Amazing! Calculator App\nWait. Did you want a calculator that adds two numbers and is fast, reliable,\nscalable, and maintainable? Why didn\u2019t you say so! If we hadn\u2019t asked about\nthese quality attributes, we might have designed the wrong system altogether. A quality attribute is any externally visible characteristic by which stakeholders\njudge a software system\u2019s goodness. Some examples include scalability,\navailability, maintainability, and testability. You experience quality attributes\nwhen you interact with the software. When you choose an architectural structure, you are choosing the quality\nattributes you want to be promoted in the software system. Thinking about\nsoftware architecture makes sure you design a software system that supports\nthe quality attributes you want within the context of all the other concerns\nvying for attention. Quality attributes make software unique. The circumstances of every system\nare different\u2014different team, different budget, different market conditions,\nChapter 1. Become a Software Architect \u2022 10\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 26", "position": 26, "chunk_type": "semantic", "token_estimate": 262}
{"text": "then you can see how people can collaborate to develop software. The larger: the software system, the more important this becomes. 3. Software architecture provides a vocabulary for talking about complex\nideas. If I don\u2019t understand what you\u2019re talking about, then we won\u2019t be able to\ncollaborate. Instead of spending all our time inventing vocabulary and\nconcepts, we can use the essential concepts and core vocabulary of\narchitecture as the starting basis for collaboration. Now we can spend\nour time solving our users\u2019 real problems. 4. Software architecture looks beyond features and functionality. Features and functionality are important, but they are not the only thing\nthat determines whether or not software is awesome. When designing\narchitecture, you\u2019ll consider not only the features but also costs, con-\nstraints, schedules, risk, the ability of the team to deliver, and most\nimportantly quality attributes\u2014things like scalability, availability, perfor-\nmance, and maintainability. 5. Software architecture helps you avoid costly mistakes. In Who Needs an Architect? [Fow03], Martin Fowler defines software\narchitecture as \u201c\u2026the important stuff. Whatever that is.\u201d The important\nstuff is nearly always what we think will be difficult to change without\nsignificantly increasing complexity. Grady Booch echoes Fowler\u2019s sentiment\nby defining architecture as the \u201c\u2026significant design decisions (where\nsignificant is measured by the cost of change).\u201d\n1 Software architects are\nnot omniscient, but designing an architecture will help you discover the\nchallenging (and interesting) parts of the problem that might cause big\ntrouble later. 6. Software architecture enables agility. Your software should respond to change like water, by bending around\nobstacles with ease. If software is like water, able to take any shape, then\nsoftware architecture is the container that holds it. That container can\nbe rigid like a box or flexible like a plastic bag. It can be thick and heavy\nor lightweight. Without an architecture, software, like water, follows the\npath of least resistance and sprawls uncontrollably. A software system\u2019s\narchitecture provides the structure within which change is possible. We\u2019ll expand on these ideas throughout the remainder of the book. 1. Grady Booch. Abstracting the Unknown. SATURN 2016. http://resources.sei.cmu.edu/library/\nasset-view.cfm?assetID=454315\nreport erratum  \u2022  discuss\nBuild Amazing Software \u2022 13", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 29", "position": 29, "chunk_type": "semantic", "token_estimate": 359}
{"text": "code so that it\u2019s possible to see module structures in the architecture. Making: is also an excellent way to push your team out of analysis paralysis. Evaluate Fit\nHow do you know if a design decision will solve the problem? When we\nembrace the evaluate mindset, we determine the fitness of our design decisions\nrelative to our current understanding. Evaluation is not an all or none proposition. We can evaluate all or part of\nthe architecture, even only a single model, concept, or idea. The most common\napproach is to walk through a piece of the architecture with different scenarios,\nbut we can also test design decisions directly by running experiments or\nexamining the risks surrounding a decision. The evaluate mindset comes in handy when we want to verify the planned or\nbuilt architecture, but this is only the beginning. This mindset will help us\ninspect anything we make and decide whether that artifact is serving our need. Using design mindsets requires a process with a tight feedback loop so we\ncan quickly move from one mindset to the next. In the next section, we\u2019ll learn\nhow to use a simple, iterative approach to help us choose and use design\nmindsets. Get Your Hands Dirty: Understand, Explore, Make, Evaluate\nThe four design thinking mindsets reflect how people solve problems. Even\nwithout training in design thinking, you have probably used these mindsets\nbefore. What are some examples of how you embraced each of these mindsets\nso far in your software development career? Try to name at least two examples\nof how you worked in each design mindset. Here are some things to think about:\n\u2022 When have you worked with people to understand a problem? Did you\nfollow a particular method? \u2022 How have you collaborated with others to explore ideas and generated\nalternatives? \u2022 Looking beyond code, how do the things you make change how you\ninteract with stakeholders and teammates? \u2022 How do you evaluate your designs? What techniques have you used to\ntest solution hypotheses? Chapter 2. Design Thinking Fundamentals \u2022 20\nreport erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 36", "position": 36, "chunk_type": "semantic", "token_estimate": 348}
{"text": "constraint and this increases the risk that the architecture will be unable to: satisfy performance requirements. \u2022 Think. We know system performance is important, but we don\u2019t know\nwhat it means to have good performance. Since we need information about\nthe problem, let\u2019s adopt the understand mindset. Looking through some\npractices in Chapter 14, Activities to Understand the Problem, on page 191,\nwe decide to capture quality attribute scenarios. \u2022 Do. We brainstorm some performance scenarios and record them in a\ndocument. \u2022 Check. The team and stakeholders review the scenarios and provide\nfeedback. Based on what we learned, new risks arise. Can we achieve the performance\nquality attribute scenarios given the new constraint? \u2022 Think. Since we need to verify that our decisions promote a specific\nquality attribute let\u2019s adopt the evaluate mindset. We plan an experiment\nso we can directly test the constraint\u2019s impact on performance. \u2022 Do. We write some simple scripts to drive existing parts of the software\nsystem and collect data. We run the experiment. \u2022 Check. With data in hand, we examine the results and conclude that the\nnew constraint negatively impacts performance but only by a few 100\nmilliseconds. We think we\u2019ve done a thorough job, but performance is funny. Hurting per-\nformance might not be a big deal until it degrades too much. We need to share\nthese results with our stakeholders and discuss the implications of the new\nconstraint. \u2022 Think. Since making ideas tangible facilitates communication, we\u2019ll adopt\nthe make mindset and create a simple prototype. We want stakeholders\nto experience the impact of the new constraint. Graphs aren\u2019t enough. \u2022 Do. We develop a throwaway prototype that demonstrates the application\nworkflow and simulates different assumptions about performance. \u2022 Check. We give the prototype to our stakeholders and explain why the\nperformance of the system was impacted. On paper, a few 100 milliseconds\nis tiny, but experiencing the slowdown firsthand shows that this dip in\nperformance isn\u2019t acceptable. report erratum  \u2022  discuss\nThink, Do, Check \u2022 23", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 39", "position": 39, "chunk_type": "semantic", "token_estimate": 337}
{"text": "The prototype helped our stakeholders learn something about the problem: nobody knew was important until now. Next, we\u2019ll adopt the understand\nmindset and refine our new requirements. We check our understanding a few\nminutes in the same meeting by selecting the explore mindset. And the cycle\ncontinues. The think-do-check cycle is extremely flexible. How you use it depends on\nthe complexity and size of the system, your team\u2019s size and skills, and your\nexperience with having simultaneous design initiatives in flight. Next Up\nDesign thinking gives us a way to connect the highly technical world of soft-\nware development with the humans affected by the software we build. The\nfour HART principles are the means by which we\u2019ll give our software heart\n(pun 100 percent intended). Design mindsets are the way we\u2019ll decide what\nneeds to be done to help our stakeholders. Now that we\u2019ve covered the theory, it\u2019s time to get down to business. Since the invention of software, we have debated how much architecture\ndesign should happen up front and how much can emerge as we implement\na solution. Like any discussion about extremes, the real answer lies somewhere\nin the middle. In the next chapter, you\u2019ll see how to define a design strategy\nappropriate to your situation and choose design mindsets by considering the\nrisks in the software system. Chapter 2. Design Thinking Fundamentals \u2022 24\nreport erratum  \u2022  discuss", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 40", "position": 40, "chunk_type": "semantic", "token_estimate": 233}
{"text": "CHAPTER 3: Explore\nUnderstand\nMake\nEvaluate\nDevise a Design Strategy\nDesigning software architecture always feels a bit chaotic. Despite the swirl\nof uncertainty surrounding every software system, it\u2019s important to have a\nplan. With a solid design strategy, we can feel our way through the mists of\nuncertainty. Design thinking is perfect for finding solutions to complex problems. Instead\nof trying to solve the problem perfectly on the first try, design thinking\nemphasizes learning and experimentation. Testing an architecture might be\nimpossible without implementing it, but it may be possible to verify pieces of\nthe architecture incrementally as we design them. We can use design mindsets\nand the think-do-check cycle to decide where to focus our attention next. In Chapter 2, Design Thinking Fundamentals, on page 15 you learned the\nbasic rules of design thinking and how to use design mindsets. In this chapter,\nyou\u2019ll learn how to choose design mindsets as part of a broader design strat-\negy by thinking about the risks in the software system. Find a Design That Satisfices\nIn a rational world, we\u2019d fully define the problem before designing a perfect\narchitecture to solve it. Too bad we don\u2019t live in a perfect, rational world. In\nThe Sciences of the Artificial [Sim96], Herbert Simon coined the term bounded\nrationality to describe the theoretical barrier created by limits in time, money,\nskills, and knowledge that make rational design challenging for complex\nproblems such as software architecture. Instead of rationally seeking an optimal design, our goal is to find an archi-\ntecture that satisfices. A satisficing design is both satisfactory and suffi-\ncient\u2014good enough\u2014for our needs. report erratum  \u2022  discuss", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 42", "position": 42, "chunk_type": "semantic", "token_estimate": 273}
{"text": "Instead of thinking of software architecture as a design optimization problem,: we\u2019ll look for a satisficing design by emphasizing the following activities. Treat solutions as experiments. Architects are not omniscient sages of\ntechnology who know all things. Think of every potential solution as an\nexperiment to be validated. The sooner, faster, and cheaper we can validate\n(or invalidate) our hypotheses, the sooner we\u2019ll find the right combination\nof structures that will help our stakeholders and the sooner our stakehold-\ners will gain value from our designs. Focus on reducing risks. Value is only one variable that must be considered. Architecture is the foundation of the software system. If it fails, then\neverything fails. Architects must constantly worry about what could go\nwrong and design for these scenarios. We can use risk to help us decide\nwhat to design next. Work to simplify problems. Simple problems often have simple solutions. There are many ways to simplify the problem. Reducing the number of\nstakeholders will decrease the variety of competing perspectives influencing\nthe system. Adding or removing constraints, or focusing on a subset of\nthe problem can reduce complexity. Identifying the routine problems makes\nit easier to focus on redesign. Routine problems have a known solution\nso we can start with pattern catalogs and apply our collective experience\nwhen exploring solutions. Iterate quickly to learn quickly. The faster we learn, the more we can explore,\nand the greater confidence we\u2019ll have in our solutions. If we\u2019re wrong, let\u2019s\nfind out as quickly as possible. Failing fast means learning fast. Favor\nshort, tight design iterations with concrete outcomes over longer design\niterations that only focus on abstract goals. Think about the problem and solution at the same time. In Notes on the\nSynthesis of Form [Ale64], Christopher Alexander shows how problems\nare always defined with a solution in mind. The boundary around a\nproblem is created by the solutions that could potentially solve it. To\nunderstand the problem, we must explore solutions. To do a better job\nof exploring solutions, we must improve our understanding of the problem. Designing software architecture requires us to think about problems and\nsolutions simultaneously. Writing some code early in the design process\nis one strategy for dealing with the reciprocal relationship between prob-\nlems and solutions. Avoiding rational design does not mean we suddenly become irrational\narchitects. Architecture is the foundation of every software system, so we still\nChapter 3.", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 43", "position": 43, "chunk_type": "semantic", "token_estimate": 403}
{"text": "Instead of thinking of software architecture as a design optimization problem,: Avoiding rational design does not mean we suddenly become irrational\narchitects. Architecture is the foundation of every software system, so we still\nChapter 3. Devise a Design Strategy \u2022 28\nreport erratum  \u2022  discuss", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 43", "position": 43, "chunk_type": "semantic", "token_estimate": 45}
{"text": "need do some design work up front. We\u2019ll need to decide how much of the: architecture we\u2019ll design up front and how much we\u2019ll allow to emerge over\ntime. Selecting a design strategy early in a software system\u2019s life tells our\nteam how we want to grow the architecture and instills confidence in our\nstakeholders. Decide How Much to Design Up Front\nArchitecture is a necessary investment. Every software system has an archi-\ntecture. One way or another, you will spend time designing it. If we spend\ntime designing architecture up front, then we\u2019ll reduce the cost of future\nrework. Of course, time spent planning architecture also delays implementa-\ntion thus potentially delaying value for stakeholders. If we spend no time up\nfront on architecture, then we are more likely to make changes to the archi-\ntecture after developing parts of the software system. Depending on the software system\u2019s size and requirements variability, every\nsoftware systems has a design sweet spot, an optimal amount of time to spend\ndesigning architecture before diving into implementation. Find the Design Sweet Spot\nIn Architecting: How Much and When? [BWO10], Barry Boehm shows us that\nthe combination of development time, architecture planning, and rework are\nmajor contributing factors to the overall project schedule. Rework includes\nactivities such as fixing design defects, rewriting code, and undoing mistakes. To find the sweet spot, we must account for both design costs and the\ninevitable rework required to complete the software system. Development Time\nArchitecture and Risk Reduction Time\nRework Time (fixing defects, rewrites, mistakes)\nTotal Project Time\n+\nNote: Time spent on architecture can\nspeed up development and reduce rework! The architecture sweet spot is highly dependent on the size, requirements\nvolatility, and complexity of the software you\u2019re developing. The graph on\npage 30 from Boehm\u2019s data [BWO10] shows how the amount of rework\ndecreases as more time is invested in architecture planning. The solid green\nreport erratum  \u2022  discuss\nDecide How Much to Design Up Front \u2022 29", "domains": ["Design Patterns", "Design Principles"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 44", "position": 44, "chunk_type": "semantic", "token_estimate": 332}
{"text": "This graph is packed with important implications, so let\u2019s break down the: essential points. Chapter 3. Devise a Design Strategy \u2022 30\nreport erratum  \u2022  discuss", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 45", "position": 45, "chunk_type": "semantic", "token_estimate": 26}
{"text": "Of course, more architecture does not always mean we\u2019ll have a shorter: schedule. If we spent a third of the estimated development time on architec-\nture, we\u2019d increase the total development schedule. While we\u2019d spend signifi-\ncantly less time on rework, the extra time dedicated to architecture doesn\u2019t\npay off since the overall project schedule increases by about 40 percent. Here are the numbers assuming our estimated 100-day initial development\nschedule:\nDays in\nTotal Schedule\nDays Spent\non Rework\nDays Spent\non Architecture\n143\n38\n5\n138\n21\n17\n140\n7\n33\nThe Constructive Systems Engineering Model (COSYSMO) includes Boehm\u2019s\nfindings. I suggest you try the COSYSMO and COCOMO II tools with your\nproject data. 1\nThanks to Boehm\u2019s work, we have a general idea for how much time to spend\non architecture design, but we still don\u2019t know when to do the design work\nor when to adopt the different design mindsets introduced in Chapter 2,\nDesign Thinking Fundamentals, on page 15. It turns out Boehm also has an\nanswer for this (yes, he is that awesome). In Using Risk to Balance Agile and\nPlan-Driven Methods [BT03], Barry Boehm and Richard Turner propose using\nrisk to decide when to focus on architecture. If we think about risk in the\nright ways, we can also use it to determine what to design and how to involve\nstakeholders in the design process. Let Risk Be Your Guide\nShortly after the first stakeholder meeting on a new software project, I always\nfeel a giant pit grow in my stomach. If I didn\u2019t have that feeling, then I would\nbe worried. Software worth building always has risks. You should feel a bit\nuncomfortable at the start of a new project. After all, if you knew everything\nat the outset and had no questions about what you were going to build, then\nwhy would an architect be needed? We can use that slight sinking feeling in our guts to our advantage. Risk is an\nexcellent indicator of what might prevent us from succeeding. To harness the\npower of our guts, write down all the things that worry you about the software\n1.\nhttp://sunset.usc.edu/csse/research/cocomoii/cocomo_main.html\nChapter 3. Devise a Design Strategy \u2022 32\nreport erratum  \u2022  discuss", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 47", "position": 47, "chunk_type": "semantic", "token_estimate": 371}
{"text": "\u2022 Accept it and do nothing. Sometimes people eat too many burritos: (mmmm\u2026 guacamole). We\u2019ll deal with the repercussions if the risk converts\ninto a problem. Knowing the condition and the consequence creates hooks for deciding what\nto do about the risk. Compare our <Condition>; might <Consequence> risk\nwith these other, less effective risk statements:\nWhy It\u2019s Bad\nBad Risk Statement\nSo what? The negative impact is unclear. In fact, this sounds great. We love burritos! New burrito restaurant opened. This sounds bad, but why should we be\nworried about this now? The team might overindulge in\nburritos. True, but what does this have to do with\nmy team? Eating too many burritos can\nmake you sick. And if a radioactive meteorite falls on the\noffice, we\u2019ll get sick too. What led you to\nbe worried about burritos? If a teammate eats too many\nburritos, he or she will get sick. OK, enough about burritos. Let\u2019s get back to software design. Use Risk to Choose a Design Mindset\nSoftware architecture design is an exercise in risk reduction. Every time you\nthink, I\u2019ve got a bad feeling about this, it\u2019s a sign there\u2019s a risk looming nearby. If you can pick a condition and consequence that captures the essence of your\nbad feeling, then we can use that information to guide our design activities. Here are some example risks from a past project I worked on and the design\nactivities the team used to reduce the risk:\nThe Model Training service was originally built for a different purpose; might\noverload it with new requests. Design Mindsets: Understand, Evaluate\nWhat we did: Talked to the team who built the Model Training service to\nunderstand scalability, ran experiments to measure throughput. Data processing is time consuming and resource intensive; might not be\nable to finish processing jobs without failures. Design Mindset: Explore\nWhat we did: Brainstormed approaches for promoting reliability, researched\njob scheduling patterns, and sketched alternative designs that might\nreduce processing time. Chapter 3. Devise a Design Strategy \u2022 34\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 49", "position": 49, "chunk_type": "semantic", "token_estimate": 342}
{"text": "A lot of data is needed to train a statistically significant model; might not: be profitable due to data storage costs at scale. Design Mindset: Make\nWhat we did: Created a cost estimation model. The model demonstrated\npros and cons of different design options to stakeholders. Pushed out the\nrisk\u2019s time frame by changing backlog priorities. Stored data may contain sensitive customer information; might require\nstricter data isolation than we can provide. Design Mindset: Evaluate\nWhat we did: Rated available compute platforms based on how well each\nmet our needs. Engineering risks help us decide what to design. Design mindsets help us\ndevise a strategy to decrease the risk. When facing a risk that must be reduced,\nfirst decide which parts of the risk you can address\u2014condition, impact, proba-\nbility, or time frame. Next, choose a design mindset. Here are some questions\nto help decide which design mindset might be appropriate:\nIf\u2026\nTry\u2026\nThe risk is about the problem. Do you need a deeper\nunderstanding of stakeholders or other system\nactors? Understand Mindset\nThe risk about the solution. Have you seen enough\nsolution alternatives? Explore Mindset\nThe risk is about communication. Do stakeholders\nfully understand design concepts at play and can\nthey see the architecture? Make Mindset\nThe risk involves a design decision or the design\u2019s\noverall fit. Do we need to make a design decision? Evaluate Mindset\nRisks are the GPS for our design process. They tell us where we are, where\nwe\u2019re going, and how much we have left to design. With each loop through\nthe think-do-check cycle discussed on page 21, think about the risks and\nuse them to decide what to do next. Shift to Passive Design Once Risks Are Reduced\nIn Just Enough Software Architecture: A Risk-Driven Approach [Fai10], George\nFairbanks tells us that architects should work to reduce technical risks to\nthe point where architecture is no longer the biggest source of risk in the\nreport erratum  \u2022  discuss\nLet Risk Be Your Guide \u2022 35", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 50", "position": 50, "chunk_type": "semantic", "token_estimate": 332}
{"text": "system. Once we have reduced enough of the architectural risks, whatever: that means for the software system, then our time is better spent elsewhere. Once architecture is no longer the greatest source of risk in the system, shift\nfrom active design to passive design, as shown in the graph. With active\ndesign, we drive the design process in the pursuit of reducing risk. With\npassive design, we observe the architecture as it manifests in the working\nsystem and take corrective actions as necessary. Engineering \nRisk\nTime\nRisk Threshold\nActively work to reduce \nrisks in the architecture\nPassively monitor the \narchitecture and address issues\nHigh\nLow\nDon\u2019t be tricked by the name. There is still a lot for an architect to do in passive\ndesign mode. We might correct errant documentation or improve missing\ndocuments. We\u2019ll make minor adjustments to the architecture as new informa-\ntion emerges. We\u2019ll teach our teammates about the architecture by pairing\nand reviewing code. Most importantly, we\u2019re on the front line in the fight against\narchitectural erosion and other issues, discussed on page 172. Even with careful vigilance, architecture could reemerge as a significant risk. New risks might emerge. The implemented system could drift too far from\nour plans. We could learn that our assumptions about the world are wrong\nor that the world around us changed. When these things happen, switch back\nto active design and adjust the architecture based on the new realities. Now that you know how to use risk to help you decide what to design, let\u2019s\npull together everything you\u2019ve learned in this chapter by ceating an architec-\nture design plan. Create a Design Plan\nDesign plans outline a general strategy for how the team will spend their time\non architecture. Will we do more analysis up front? Are we expecting change\nlater? When do we start writing code? A good design plan sets expectations\nand explains these details. Chapter 3. Devise a Design Strategy \u2022 36\nreport erratum  \u2022  discuss", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 51", "position": 51, "chunk_type": "semantic", "token_estimate": 330}
{"text": "Project Lionheart: The Story So Far\u2026: Next week you\u2019ll go on site to gather requirements from the mayor and other\nstakeholders. We have a fixed final due date in about six months. We need\nto focus on value up front and deliver as fast as possible. It also sounds like\nthe core functional requirements will be based on an existing process, so\nthere is a low probability of requirements churn. The solution seems like a classic data-driven web application with some\nsearch features. Based on the mayor\u2019s description, security and privacy could\nbe a key concern. We also know that the city\u2019s IT department will take over\nthe software system after us. That group may impose some unique constraints. You send Mayor van Damme an agenda for the on-site visit. Our biggest risks\nright now can be addressed by digging for information, so for now you\u2019ll focus\non getting to know our stakeholders. We think we can get away with very little\nup-front design and want to concentrate on delivering value faster, even if\nthat means rewriting parts of the application later. The team wants to start\nwriting code immediately after a two-week design spike. Next Up\nOne way or another, you\u2019ll pay for your architecture either through up-front\ndesign or downstream rework. In this chapter, you learned how to use risk\nto plan our design activities. Risks can help us decide how much work to do\nup-front. We can also use risk to decide which design mindsets to adopt. One of the first risks many teams face on a new software system, even if it\u2019s\nonly new to you, is understanding who the software is meant to help. In the\nnext chapter, you\u2019ll learn how to embrace the understand mindset by devel-\noping empathy for the humans who benefit from the software you develop. When you can walk in your stakeholders\u2019 shoes, you\u2019ll get a deeper under-\nstanding of their actual needs. Understand stakeholders\u2019 real needs, and you\nimprove your chance of solving the right problem. Chapter 3. Devise a Design Strategy \u2022 38\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 53", "position": 53, "chunk_type": "semantic", "token_estimate": 349}
{"text": "Here are some stakeholders for the Project Lionheart Case Study, introduced: on page 14. In this picture, the icons represent specific people or roles while\nspeech bubbles show stakeholders\u2019 thoughts and feelings. I love security. I hate downtime. We want to \nmake awesome \nsoftware! We need to cut the \ncity s operating costs. We make a living \nselling goods and \nservices to the city. We manage the\ncity s contracts and find \nthe best prices. Some Project Lionheart Stakeholders\nDev Team\nSystem \nAdministrator\nMayor ($$$)\nLocal Businesses \n(User)\nOffice of Management \nand Budget (User)\nStakeholders are interested in what we\u2019re building and will influence the\narchitecture we design. Since we\u2019ll want to invite these people to future design\nworkshops, we should find out who they are. Enter the stakeholder map. Bett says:\nIt\u2019s About the Customer\nBy Bett Bollhoefer, software architect at General Electric\nArchitecture is about the customer. If I create an architecture that doesn\u2019t give value\nto the customer, I am wasting my time. When I talk to customers, I often hear horror\nstories about how their current systems were developed by someone in an ivory tower\nwho didn\u2019t understand them or their work. How do I make sure I am bringing value\nto customers through my architecture? My answer is to use a customer-centric design process. I start with who the customer\nis and what they want to do. I divide the system into tasks the customer performs. For each task, I find out how they start it and where they run into issues. You might be thinking, \u201cThis doesn\u2019t sound like architecture\u2014it sounds like user\nexperience!\u201d Yes, it is, but many UX designers don\u2019t understand the technical aspects\nof the system well enough to determine the architecture. My process goes beyond the\nChapter 4. Empathize with Stakeholders \u2022 40\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 55", "position": 55, "chunk_type": "semantic", "token_estimate": 307}
{"text": "surface to ensure the deep structures support the customer\u2019s values. I call it Customer: Experience Architecture. Step 1: Determine what matters to the customer, including their functional require-\nments and quality attributes, by watching how they do the task in their natural\nenvironment and asking lots of why\u2019s. Step 2: Design the system around the customer\u2019s needs and document it in a proto-\ntype. The prototype should be as interactive as possible, not just a flowchart. Step 3: Review the prototype as early as possible with the customer. Make sure they\nreally understand what is changing in the new system and how it will impact them. Step 4: Revise the architecture based on feedback from the customer\u2019s review. Using these four steps, you can create value for your customer through your archi-\ntecture and become their hero, or at least not the person in the ivory tower who is\nruining their life. Create a Stakeholder Map\nA stakeholder map is a network diagram showing all the people involved with\nor affected by the proposed software system. Stakeholder maps are ideal for\nvisualizing relationships and interactions among people. They also give you\na snapshot of what motivates different stakeholders. Use stakeholder maps\nto decide who the most important people are to talk to about their concerns. Every time I create a stakeholder map, I\u2019m surprised to see how many people\nI might touch with the software I build. There\u2019s a partial stakeholder map for\nProject Lionheart on page 42. There are several stakeholders not shown on this diagram for the sake of sim-\nplicity. Additional stakeholders include IT vendors we might have to collaborate\nwith, the Chamber of Commerce (or other lobbying organizations), the deputy\nmayor, and various community groups who receive services from the city. The\ncity departments stakeholder can be made more precise by dividing it into the\nboard of education, parks and recreation, public works, sanitation, and so on. If these groups have a similar stake in the system, then they could be lumped\ntogether as shown. As a rule of thumb, it\u2019s best to be as specific as possible. Step back and look at the stakeholder map after you\u2019ve created it. Who is paying\nfor the software? Who is using it? Are there network hubs with many incoming\nor outgoing arrows? Are there stakeholders with potential conflicts of interest? These people are all excellent candidates for interviews and further research. report erratum  \u2022  discuss\nCreate a Stakeholder Map \u2022 41", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 56", "position": 56, "chunk_type": "semantic", "token_estimate": 413}
{"text": "You can build a stakeholder map by yourself, but it\u2019s more fun to create them: in groups. The steps for this activity are outlined in Activity 10, Stakeholder\nMap, on page 221. Get Your Hands Dirty: Create a Stakeholder Map\nPick an open source project you use or contribute to and create a stakeholder\nmap for it. Take a picture of it and share it on this book\u2019s forum. 1 Here are\nsome things to think about:\n\u2022 Is there an organization that oversees or funds the project? Are there sub-\ngroups within the organization who might have different vested interests? \u2022 Who are the biggest contributors to the project? \u2022 How is the project licensed? Who benefits from the choice of license? \u2022 Who uses the project? What problems are they trying to solve? Discover the Business Goals\nEvery software system is built to serve some fundamental purpose. Business\ngoals describe what stakeholders hope to accomplish with the software. Business goals also seed conversations about quality attributes, trade-offs,\nand technical debt. Business goals are a primary architectural driver and help prioritize competing\nconcerns. The better everyone understands stakeholders\u2019 needs, the better you\u2019ll\nbe able to help them. Here\u2019s a summary of common business goal categories:\nWhat they want\nWho wants it\nIncrease wealth, power, reputation, personal enjoyment,\nor knowledge\nIndividuals\nIncrease revenue, maximize profits, grow the business,\nbecome a market leader, improve stability, enter a new\nmarket, beat a competitor\nOrganizations\nInteresting and meaningful work, increase knowledge, help\nusers, become recognized as an expert\nEmployees\nImprove specific quality attributes, reduce costs, add new\nfeatures, implement a standard, improve time-to-market\nDevelopment\nTeam\nSecurity, civic welfare, social responsibility, legal compliance\nNations,\ngovernments\n1.\nhttp://pragprog.com/book/mkdsa/design-it\nreport erratum  \u2022  discuss\nDiscover the Business Goals \u2022 43", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 58", "position": 58, "chunk_type": "semantic", "token_estimate": 293}
{"text": "constraints limit choice, but well-chosen constraints simplify the problem: and can make it easier to design a satisficing architecture. Sometimes con-\nstraints create a living hell for architects by limiting options so severely we\nare unable to satisfy other requirements. Constraints can influence technical or business concerns. Business con-\nstraints limit decisions about people, process, costs, and schedule. Technical\nconstraints limit decisions about the technology we may use in the software\nsystem. Here are some examples of each:\nBusiness Constraints\nTechnical Constraints\nTeam Composition and Makeup\nProgramming Language Choice\nTeam X will build the XYZ component. Anything that runs on the JVM. Schedule or Budget\nOperating System or Platform\nIt must be ready in time for the Big\nTrade Show and cost less than\n$800,000. It must run on Windows, Linux,\nand BeOS. Legal Restrictions\nUse of Components or Technology\nThere is a 5 GB daily limit in our\nlicense. We own DB2 so that\u2019s your\ndatabase. Capture Constraints as Simple Statements\nTo capture a constraint, describe the decision and its origin in a brief state-\nment. There are some constraints for the Project Lionheart system in the table\non page 51, introduced on page 14. Constraints, once decided, are 100 percent non-negotiable. Be conservative in\naccepting constraints. There is a huge difference between this must be done or\nyou will fail and this should be done unless you have a good reason not to do it. As the software system emerges, design decisions can become constraint-like. Distinguishing between the constraints we created and the ones we were\ngiven becomes more difficult as the system grows. Like barnacles on a ship,\nsoftware slowly gains cruft and becomes less nimble, less clean, less malleable. Eventually, it may become so difficult to amend the architecture that those\nearly design choices become constraints for future designers. As constraints emerge, be careful to distinguish the constraints chosen for\nyou from the constraints you give yourself. Though it may be difficult, you\nalways have the option of changing a constraining design decision. Chapter 5. Dig for Architecturally Significant Requirements \u2022 50\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 64", "position": 64, "chunk_type": "semantic", "token_estimate": 350}
{"text": "Context: Type\nOrigin\nConstraint\nThe City has an Open\nData policy and citizens\nBusiness\nMayor van\nDamme\nMust be developed\nas open source\nsoftware. must have access to\nsource code. Decreases concerns about\nsoftware delivery and\nmaintenance. Technical\nMayor van\nDamme\nMust build a\nbrowser-based web\napplication. Avoids end of fiscal year\nbudget issues. Business\nMayor van\nDamme\nMust ship by the\nend of Q3. Officially supported\nbrowser. Technical\nCity IT\nMust support latest\nFirefox web browser. City uses Linux and open\nsource where possible. Technical\nCity IT\nMust be served from\na Linux server. Define the Quality Attributes\nQuality attributes describe externally visible properties of a software system\nand the expectations for that system\u2019s operation. Quality attributes define\nhow well a system should perform some action. These -ilities of the system\nare sometimes called quality requirements. Here is a list of some common\nquality attributes from Software Architecture in Practice [BCK12]. Conceptual Properties\nRuntime Properties      \nDesign Time Properties\nManageability\nAvailability\nModifiability\nSupportability\nReliability\nMaintainability\nSimplicity\nPerformance\nReusability\nTeachability\nScalability\nTestability\nSecurity\nBuildability or Time-to-Market      \nEvery architecture decision promotes or inhibits at least one quality attribute. Many design decisions promote one set of quality attributes while inhibiting\nothers that are also important! When this happens, we\u2019ll trade one quality\nattribute for another by choosing a structure for the architecture that favors\none quality attribute but harms others. When digging for ASRs, we\u2019ll spend most of our time working with quality\nattributes. Quality attributes are used throughout the design process to guide\ntechnology selection, choose structures, pick patterns, and evaluate the fitness\nof our design decisions. report erratum  \u2022  discuss\nDefine the Quality Attributes \u2022 51", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 65", "position": 65, "chunk_type": "semantic", "token_estimate": 275}
{"text": "Joe asks:: Are Quality Attributes Non-functional\nRequirements? Traditional software engineering textbooks usually discuss two classes of requirements. Functional requirements describe the behavior of the software system. Non-functional\nrequirements describe all system requirements that aren\u2019t functional requirements,\nincluding what we\u2019re calling quality attributes and constraints. When you are designing a software architecture, it\u2019s useful to distinguish between\nfunctionality, \nconstraints, \nand \nquality \nattributes \nbecause \neach \ntype \nof \nrequirement \nimplies\na different set of forces are influencing the design. For example, constraints are non-\nnegotiable whereas quality attributes can be nuanced and involve significant trade-offs. Yes, quality attributes are non-functional requirements, but it is strange to use this\nterm to describe them since quality attribute scenarios (sometimes called quality\nrequirements) have a functional piece to them. Quality attributes make sense only\nin the context of system operation. In a quality attribute scenario, an artifact\u2019s\nresponse is the direct result of some function. Capture Quality Attributes as Scenarios\nA quality attribute is just a word. Scalability, availability, and performance\nare meaningless by themselves. We need to give these words meaning so we\nunderstand what to design. We use a quality attribute scenario to provide an\nunambiguous description of a quality attribute. Quality attribute scenarios describe how the software system is expected to\noperate within a certain environmental context. There is a functional compo-\nnent to each scenario\u2014stimulus and response\u2014just like any feature. Quality\nattributes scenarios differ from functional requirements since they qualify\nthe response using a response measure. It is not enough just to correctly\nrespond. How the system responds is also important. The diagram on page\n53 visually depicts the six parts of a quality attribute scenario. Stimulus The stimulus is an event that requires the system to respond in\nsome way. The stimulus kicks off the scenario and will vary depending\non the type quality attribute. For example, the stimulus for an availability\nmight be a node becoming unreachable whereas the stimulus for a modi-\nfiability scenario might be a request for a change. Source The source is the person or system that initiations the stimulus. Examples include users, system components, and external systems. Chapter 5. Dig for Architecturally Significant Requirements \u2022 52\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 66", "position": 66, "chunk_type": "semantic", "token_estimate": 365}
{"text": "Response: Artifact\nSource of \nStimulus\nEnvironment Context\nStimulus\nResponse Measure\nPart of\nthe system\nCondition that \nrequires a response\nState of the system\n(examples: normal, peak load)\nObservable action that \nresulted from stimulus\nSpecific,\nmeasurable, testable\nPerson or system that \ngenerates the stimulus\nArtifact The artifact is the part of the system whose behavior is characterized\nin the scenario. The artifact can be the whole system or a specific component. Response The response is an externally visible action that takes place in the\nartifact as a result of the stimulus. Stimulus leads to response. Response Measure The response measure defines the success criteria for the\nscenario by defining what a successful response looks like. Response\nmeasures should be specific and measurable. Environment Context The environment context describes the operational\ncircumstances surrounding the system during the scenario. The environ-\nment context should always be defined even if the context is normal. Abnormal contexts, such as peak load or a specific failure condition, are\nalso interesting to consider. Here is an example portability scenario for an interplanetary robotic explorer\nbased on examples from the NASA Jet Propulsion Laboratory [WFD16]. Test results\nMission flight \ncontrol \nsystem\nTest Team\nNew, Supported Hardware Platform\nRuns test \nsuite\nAll tests pass with \nno code change\nPortability Scenario for a Mars Rover (via NASA JPL)\nRaw scenario: Processors and platforms are typical variation points project to \nproject. Enabling projects to select processors and platforms with minimal \neffects to applications allows for system optimization. Source\nStimulus\nArtifact\nResponse \nMeasure\nResponse\nreport erratum  \u2022  discuss\nDefine the Quality Attributes \u2022 53", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 67", "position": 67, "chunk_type": "semantic", "token_estimate": 262}
{"text": "Notice that the raw scenario in our example doesn\u2019t mention specific response: measures. Raw scenarios are simple descriptions that form the basis for more\nprecise quality attribute scenarios. We call them raw because they need further\ncooking to become a good scenario. Think of a raw scenario as the start of a\nconversation. Specifying all six parts of a formal quality attribute scenario is not always\nnecessary. You can often get by with a simple statement that includes the\nstimulus, source, response, and response measure. Add the environment\nwhenever the scenario does not describe a normal environmental context. Here are some quality attribute scenarios for the Project Lionheart case study:\nPriority\nScenario\nQuality Attribute\nHigh\nWhen the RFP database does not respond, Lionheart\nshould log the fault and respond with stale data\nwithin 3 seconds. Availability\nHigh\nA user\u2019s searches for open RFPs and receives a list\nof RFPs 99% of the time on average over the course\nof the year. Availability\nLow\nNew servers can be added during a planned main-\ntenance window (less than 7 hours). Scalability\nHigh\nA user sees search results within 5 seconds when\nthe system is at an average load of 2 searches per\nsecond. Performance\nLow\nUpdates to RFPs should be reflected in the applica-\ntion within 24 hours of the change. Reliability\nLow\nA user-initiated update (for example, starring an\nRFP) is reflected in the system within 5 seconds. Availability\nLow\nThe system can handle a peak load of 100 searches\nper second with no more than a 10% dip in average\nresponse times. Availability\nLow\nData growth is expected to expand at a rate of 5%\nannually. The system should be able to grow to\nhandle this with minimal effort. Scalability\nA good-quality attribute scenario communicates the intent of the requirement\nso anyone can understand it. Great scenarios are precise and measurable. Two people who read the same quality attribute scenario should come away\nwith the same understanding of the system\u2019s scalability or performance or\nmaintainability. Chapter 5. Dig for Architecturally Significant Requirements \u2022 54\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 68", "position": 68, "chunk_type": "semantic", "token_estimate": 348}
{"text": "Strive for Specific and Measurable Response Measures: To create a response measure, start by estimating potential values based on\nyour own experience. Use a straw man to kick off a conversation with stake-\nholders (see Activity 9, Response Measure Straw Man, on page 219). What if it\ntook nine months to migrate the system to a new microcontroller platform,\nwould that work? How about six months? Eventually, you\u2019ll find a response\nmeasure that resonates with stakeholders. Good response measures are testable. Early in the system\u2019s life, the architec-\nture might exist only on paper, but it\u2019s just a matter of time before you have\na running system. If you can\u2019t write a test using your scenario, then the sce-\nnario does not have a specific, measurable response measure. Choose Appropriate Response Measures\nI was once on a team responsible for building a simulation testbed for a military\ncombat system. The purpose of the testbed was to connect a dozen military bases\nacross the world so we could play simulated war games. To run a test, we would play\na scenario that generated fake aircraft. The hardware and software at each site would\ndetect the simulated aircraft, and the combat systems would process the sensor data\nas if it were from the real world. The simulation testbed had extremely aggressive latency requirements. If all sites did\nnot receive the same simulation data within a narrow window of time, it would seem\nas if aircraft were appearing and disappearing from the sky. Even worse, aircraft\nmight be visible only to some sites in the network. Too much latency would invalidate\nthe system tests. After crunching some numbers, we determined our testbed would need to transfer\ndata faster than the speed of light for everything to work. The performance and\navailability response measures were nowhere near reality. Once quantum entangled\nnetworks become viable, it will be interesting to revisit this problem. Get Your Hands Dirty: Refine These Notes into Quality\nAttribute Scenarios\nDuring a meeting, Project Lionheart stakeholders shared the following state-\nments. For each statement, identify the quality attribute and create a formal,\nsix-part quality attribute scenario. \u2022 There\u2019s a small number of users, but when a user submits a question or\nproblem we need to be able to respond quickly, within a business day. \u2022 Releases happen at least once a month. Ideally, we\u2019ll ship code as it is ready.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 69", "position": 69, "chunk_type": "semantic", "token_estimate": 399}
{"text": "persistence go in one group whereas features that require user interac-: tion go in another. \u2022 Look for functional requirements that seem difficult to implement. These\ncould be significant to the architecture. \u2022 Look for high-value, high-priority functional requirements. Here\u2019s an example. Recall the simple calculator example on page 10. Adding\ntwo numbers together is an important functional requirement but has little\ninfluence on the architecture, so let\u2019s spice it up a bit. Here\u2019s a new feature:\nas an Adder User I can review my addition history even if I\u2019ve lost my phone. \u201cPeople love looking at past stuff they\u2019ve done,\u201d the marketing team assures\nus. \u201cIt\u2019s going to be A-Mazing!\u201d\nHistorical information? OK, no problem. We can save the user\u2019s actions to a\nlocal database. Wait\u2026 even if they\u2019ve lost their phone?!?! Now we need a\nremote database server, which opens up a ton of new questions. What happens\nwhen the user\u2019s phone is offline? What about availability? Scalability? Hosting\ncosts? Syncing the app when the schema changes? The list goes on. Calculator\nApp\nUser s \nPhone\nWithout History\nCalculator\nApp\nUser s \nPhone\nHistory API\nMy Amazing! Calculator App\nAllocation View\nCloud \nHosting\nDatabase\nSoftware\nHardware", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 71", "position": 71, "chunk_type": "semantic", "token_estimate": 198}
{"text": "Fred Brooks in the Mythical Man Month [Bro95], describes the relationship: between team organization and architecture. \u2026organizations which design systems\u2026are constrained to produce designs which\nare copies of the communication structures of these organizations. If you have three teams, you\u2019ll end up with three components. Communication\nboundaries among people manifest as element boundaries in the architecture. Conway\u2019s Law works both ways. Communication paths designed into the archi-\ntecture will also influence how you organize your teams. If you want to design\nthe best software possible, then you must be prepared to reorganize your team. Other influencers are usually only recorded as part of the rationale for design\ndecisions. So many things can influence the architecture that it is practically\nimpossible to document all the potential influencers prior to making design\ndecisions. Dig for the Information You Need\nArchitecturally significant requirements are hidden all around us. You\u2019ll find\nASRs in user stories, implied by a manager\u2019s request, and hinted by stake-\nholders who know what they want but don\u2019t quite know how to explain it. The product backlog contains a treasure trove of ASRs. Quality attributes are\nimplied or assumed in nearly every functional requirement. Sometimes a user\nstory will plainly describe response times, scalability needs, or how to handle\nfailures. Highlight these details as quality attribute scenarios lest they get\nlost in the feature backlog. Talk to stakeholders. Find out what worries them. Ask stakeholders what\nexcites them. Share the risks and open questions you see. Here are some\nadditional methods you can use to dig out interesting ASRs:\n\u2022 Use Activity 3, Goal-Question-Metric (GQM) Workshop, on page 199 to con-\nnect business goals and quality attribute response measures with concrete\ndata requirements. \u2022 Use Activity 4, Interview Stakeholders, on page 202 to uncover quality\nattribute scenarios and constraints. Interviews work especially well with\ntechnical stakeholders. \u2022 Use Activity 5, List Assumptions, on page 205 to flush hidden requirements\ninto the open. \u2022 Use Activity 7, Mini-Quality Attribute Workshop, on page 210 to quickly and\neffectively define high-priority quality attribute scenarios. This workshop\nreport erratum  \u2022  discuss\nDig for the Information You Need \u2022 59", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 73", "position": 73, "chunk_type": "semantic", "token_estimate": 355}
{"text": "Thijmen says:: Communication skills are hard to learn from books, yet I recommend two to assist\nyou on your way to becoming an amazing software architect. How to Win Friends and\nInfluence People [Car09] by Dale Carnegie is a classic book that gives actionable\nguidance on how to build better relationships with people. In Culture Clash 2:\nManaging the Global High Performance Team [Zwe13] Thomas D. Zweifel provides an\neasy-to-understand framework for identifying and overcoming cultural differences. report erratum  \u2022  discuss\nBuild an ASR Workbook \u2022 61", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 75", "position": 75, "chunk_type": "semantic", "token_estimate": 87}
{"text": "table, we\u2019ll converge our thinking by building consensus and eliminating: options that are a poor fit for the current problem. Diverge\nConverge\nDiscover \nOptions\nMake \nChoices\nExplore\nHuman brains crave options. Our confidence in a decision increases after\nseeing multiple alternatives. Unfortunately, there isn\u2019t time to explore every\npossible option and all aspects of a software system\u2019s design. Architects need\nto focus on and champion quality attributes, structural organization, and\ndesign decisions that will influence these things. Explore the Architecturally Significant Things\nGrady Booch has said, \u201cAll architecture is design, but not all design is\narchitecture.\u201d\n1 As you learned in What Is Software Architecture?, on page 7,\na system\u2019s software architecture is the set of significant design decisions\nabout how the software is organized to promote desired quality attributes and\nother properties. Architects must explore these significant design decisions\nand actively choose how to organize the software to achieve desired quality\nattributes. Here are areas of a software system\u2019s design architects will typically explore:\nExplore elements and their responsibilities to determine the general compo-\nsition of structures in the architecture. Recall from Define the Essential\nStructures, on page 7 that structures in the architecture are made up of\nelements. In a well-designed architecture, every element has clear responsi-\nbilities. Any element without a well-defined responsibility should be elimi-\nnated. Exploring design options requires that we explore combinations of\nelements with varying responsibilities. Explore relations and their interfaces to determine how elements interact\nwith one another. Relations describe how two elements in the architec-\nture work together to accomplish a task. A component\u2019s interface is one\nexample of a relation. Both the communication mechanism (for example,\nHTTP, TCP, or shared memory) and the rules for communication (such\nas APIs, response objects, or required data) define the interface. The rules\n1. Grady Booch. Abstracting the Unknown. SATURN 2016. http://resources.sei.cmu.edu/library/\nasset-view.cfm?assetID=454315\nChapter 6. Choose an Architecture (Before It Chooses You) \u2022 64\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 78", "position": 78, "chunk_type": "semantic", "token_estimate": 324}
{"text": "Len says:: Don\u2019t Forget Deployment\nBy Len Bass, independent consultant and co-author of Software Architecture in Practice\n[BCK12], Documenting Software Architectures: Views and Beyond [BBCG10], and\nDevOps: A Software Architect\u2019s Perspective [BWZ15]\nOne of the most easily overlooked items when designing a system or service with multiple\ninstances during execution is deployment. There are two basic methods for deploying a\nnew version of a service with multiple instances: red/black or rolling upgrade. A red/black deployment (some names use different colors like blue/green) allocates\nsufficient virtual machines for all instances of the new version, deploys the new version\ninto those instances, and then switches to use the new instances. A rolling upgrade\nwill upgrade one instance at a time. In either case, there are possibilities of inconsistencies. For example, suppose you\nhave a chain of services\u2014Service A depends on Service B, which in turn depends on\nService C. Now one of your developers deploys a new version of Service B. This new\nversion may change the syntax or semantics of the interface. What happens when\nService A invokes Service B and gets an incorrect error because the semantics of an\ninterface has changed? What happens when the new version of Service B assumes a\nnew version of Service C, and the new version of Service C has yet to be deployed? If you are deploying new versions using a rolling upgrade strategy, then it is possible\nthat two different versions of Service B with different interfaces will simultaneously\nbe executing. There are a collection of techniques used to overcome these inconsistencies\u2014enforcing\nbackward compatibility, using feature toggles, gracefully handling unknown responses\nfrom a dependent service\u2014but the first step is recognizing that deployment and\ndeployment strategies can cause inconsistencies when multiple instances of a service\nare being run. Accept Constraints\nIn Limit Design Options with Constraints, on page 49 you learned that con-\nstraints are predetermined design decisions that cannot be changed. Recall\nthere are two types of constraints: technical and business. Technical con-\nstraints limit your technical options whereas business constraints focus on\npeople, process, cost, and schedule. We have no choice but to embrace technical constraints and incorporate them\ninto the architecture. If we agree that the system must be written in .NET,\nthen there is no point lamenting over the loss of your favorite Java framework. Chapter 6. Choose an Architecture (Before It Chooses You) \u2022 66\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 80", "position": 80, "chunk_type": "semantic", "token_estimate": 401}
{"text": "Promote Desired Quality Attributes: Selecting structures for the architecture is like making a smoothie. Smoothies\n(like software) are tasty but difficult to make well. While many things must\ngo right to create great software, there is only one thing you need to get right\nfor a great smoothie: use the proper blender. OK, there are lots of things that\ncan wrong with smoothie making too (berry seeds, ugh! ), but the blender is\na crucial smoothie-making tool. You\u2019d think picking a blender would be easy. It\u2019s not. Do you want one that\u2019s\neasy to clean? Something that stores easily and fits on your countertop? Something quiet? Or powerful? Or portable so you can blend on the beach? We can express these needs as blender quality attributes. Here are three types of blenders capable of making smoothies. Each blender\nis designed to promote different quality attributes and, as you can see, no\ntwo blenders are the same. Hand \nBlender\nStandard \nBlender\nChainsaw \nBlender\nChainsaw Blender photo credit: Mike Warren\nThe standard blender is dishwasher safe and has a sturdy base for sitting on\na kitchen counter top. But it requires electricity, so you\u2019re limited to the\nkitchen. The battery-powered hand blender is small, portable, and easy to\nclean, but trades power for portability. Finally, the gas-powered chainsaw\nblender has the best power and portability. 2 Too bad the 37cc two-stroke,\nmotorcycle-throttle-controlled chainsaw engine is a tad loud and emits an\nexhaust unsafe for indoor use. 2. Yes, this is a real, working blender. Instructions for making your own can be found at\nhttp://www.instructables.com/id/Chainsaw-Blender/. Chapter 6. Choose an Architecture (Before It Chooses You) \u2022 68\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 82", "position": 82, "chunk_type": "semantic", "token_estimate": 277}
{"text": "Here is a summary of how well our top-quality attributes are promoted by: each blender:\nChainsaw Blender\nHand Blender\nStandard Blender\nNeutral\nPositive\nNeutral\nCleanability\nStrongly Negative\nNegative\nPositive\nCounter top-ability\nStrongly Negative\nPositive\nNeutral\nQuietness\nStrongly Positive\nNegative\nNeutral\nPower\nStrongly Positive\nPositive\nStrongly Negative\nPortability\nNegative\nNeutral\nNeutral\nSafety\nEach blender performs the same basic function (blending). They have inter-\nchangeable parts. For example, the same glass pitcher works with the standard\nand gas-powered chainsaw blenders. In addition to the blender quality\nattributes, the designers considered costs, manufacturing techniques, inter-\nfaces with external systems (human and machine), and other properties. The\nstructures we see in the final designs were chosen to promote properties the\ndesigners highly valued. Just like the blenders, architects choose structures to promote quality\nattributes in the software system. The most common way to select structures\nis by exploring patterns. Remember, all design is redesign! Find patterns that\npromote desired quality attributes and use those patterns as a starting point\nfor the architecture. Explore Patterns with Quality Attributes in Mind\nWe\u2019ll explore architecture patterns in greater detail in Chapter 7, Create a\nFoundation with Patterns, on page 79. For now, let\u2019s see a simple example of\nhow we can use quality attributes to choose an appropriate pattern. Say we want to build a web-based, data-driven application. What patterns\nwould you choose for this application? There are three decent options: 3-tier,\npublish-subscribe, and service-oriented as shown in the figure on page 70. Option A: 3-Tier Pattern. Introduced on page 92, each tier is responsible for\ndifferent application concerns. For a web application, the display tier\nrenders the UI, the business tier operates server side to verify business\nrules, and the database stores data. Option B: Publish-Subscribe Pattern. Introduced on page 88, each element\npublishes messages to an event bus. Interested components may subscribe\nreport erratum  \u2022  discuss\nPromote Desired Quality Attributes \u2022 69", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 83", "position": 83, "chunk_type": "semantic", "token_estimate": 317}
{"text": "Option A:: 3-Tier\nWhich architecture pattern would you choose for a\ndata-driven web application? Option B:\nPublish-Subscribe\nOption C:\nService Oriented\nDisplay \nService\nRules \nService\nData \nService\nDatabase\nDisplay\nRules \nChecker\nData \nAccessor\nEvent Bus\nDatabase\nDisplay\nTier\nBusiness \nTier\nDatabase\nService \nRegistry\nto message types. Depending on the rules of the message system, events\nmight not be delivered in order and delivery might not be guaranteed. Option C: Service-Oriented Architecture Pattern. Introduced on page 86, ser-\nvices register with a central registry so that callers can find them. Compo-\nnents look up and call those services directly and the service responds with\nthe requested information\u2014or doesn\u2019t if something goes wrong. Each of these patterns promotes and inhibits different quality attributes. Which one would you choose? The 3-tier pattern is ideal in many situations. It\u2019s easy to test, easy to deploy,\nand easy to describe. This simplicity comes at a cost. The multi-tier pattern\ndoes not promote quality attributes such as scalability and availability. Depending on other quality attribute scenarios, this pattern may not address\nall our needs without augmenting the architecture with other patterns. The publish-subscribe pattern is highly modifiable and extremely flexible. This flexibility makes it easy to build loosely coupled systems. While this\nflexibility and modifiability are attractive, there is a downside. Message order\nmatters to the events in our data-driven application, but the publish-subscribe\npattern alone can\u2019t guarantee message order. With the right message bus\ntechnology, we might make this pattern work, but it feels awkward. Like the other patterns, service-oriented architecture is modifiable, flexible, and\ntestable. Service-oriented systems are also scalable and promote availability\neasier than our other options. It\u2019s also the most complex of the three patterns\nunder discussion and has the steepest infrastructure curve. Depending on our\nspecific quality attribute scenarios, this pattern could be overkill. Chapter 6. Choose an Architecture (Before It Chooses You) \u2022 70\nreport erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 84", "position": 84, "chunk_type": "semantic", "token_estimate": 318}
{"text": "The best decision is often obvious once it\u2019s in the matrix. Use a scale like the: following to summarize the analysis of each architecture design option. Immediately eliminate any design option that prevents you from achieving a\nrequired system property. We already saw a decision matrix for smoothie blenders on page 69. Let\u2019s\ncreate another decision matrix, this time for the Project Lionheart patterns\ndiscussed on page 69. Here is a decision matrix, which shows some of the\nanalysis for the quality attribute scenarios we defined in Capture Quality\nAttributes as Scenarios, on page 52:\nProject Lionheart Decision Matrix\nAvailability \n(Database unavailable)\nAvailability\n(Uptime requirements)\nPerformance\n(5-second response time)\nSecurity\nScalability\n(5% annual growth)\n3-Tier\nPublish - \nSubscribe\nService \nOriented\n+\n+\nMaintainability\n(Team knowledge)\nBuildability\n(Implementation risks)\n++\n+\n+\n+\n+\n++\nPromotes\nStrongly Promotes\nStrongly Inhibits\nInhibits\nNeutral\nLegend\nLooking at the decision matrix, which pattern would you choose? Are there\nother factors not captured in the matrix that might influence your final decision? The work that goes into creating the matrix is more important than the matrix\nitself. The decision matrix is a convenient way to summarize findings and\nfacilitate discussions with stakeholders. We want stakeholders to have a\nrobust discussion about trade-offs among design decisions. Be prepared to\nexplain the scores in the matrix. Chapter 6. Choose an Architecture (Before It Chooses You) \u2022 72\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 86", "position": 86, "chunk_type": "semantic", "token_estimate": 234}
{"text": "Using numbers in the matrix is tempting. Don\u2019t. Numbers give a false sense: of confidence and precision in the analysis. Eventually, someone will try to\nadjust scores with weighted stakeholder preferences, sum the columns, con-\nsider aggregate averages, or some other dreadful idea. It\u2019s just bad news. See Activity 32, Decision Matrix, on page 292 for further details on this method. An alternative method for helping discuss trade-off priorities is the trade-off\nsliders activity described on page 192. Assign Functional Responsibilities to Elements\nEvery element in the architecture has a job to do. As we choose structures,\nwe\u2019ll assign specific functional responsibilities to each element so we can\nachieve all the essential functional requirements. Let\u2019s look at an example from our case study system, Project Lionheart. Here\nare some functional requirements gleaned from interviews with people from\nthe Office of Management and Budget. An Office of Management and Budget user can:\n\u2022 Search existing and past city contracts\n\u2022 Paginate through all results\n\u2022 View basic information about a company including the name, phone\nnumber, address, and list of past and active contracts\n\u2022 View basic information about a contract including the type, status, expi-\nration date, PID, bidding companies, and who won the contract\n\u2022 Subscribe to receive alerts about contract updates\nSeveral responsibilities are implied by these functional requirements, in\naddition to the things directly mentioned:\n\u2022 Since users can search, this suggests it must be indexed. \u2022 To show contract and company information it must be stored. \u2022 Subscriptions require that the system stores email addresses. \u2022 To alert users about changes implies something can recognize when a\nchange has happened. Here is one view of a set of elements that will allow us to achieve these func-\ntional requirements shown in the figure on page 74.\nreport erratum  \u2022  discuss\nAssign Functional Responsibilities to Elements \u2022 73", "domains": ["Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 87", "position": 87, "chunk_type": "semantic", "token_estimate": 311}
{"text": "Legend: Project Lionheart\nComponent Overview\n(Dynamic Structures)\nRead\nRead/Write\nRead\nRead\nDB Driver", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 88", "position": 88, "chunk_type": "semantic", "token_estimate": 13}
{"text": "System Process: Search \nIndex\nHere is an element responsibility catalog for this diagram:\nResponsibility\nElement\nRenders a user interface for the user in their web\nbrowser, handles user interactions. Web UI\nAuthentication and authorization, proxy for other backing\nservices, verifies business logic for application use. Display Business\nCore processing for query parsing, search, pagination,\nfiltering. Search Service\nNormalizes tags, writes favorites to persistent storage. Favorites Service\nScheduled to look for recent changes, sends email\nbased on subscriptions stored in user metadata\ndatabase. Alerting Service\nReads data from the Contracts DB, transforms it for\nsearch, uploads to index. Crawler\nPersistent storage for user subscriptions and other\nuser-added content. User Metadata DB\nOptimized representation of contract data designed\nfor search. All contract data to be displayed in the UI\nis searchable, sortable, and stored. Search Index\nPersistent storage. System of record for city RFP data. Contracts DB\nCommunication among services over standard HTTP\nprotocols. APIs are assumed to be RESTful. HTTP Relation\nNative driver/client for the to-be-selected database. DB Driver Relation\nChapter 6. Choose an Architecture (Before It Chooses You) \u2022 74\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 88", "position": 88, "chunk_type": "semantic", "token_estimate": 184}
{"text": "The element responsibility catalog describes the essential duties each element: in the architecture has the authority to perform. We created this element\nresponsibility catalog by running down the list of the known influential\nfunctional requirements and ensuring each function was owned by one and\nonly one element. Also, each element in the architecture should have at least\none function for which it is responsible; otherwise, that element is without\npurpose. Influential functional requirements make for a great checklist when assigning\nresponsibilities to elements. One approach for identifying responsibilities is\nto model the system with component responsibility collaborator cards as\ndescribed on page 232. Design for Change\nSo far in this chapter, you\u2019ve learned how to explore options and make deci-\nsions using your understanding of the ASRs. Making significant design deci-\nsions is supremely important for having a robust architecture, but if there is\none constant in software, it\u2019s change. All great architectures account for the inevitability of change. We design for\nchange by choosing when to make a decision and by moving design decisions\nout of the architecture. Defer Binding Decisions until the Most Responsible Moment\nMaking a decision that cannot be easily reversed\u2014an architectural decision\u2014is\na big deal. One strategy for avoiding dead ends and wrong turns is to defer\nmaking binding decisions for as long as responsible. Delaying design decisions\nuntil they must be decided creates time for research and exploration. In Lean Software Development: An Agile Toolkit for Software Development\nManagers [PP03], Mary and Tom Poppendieck introduced the idea of the last\nresponsible moment, the time when a decision must be made to avoid losing\nimportant design alternatives. Instead of thinking about the last responsible\nmoment, we want to try to make design decisions at the most responsible\nmoment, the time at which a design decision has the greatest positive impact\non the software system. 3\n3.\nhttp://wirfs-brock.com/blog/2011/01/18/agile-architecture-myths-2-architecture-decisions-should-be-made-at-\nthe-last-responsible-moment/\nreport erratum  \u2022  discuss\nDesign for Change \u2022 75", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 89", "position": 89, "chunk_type": "semantic", "token_estimate": 322}
{"text": "Ideally, the last responsible moment is also the most responsible moment to: decide. In practice, the most responsible moment to make a decision leaves\nextra time for external dependencies beyond our control, consensus building,\neducation, and design validation. The most responsible moment is often ear-\nlier than we think it is. Here are some questions I use to help me decide whether now is the right\ntime to make a design decision:\n\u2022 Does a lack of a decision prevent forward progress? \u2022 Does the decision resolve a problem that cannot wait? \u2022 Does the decision create more options or new opportunities? \u2022 Does delaying the decision introduce significantly more risk? \u2022 Do I understand and accept the implications of the decision? \u2022 Do I have a clear rationale for why I am making this decision now? \u2022 Do I have the time to undo this decision if it is wrong? Can I afford to\nmake a mistake? Even if we can identify the most responsible moment to decide, that doesn\u2019t\nmean we\u2019ll always have enough information to make a good decision. Luckily\nwe have a cheat to help us avoid catastrophes when this situation arises. We\ncan move things likely to change out of the architecture. Move Design Decisions out of the Architecture\nIf a design decision is easy to change later, then it is no longer an architectural\nconcern. When possible, design the architecture so that decisions likely to\nchange are left open for downstream designers to decide. Many of the design principles we know from programming are just plain good\ndesign principles. For example, applying SOLID principles to architecture\nyields many of the same benefits to architecture as they do to object-oriented\ndesign. SOLID is a mnemonic to help remember the single responsibility,\nopen/closed, Liskov substitution, interface segregation, and dependency\ninversion design principles. When elements in the architecture have a single\nresponsibility it\u2019s easier to isolate changes. Depending on abstractions and\ncreating elements with clean interfaces creates flexibility. There are many ways to move design decisions out of the architecture,\nincluding pluggable architectures, external configuration, self-describing data,\nand dynamic discovery. In each of these examples, we chose to alter the sys-\ntem\u2019s behavior at design time or runtime without modifying the architecture\nand, ideally, without adversely affecting essential quality attributes. Chapter 6. Choose an Architecture (Before It Chooses You) \u2022 76\nreport erratum  \u2022  discuss", "domains": ["Design Principles", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 90", "position": 90, "chunk_type": "semantic", "token_estimate": 398}
{"text": "a specific combination of structures. Choose the right patterns for our problem,: and we can avoid nasty traps that may otherwise cause trouble had we\nattempted to design the architecture from scratch. Patterns have many other benefits. Since many patterns are widely known,\nwe get communication bonuses by using them. If a picture is worth a thousand\nwords, a pattern is worth a thousand pictures. Popular patterns are baked\ninto frameworks and platforms, making it easier to adopt them. Let\u2019s explore some of the more common architecture patterns in use today. The\nmini-catalog \nhere \nis \nfar \nfrom \na \ncomplete \nlist. More \ninformation \nabout \neach \npattern\ncan be found easily on the web and in existing architecture literature. Joe asks:\nWhat Is the Difference between a Design Pattern\nand an Architecture Pattern? Design patterns are an essential design tool for all designers regardless of design\ndiscipline or granularity of abstraction. You\u2019ll find design patterns for user experience,\ntesting, database design, and even engineering processes, in addition to programming,\nsoftware architecture, and enterprise architecture. All design patterns have a place\nin modern software development. Architecture patterns differ from programming design patterns, such as those cata-\nloged by the Gang of Four in Design Patterns: Elements of Reusable Object-Oriented\nSoftware [GHJV95], by the types of problems they aim to solve. The Gang of Four\u2019s\ndesign patterns shows how to organize object-oriented programs to promote\nreusability and maintainability. Architecture patterns define solutions for a variety\nof quality attributes scenarios\u2014design time, runtime, and conceptual\u2014and often\ndeal with multiple components of a software system. The scope is broader in an\narchitecture pattern regarding both the quality attributes and the granularity of\nabstractions in play. In practice, distinguishing programming design patterns from architecture design\npatterns isn\u2019t so important. After all, one person\u2019s architecture might be another\nperson\u2019s detailed design. Layers Pattern\nThe layers pattern is one of the most used (and abused) architecture patterns. Most software systems have multiple contributors. Partitioning code into\ndistinct and independent layers organized around a specific set of related\nconcerns enables developers to work together better. Layers promote decreased\ncoupling between the layers and higher cohesion within, which promotes\nChapter 7. Create a Foundation with Patterns \u2022 80\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 93", "position": 93, "chunk_type": "semantic", "token_estimate": 370}
{"text": "maintainability. Use layers any time you need to change code modules inde-: pendently of one another. Module\nCategory\nLayer\u2014group of functionally cohesive modules. Elements\nAllowed to use\u2014indicates which layers may use modules\nwithin another layer. Relations\nEvery module must be allocated to one and only one layer. Rules for Use\nLayers above are allowed to use layers below, but this rela-\ntion only goes one way. The allowed to use relation can be\nlimited so the current layer may only use the layer immedi-\nately below it. Cyclical dependencies are not permitted. Promotes maintainability, portability, reusability, testability,\ndesign time modifiability. Conceptually simple to implement. Layers can be made visible in the code. Strengths\nEach layer introduces additional abstractions between the\nhighest layers and the lowest. These additional abstractions\nWeaknesses\nincrease complexity and may harm performance. Too many\nlayers or leaky abstractions can make development painful\nfor programmers. Here are examples of layered diagrams. The diagram on the left explicitly\nshows the allowed to use relation, whereas the diagram on the right implies\nrelations among elements.", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 94", "position": 94, "chunk_type": "semantic", "token_estimate": 175}
{"text": "Business Logic: Data Access\nCommon\nLayers Pattern Examples\nLayer\nA             B A is allowed to use B\nLegend\nThere many variants of the layered pattern. No matter how it\u2019s drawn or how\nmany layers are involved, the elements, relations, and rules for their use are\nthe same. report erratum  \u2022  discuss\nLayers Pattern \u2022 81", "domains": ["Architectural Patterns and Styles"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 94", "position": 94, "chunk_type": "semantic", "token_estimate": 55}
{"text": "Ports and Adapters Pattern: The ports and adapters pattern isolates core business logic so it can be used in\na variety of contexts and tested in isolation from components that provide data\nand events. At runtime, pluggable adapters for specific input sources can be\ninjected into the core business logic to provide access to events and data. Adapters can be swapped at build-time or runtime to create different configura-\ntions of the software system. Use this pattern when the system must support\nmultiple input devices or when there is a risk that input devices could change. This pattern was initially described by Alistair Cockburn under the name\nHexagonal Architecture. 1 See the table on page 83. Here is an example of a ports-and-adapters diagram. In this example, radar\nsimulators can be swapped for adapters to real radar systems without\nchanging the core business logic. The logging and communication bus can\nalso be exchanged depending on the situation. Ports and Adapters Example\nAN/SPY-1 \nAdapter\nE-2 Hawkeye\nSimulator", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 95", "position": 95, "chunk_type": "semantic", "token_estimate": 166}
{"text": "Adapter: Core \nBusiness \nLogic\nShared \nMemory\nmySQL\nFile\nSystem\nEvent Bus\nPorts\nSensor Inputs\nEvent broadcast\nLogging\nAdapter\nUses\nLegend\nLayer\nOther available \nadapters\n1.\nhttp://alistair.cockburn.us/Hexagonal+architecture\nChapter 7. Create a Foundation with Patterns \u2022 82\nreport erratum  \u2022  discuss", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 95", "position": 95, "chunk_type": "semantic", "token_estimate": 39}
{"text": "Module or Component & Connector: Category\nLayer\u2014Contains domain or business logic that has no\nknowledge of where data or events it uses originates. Elements\nPort\u2014Describes the interface between a layer and an\nadapter. Ports allow layers to be decoupled from concrete\nadapters. Adapter\u2014Code that interacts with external data sources,\ndevices, or other components that layers can use to gain\naccess to data or events. Exposes\u2014Indicates the ports available from a specific layer. Relations\nImplements\u2014Describes the ports which constrain an\nadapter. Injects\u2014Indicates which adapters will be available to a given\nlayer. Layers usually but are not required to expose ports. Layers\nwithout ports are sometimes referred to as inner layers. Rules for Use\nAdapters may satisfy the constraints of one or more ports. An adapter may only be injected into a port when that\nadapter implements the interface required by that port. Depending on the mechanisms used to realize elements\nand relations, the pattern may refer to design-time or run-\ntime interactions. Be clear and consistent in your models\nwhether you are showing module or C&C structures. Promotes testability, maintainability, and modifiability. Different teams can work on different layers or adapters. Strengths\nMechanisms must be developed to select adapters used at\nruntime. Runtime qualities such as security and reliability\nWeaknesses\nare decided by the adapters. Third-party adapters should\nbe selected with care. report erratum  \u2022  discuss\nPorts and Adapters Pattern \u2022 83", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 96", "position": 96, "chunk_type": "semantic", "token_estimate": 231}
{"text": "Pipe-and-Filter Pattern: With the pipe-and-filter pattern, each component called a filter is responsible\nfor a single transformation or data operation. Data is streamed from one filter\nto the next as quickly as possible, and data operations occur in parallel. Loosely coupled filters can be reused and combined in different ways to create\nnew pipelines. The pipe-and-filter pattern is prevalent in data analysis and data transforma-\ntion use cases. If you\u2019ve ever piped Unix commands together in a terminal\nwindow, then you have firsthand experience with the pipe-and-filter pattern. See the table on page 85. Here is an example diagram of the pipe-and-filter pattern:\nJobs \nSource\nPipe-and-Filter Example\nFilter\nTCP Pipe\nLegend\nRemove \nBad Data\nScore\nNormalize \nScores\nCreate", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 97", "position": 97, "chunk_type": "semantic", "token_estimate": 118}
{"text": "Component & Connector: Category\nFilter\u2014A component that reads data, transforms it, then\nwrites out the transformed data. Filters may begin process-\nElements\ning data as soon as it is read. Filters must define expected\ninputs and produced outputs. Pipe\u2014A connector, which transports data from one filter to\nthe next, preserving data order. Pipes have a single input\nand output, and do not alter the data in transit. Some variants of this pattern also include source and sink\nelements. The former only produces data whereas the latter\nonly receives it. Attachment\u2014Connects the output of one filter with the input\nof another by way of a pipe. Relations\nPipes can only connect filters with compatible inputs and\noutputs. Filters should be completely independent of one\nRules for Use\nanother and have no knowledge of upstream or downstream\nfilters. Promotes performance, reusability, and modifiability. Strengths\nPipe-and-filter systems are not interactive and cannot\ninclude a user interface without modifying the pattern. Weaknesses\nReliability is not specifically promoted by the pattern but\ncan be designed in by introducing filters to handle error\ncases. A naive implementation can harm performance\nbecause having many filters running in parallel can be\ncomputationally expensive. report erratum  \u2022  discuss\nPipe-and-Filter Pattern \u2022 85", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 98", "position": 98, "chunk_type": "semantic", "token_estimate": 203}
{"text": "Service-Oriented Architecture Pattern: In a service-oriented architecture, independent components are implemented\nas services, which provide specific functionality. Services are combined at\nruntime to define the software system\u2019s behavior. For this to work, service\nconsumers must be able to locate and use services without knowing about\nimplementation details behind the services they use. Service-oriented architectures (SOA) can be implemented in many ways. Tra-\nditional SOA relies heavily on message buses and communication via SOAP. Modern SOA encourages the use of fine-grained microservices connected by\nlightweight message protocols such as HTTP. Complex organizations will often turn to SOA to design large software systems\nin which different departments own different pieces of the system. SOA allows\neach department to work independently within their area of expertise and\nhide information systems but also provides broad access to those subsystems\nwithout compromising design integrity. See the table on page 87. Here is an oversimplified example diagram showing a single view of a service-\noriented system. Service-oriented architectures are complicated and involve\nmany architectural components. This diagram shows two services attached\nto the service registry. Services must check the registry to look up connection\ninformation for other services they want to call. Microservice\nLegend\nHTTP/REST\nService-Oriented \nArchitecture Example\nWeb UI\nRead/Write\nRatings\nEureka\nArchaius\nService \nDiscovery\nDatabase\nConfiguration Store\nChapter 7. Create a Foundation with Patterns \u2022 86\nreport erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 99", "position": 99, "chunk_type": "semantic", "token_estimate": 226}
{"text": "Component & Connector: Category\nService\u2014An independently deployable unit, which provides\nfunctionality behind a well-defined interface. Elements\nService registry\u2014List of all available services, used by a\nservice to discover other services to use. Message system\u2014The specific element type depends on the\nflavor of SOA and other design decisions around service\ncommunication. Some examples include SOAP, REST (rep-\nresentational state transfer, usually over HTTP), gRPC,\n2 and\nasynchronous messaging. Varies depending on the constraints in the SOA system. With the smart endpoints, dumb pipes approach popularized\nRelations\nby Netflix, calls might be the only relation. If your SOA\nsystem uses asynchronous messaging, publish and sub-\nscribe might be the relations in play. Services have no knowledge about the implementation\ndetails of the services they use. Services must discover\nRules for Use\nother services via an external component, either a service\nregistry or message bus in the case of asynchronous mes-\nsage passing. Promotes interoperability, reusability, and scalability. This\nis a well-studied pattern with many, many subpatterns\ndefined. Strengths\nSOA systems are distributed systems and include all the\ncomplexity that comes with distributed computation. SOA\nWeaknesses\nsystems have many parts and can be complicated to\nassemble. Properties that can be handled easily at design\ntime in other patterns are a runtime concern with SOA. For\nexample, it\u2019s impossible to know the version of an SOA\nsystem without knowing what services were running at a\nsnapshot in time. Availability, reliability, and performance\nare inhibited by this pattern. 2.\nhttp://www.grpc.io/\nreport erratum  \u2022  discuss\nService-Oriented Architecture Pattern \u2022 87", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 100", "position": 100, "chunk_type": "semantic", "token_estimate": 254}
{"text": "Avoid Architectural Mismatch: Architectural mismatch, described in Architectural Mismatch: Why Reuse Is So Hard\n[GAO95], is a phenomenon that occurs when the assumptions made about how a\ncomponent will be used conflicts with that component\u2019s current use. In the best case,\na system experiencing architectural mismatch will be difficult to develop and maintain. In the worst case, key quality attributes will be unattainable. Architectural mismatch can occur at the conceptual level when a selected pattern is\nin direct tension with high-priority quality attributes. For example, if performance is\nthe number one quality attribute, then selecting service-oriented architecture might\nbe a mismatch. Picking the wrong pattern can significantly harm the architecture\u2019s\nability to promote required properties. Architectural mismatch can also occur when the technology selected to implement\nthe system does not align with assumptions laid out in the architecture. For example,\nif the architecture describes a publish-subscribe pattern, using a relational database\nas the primary mechanism for message passing would undermine the properties\npromoted by the publish-subscribe pattern. When a mismatch occurs on my team,\nwe will talk about how we are fighting the framework. To avoid creating a mismatch,\nchoose technologies that match the assumptions made in the architecture. Publish-Subscribe Pattern\nIn the publish-subscribe pattern, producers and consumers exist independently\nand unaware of one another. Numerous consumers subscribe to events\npublished by various producers. Producers and consumers communicate\nindirectly via an event bus, which is responsible for connecting published\nevents with interested subscribers. The choice of event bus technology\ngreatly influences the systems properties. Choose the publish-subscribe\npattern when multiple, independent components need access to the same\ninformation. See the table on page 89. Here is an example diagram of a publish-subscribe system:\nAlarm\nEvent Bus\nSubscribes\nLegend\nPublish-Subscribe Example\nSmoke \nSensor\nTemperature\nSensor\nHumidity\nSensor\nThermostat\nFurnace\nHistory\nDatabase\nService\nPublishes\nRead/Write\nChapter 7. Create a Foundation with Patterns \u2022 88\nreport erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 101", "position": 101, "chunk_type": "semantic", "token_estimate": 316}
{"text": "Component & Connector: Category\nPublisher\u2014any component that publishes an event. Specific\nevents published should be described in design\ndocumentation. Elements\nSubscriber\u2014any component that subscribes to an event. Event Bus\u2014responsible for registering component subscrip-\ntions and delivering published events. The properties pro-\nmoted by the event bus vary on the specific technology and\nits configuration. Publish\u2014Indicates that a component publishes events to\nthe event bus. Relations\nSubscribe\u2014Indicates that a component registers an event\nsubscription. All communications in this pattern take place via the event\nbus. As such all components, must be connected to the\nbus. Components may be both a publisher and subscriber. Rules for Use\nPromotes extensibility, reusability, and testability. Depending on the selection of event bus and how it is con-\nStrengths\nfigured, availability, reliability, and scalability might also\nbe promoted. It is difficult to reason about performance in publish-sub-\nscribe systems given the independent, asynchronous nature\nWeaknesses\nof component communication. The choice of event bus is\nultimately responsible for making or breaking a publish-\nsubscribe system. Choose your event bus with care and\nlearn everything you can about how to use it. Most publish-subscribe systems define an event specification, which describes\nevents to which components may subscribe. This document also describes\nevent formats as well as the components responsible for publishing events. report erratum  \u2022  discuss\nPublish-Subscribe Pattern \u2022 89", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 102", "position": 102, "chunk_type": "semantic", "token_estimate": 222}
{"text": "Shared-Data Pattern: In the shared-data pattern, multiple components access data through a common\ndata store. No single component is entirely responsible for the data or data store. This pattern is particularly useful when multiple components require a large\namount of data. With shared-data systems, data and the data source is the\nprimary medium of interaction. Compare this to event-based systems in which\ncomponents communicate via procedure calls or message passing. See the table\non page 91. The following diagram shows an example of a shared-data pattern. Provisioning\nUser Search\nView Profile\nAccess \nRequest\nRegistration\nComponent\nReads\nLegend\nUsers\nWrites\nData store\nPermissions\nChange \nPassword\nShared-Data Pattern Example\nThe shared-data pattern blends well with other patterns. Many large informa-\ntion systems will use this pattern somewhere within the architecture. Chapter 7. Create a Foundation with Patterns \u2022 90\nreport erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 103", "position": 103, "chunk_type": "semantic", "token_estimate": 141}
{"text": "Component & Connector: Category\nData store\u2014holds the data shared among accessors. Choice\nof the data store and the constraints placed on it determine\nthe quality attributes achieved with the pattern. Elements\nData accessor component\u2014components that use the data\nin some way. Reads\u2014indicates that a data accessor component may read\ndata from the shared-data store. Some read relations might\nRelations\nrequire specific protocols or place limits on the amount or\ntypes of data that can be read. Writes\u2014indicates that a data accessor component writes\ndata to the shared-data store. Write relations can be\ntransactional, throttled, protected, or otherwise constrained\nin a variety of ways. Only data accessors may interact with the shared-data\nstore. Rules for Use\nPromotes reliability via data consistency, security, and pri-\nvacy. Scalability and availability are also promoted when\nStrengths\nthe data store is tuned well and data accessors are\nthoughtfully partitioned. The shared-data store creates a single point of failure, which\ncan harm availability and performance. Maintainability can\nWeaknesses\nbe harmed if the data store changes, since all data accessors\nmay be required to change as well. This pattern is simple\nto implement and prone to abuse. Sharing data can solve\nmany problems, but depending on the context other archi-\ntecture patterns could be a better fit. report erratum  \u2022  discuss\nShared-Data Pattern \u2022 91", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 104", "position": 104, "chunk_type": "semantic", "token_estimate": 218}
{"text": "Multi-Tier Pattern: In the multi-tier pattern, runtime structures are organized into logical groups. These logical groups may be allocated to specific physical components, such\nas a server or cloud platform. The multi-tier pattern is conceptually similar\nto the layers pattern. Layers are a module structure and deal with design-\ntime elements, whereas tiers are either a component and connector or alloca-\ntion structure and deal with runtime elements. Any system in which components will live on different platforms or hardware\nwill benefit by thinking about the tiers at play and which components reside\non different tiers. See the table on page 93. Here is a diagram depicting the multi-tier pattern. In this example, components\nin the application tier are allocated to the customer\u2019s servers. Components\nin the middle tiers are allocated to a common platform but have different\nfunctional responsibilities. Components in the data tier are hosted on a dif-\nferent cloud platform and may only include databases. Tier\nLegend\nHTTP/REST\nMulti-Tier Example\nData Tier\nCommon Services Tier\nProduct Services Tier\nAPI Tier\nApplication Tier\nRuns on customer \nservers\nDatabases hosted \non AWS\nServices allocated \nto shared compute \nplatform. Services in \nthe API tier act as a \nthin pass-through to \nservices in the \nproduct tier. Common services \nmay be used across \ndifferent products. gRPC\nDatabase \nDrivers\nChapter 7. Create a Foundation with Patterns \u2022 92\nreport erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 105", "position": 105, "chunk_type": "semantic", "token_estimate": 229}
{"text": "Component & Connector or Allocation: Category\nTier\u2014a logical grouping of runtime components. There are\nmany ways to partition tiers. Some examples include func-\nElements\ntional responsibilities, compute platforms, team responsi-\nbilities, communication mechanisms, security requirements,\nand data access. Belongs to\u2014used to group components into a tier. Relations\nCommunicates with\u2014shows how tiers or the components\nwithin interact with one another. This relation may be spe-\ncialized to include information about protocols and commu-\nnication constraints. Allowed to communicate with\u2014indicates which tiers may\ncommunicate with components in other tiers. Allocated to\u2014maps tiers to physical compute platforms. A component may belong to only one tier. Components\nwithin a tier are only allowed to communicate with other\nRules for Use\ncomponents within the same. Additional constraints\ndescribing tier communication can enhance reasoning and\nimprove maintainability. A common approach is to allow\ncommunication only among adjacent tiers. Promotes security, performance, availability, maintainabil-\nity, modifiability. Can be used to reason about costs and\ndeployment. Strengths\nAs a runtime construct, tiers can be difficult to enforce in\nlarge systems. Systems with many tiers can inhibit perfor-\nmance and maintainability. Weaknesses\nCenter of Competence Pattern\nIn the center of competence pattern, a team of experts is charged with defining\npatterns, establishing best practices, developing support tools, and providing\neducation for a subset of the architecture. The center of competence (CoC) is\nnot expected to build and deliver this part of the system but rather help other\nteams excel in their day-to-day development work. CoC teams can be organized\naround technologies, use cases, patterns, and high-risk areas. report erratum  \u2022  discuss\nCenter of Competence Pattern \u2022 93", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 106", "position": 106, "chunk_type": "semantic", "token_estimate": 268}
{"text": "Creating a CoC will make it easier for development teams to implement pat-: terns and technologies we want in the architecture. Since the CoC is a support\ngroup, its primary goal is to increase development speed and improve the\noverall quality of the software system. Allocation\nCategory\nCoC Team\u2014group of developers and architects. Elements\nResponsibility Area\u2014subset of the architecture. Can be a\npattern, technology, or use case. Responsible for\u2014connects a CoC team with their responsi-\nbility areas. Relations\nTypically a CoC is responsible for only one type of technol-\nogy or use case. Rules for Use\nPromotes reusability and scalability of experts. Greater\naccess to experts and reusable assets can positively influ-\nStrengths\nence many quality attributes, including security, scalability,\nperformance, reliability, and maintainability. Centers of competence create pockets of expert knowledge,\nwhich can be easily disrupted by turnover. Weak CoCs can\ncreate confusion and slow down development. Weaknesses\nHere is an example of how one company, consisting of a few hundred devel-\nopers, organized center of competence teams. Responsibility Area\nCoC Team\nDevelop a framework for the job scheduling use case\nand create tools so teams can instantiate the framework\non clusters themselves. Job Scheduling\nUse Case\nConsult with teams about load and performance testing,\nprovide tools for testing and data collection, collect and\norganize data sets and other testing assets. Performance\nConsult with teams to select supported database tech-\nnologies appropriate to use case, maintain tools for\nDatabase\nTechnologies\nprovisioning databases, create or distribute training\nmaterials. Maintain common container management system,\nprovide supported Docker base images, create tools for\nCore Platform\nday-to-day tasks such as log aggregation and health\nchecks. Chapter 7. Create a Foundation with Patterns \u2022 94\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 107", "position": 107, "chunk_type": "semantic", "token_estimate": 285}
{"text": "Open Source Contribution Pattern: In the open source contribution pattern, teams are given responsibility for\ndeveloping specific architectural components but are not expected to be the\nonly contributing developers. When this pattern works well, a team will act\nas a benevolent dictator over their components, reviewing submitted changes\nto a component for quality and conceptual integrity. This pattern allows for\nlimited centralized control across the architecture. Use this pattern when\nthere are experts available from multiple development teams or when there\nis a common dependency on specific components. For this pattern to be successful, teams must know they are responsible for\nspecific components and have a firm understanding of where their components\nfit within the larger context. Provide only the owning team with write access\nto enforce architectural responsibility for the component. All other teams\nshould have the ability to submit changes for review. Create style guides,\ndesign for testability, and impose constraints on technologies and build\nplatforms, to make it easier for developers to contribute. Allocation\nCategory\nTeam\u2014a group who may submit or review component\nchanges. Elements\nRepository\u2014version control repository containing software\ncomponents. Owns\u2014indicates a team responsible for reviewing changes\nand maintaining conceptual integrity over a repository. The\nRelations\nowner is sometimes called the repository\u2019s benevolent dicta-\ntor. May contribute to\u2014indicates a team who may submit\nchanges to a repository. Repositories typically have only one owner but this is not\na strict rule. Teams to contribute to many repositories. Rules for Use\nPromotes reusability, maintainability, and development\nspeed\nStrengths\nThis pattern is strongly tied with the component partitioning\nstrategy. In many cases the learning curve for contributions\nWeaknesses\nis so steep this pattern becomes impractical. May require\nthe owning teams to adopt other open management prac-\ntices to be successful. report erratum  \u2022  discuss\nOpen Source Contribution Pattern \u2022 95", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 108", "position": 108, "chunk_type": "semantic", "token_estimate": 301}
{"text": "The open source contribution pattern pairs well with any architecture patterns: that also promotes reusability. Giving teams the ability to contribute changes\ncan create opportunities for reuse that might not exist otherwise. Big Ball of Mud Pattern\nThe big ball of mud pattern is less a pattern you choose as it is a pattern you\nfind in the real world. The big ball of mud is described by Brian Foote and\nJoseph Yoder in Pattern Languages of Program Design 4 [FHR99]. The big ball of mud pattern has no defined elements or relations. Big balls\nof mud don\u2019t promote any qualities in particular. As you can imagine, or\nhave yourself experienced, big balls of mud inhibit maintainability and\nextensibility. Both module and module and component and connector\nstructures can be big balls of mud. Simon Brown has observed that many\nmicroservices systems can evolve into distributed big balls of mud just as\neasily as monolithic systems. 3\nSince big balls of mud are found only in the real world, not on paper, the\none positive thing we can say about them is that they promote short-term\ndevelopment speed at the cost of long-term design integrity. Big balls of\nmud often emerge due to undisciplined development practices and a general\nlack of understanding of the architectural principles at play in the software\nsystem. Some big balls of mud are created on purpose to ship value sooner such as\nwhen a team strategically decides to accept technical debt in exchange for\nfaster initial development. The dangers of this approach lay in not retiring or\npaying down the debt in a timely fashion. Discover New Patterns\nPatterns are born from experience. New patterns emerge every day. Some\npatterns might apply to a variety of systems and teams. Others might be\nhyper local, perhaps only applicable to a single organization. New patterns\nspontaneously emerge all the time, though one does not simply invent a new\narchitecture pattern. Architects discover patterns in much the same way an entomologist discovers\na new species of insect. Spend time in the field. Observe the world around\nyou. When you\u2019ve identified a possible pattern, describe it and classify it rel-\native to existing patterns. If your discovery is similar to something that exists,\n3.\nhttp://www.codingthearchitecture.com/2014/07/06/distributed_big_balls_of_mud.html\nChapter 7. Create a Foundation with Patterns \u2022 96\nreport erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 109", "position": 109, "chunk_type": "semantic", "token_estimate": 389}
{"text": "add your knowledge to our collective wisdom of the existing pattern by pub-: lishing a blog post or paper. If your discovery is new, then add it to your\nteam\u2019s pattern catalog. There are two primary approaches to discovering patterns: problem focused\nand solution focused. With the problem-focused approach, you start by\nlooking for a common problem. Once you\u2019ve seen the same problem a few\ntimes, your goal is to develop a generalized solution. Survey the existing\nsolutions. Look for similarities and differences among the current solutions. Based on your analysis, attempt to describe the solution pattern. With the solution-focused approach, you start by looking for solutions that\nare used again and again, perhaps without developers realizing it. Describe\nthe solution pattern as you\u2019ve observed it. Do some analysis to uncover the\ncommon problem being solved and attempt to define it. Once you have a pattern, send it out for feedback. Look for people who are\nfamiliar with the problem or have implemented the solution before. The final\ntest of your pattern will be in its first implementation. Use the feedback from\nyour reviewers and the early implementation attempts to improve the pattern. Project Lionheart: The Story So Far\u2026\nThe team gathered in a conference room to share findings from their recent\ndesign exploration. Choosing a search technology was easy. The group gave\na short presentation of the available technologies, shared a brief demo, and\nrecommended a technology that seemed reasonable enough. Finalizing the\nbasic patterns in the architecture, it seems, is a different matter. \u201cWhat if we go with a simple 3-tier system?\u201d Leia suggests. She steps up to\nthe whiteboard and sketches some boxes and lines. An impromptu whiteboard\njam (described on page 255) breaks out. Owen counters, \u201cI\u2019ve been reading\nabout microservices. It seems like a slick solution.\u201d Owen explains the\nmicroservices pattern to the team. Finn pipes up, \u201cMicroservices sound exciting\nbut also seem like a lot of work for a simple web application.\u201d\nThe whiteboard jam continues for several minutes as teammates propose new\npatterns and discuss the merits of each pattern in turn. \u201cLots of good discus-\nsions,\u201d you chime in, \u201cbut we\u2019re losing focus and need to make a decision. How do the proposed solutions influence our top-quality attributes?\u201d\nreport erratum  \u2022  discuss\nProject Lionheart: The Story So Far\u2026 \u2022 97", "domains": ["Architectural Patterns and Styles"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 110", "position": 110, "chunk_type": "semantic", "token_estimate": 388}
{"text": "CHAPTER 8: Explore\nUnderstand\nMake\nEvaluate\nManage Complexity\nwith Meaningful Models\nComplexity is an inevitable by-product of every successful software system. More users will push the limits of availability, scalability, and performance. New features will be bolted on and wedged in wherever they fit. As software\ngrows, the sheer size of the system can overwhelm the teams who develop it. Without constant vigilance, software systems eventually become victims of\ntheir own success. All hope is not lost. When complexity rears its ugly head, we have options for\nkeeping it in check. We can make the software smaller again by altering the\nrequirements and snipping out code. We can divide big, complex things into\nsmaller things that are easier to reason about and manage. We can also hide\ndetails and think about the software from the perspective of coarser-grained\nabstractions. In Define the Essential Structures, on page 7 you learned that architecture\nis made up of structures, which in turn are composed of elements and rela-\ntions. In this chapter you\u2019ll learn how to use these basic building blocks to\ncreate meaningful models that help us reason about our designs. Reason About the Architecture\nThere is a finite amount of information we can keep in our heads at any given\ntime. Over the years, software developers have created cheats to work around\nthe limitations in our brains. One cheat is to turn problem solving into a\nmassively parallel operation by collaborating with other humans. Another\ninvolves creating new, abstract concepts to represent chunks of knowledge. report erratum  \u2022  discuss", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 112", "position": 112, "chunk_type": "semantic", "token_estimate": 258}
{"text": "These tools\u2014collaboration and abstraction\u2014give us what we need to think: through, analyze, and understand our architectures. Abstractions help us focus on specific details at the expense of others. For\nexample, an interface of a class in object-oriented programming describes\nthe public methods but says nothing about how we should implement those\nmethods. The concrete implementation of the interface provides those details. Removing these distracting details tightens focus on what you want to think\nabout: the interface. Of course, the perfect abstraction is not useful if we can\u2019t share it. Anyone\ncan draw boxes and lines. Creating a genuinely useful model of the architec-\nture takes serious thought. A model, unlike any old sketch, is a precise and\naccurate description of some piece of the architecture that enhances commu-\nnication and can be used to reason about the system. Good architecture models have many benefits:\nModels establish the vocabulary of design. Words matter. A good element\nname will convey meaning and intent. Each model we create extends the\nsoftware system\u2019s vocabulary. We use this vocabulary in our day-to-day\ndiscussions, but it also permeates the code we write and shapes the way\nwe see the world. Models direct our attention to interesting details. In software development,\ndetails are everything. Just because all details are important it does not\nmean we want to (or have the cognitive capacity to) think about all the\ndetails at the same time. Models let us hide some details so we can focus\nonly on what is needed at this moment to answer a specific question. Models allow us to reason about quality attributes and other system prop-\nerties. Models make it easier to think about and describe how the system\nwould behave. If we build the right models of our architecture, we can\nuse them to test our designs before implementing the system too. We\u2019ll\nstill need to run experiments and build prototypes so that we can learn\nhow to create accurate models. Even then, running an experiment is sig-\nnificantly cheaper and faster than learning that the design stinks after\nwe built the whole system! Models capture the architect\u2019s intent. All developers should understand why\nwe designed the system the way we did. Great models express the intent\nbehind the structures. The more people who understand this intent, the\ngreater the chance we\u2019ll have of maintaining the system\u2019s conceptual\ndesign integrity as we evolve the system over time. Chapter 8.", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 113", "position": 113, "chunk_type": "semantic", "token_estimate": 404}
{"text": "Start the process by asking a question. This question forms the basis for a: test. Through the test, we\u2019ll either find the answer in our model or find a gap\nin our current understanding. If we find an answer, then we reinforce our\nexisting model. When we find a gap, we must figure out how to change our\nmodel to fill it. Here\u2019s an example of the curiosity cycle in action. Say stakeholders have\nprioritized availability, but we also need to keep costs down. Under these\ncircumstances, we might ask the following questions:\n\u2022 Question: Which components cost us the most if they are unavailable? \u2022 Test: I can\u2019t answer this question with our current model. I see compo-\nnents, but I can\u2019t discern their costs. \u2022 Individuate a new concept: Let\u2019s introduce cost. \u2022 Build new model: We can use color in our meta-model to represent costs. White means no loss whereas a dark red box means we\u2019re losing a lot of\nmoney. The darker the color, the greater the loss. \u2022 Test: Ah-ha! Now I can see that component Foo is going to cause the most\nif it is unavailable. After updating the meta-model to include the concept of cost, we can now\ncreate a new model that lets us reason about the relationship between costs\nand other quality attributes. Original Model\nRevised Model\nComponent\nDependency\nLegend\n(Revised meta-model)\n$$$$\n$\nCost\nComponent\nDependency\nLegend\n(Original meta-model)\nWhich component \ncosts us the most? Foo\nBar\nZed\nFoo\nBar\nZed\n Cost  is a \nconcept\nIt takes time to arrive at the ah-ha! moment. There is also a risk that we may\nnot have the knowledge or experience necessary to individuate concepts\nrequired to design the right system. Starting with an existing meta-model,\nsuch as an architecture pattern, can reduce this risk. report erratum  \u2022  discuss\nDesign the Meta-Model \u2022 103", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 116", "position": 116, "chunk_type": "semantic", "token_estimate": 311}
{"text": "Pick a Pattern to Seed the Architecture: As discussed in The Four Principles of Design Thinking, on page 15, all design\nis redesign. Patterns are the ultimate example of the redesign rule in action. Architecture patterns describe a prepackaged meta-model relevant to a spe-\ncific problem. Pick an appropriate pattern, and the meta-model is free. We explore several popular patterns in Chapter 7, Create a Foundation with\nPatterns, on page 79. Notice how each pattern describes the elements, rela-\ntions, and rules. Each pattern\u2019s meta-model is complete, consistent, but also\nflexible so that designers may use the pattern under varying circumstances. Most architectures include one or two thematic patterns to seed the system\u2019s\ndesign. Even with these thematic patterns, there are still many details to sort\nout. As we add new concepts to the meta-model, it is possible that could\nundermine the patterns in our architecture\u2019s foundation. Reconcile Inconsistencies\nCombining meta-models\u2014for example, by merging patterns\u2014may introduce\ninconsistencies in the combined meta-model. For example, two meta-models\nmight define a worker element, but the responsibilities for the worker and\nrules for its use are radically different. Reconciling inconsistencies involves\nmerging similar concepts and renaming different concepts with the same\nname so that they remain distinct. Rules may also need to be adjusted. Failure\nto resolve these inconsistencies can undermine our design efforts. As we add new concepts to the meta-model, the rules for using those concepts\nshould also be updated. Rules describe how elements and relations interact in\nthe \nsystem. They \nmust \nreflect \nreality. For \nexample, \nmany \nprogramming \nlanguages\nhave strict type systems. If we implemented a pipe-and-filter system (introduced\non page 84) using a language with strong types, then the meta-model should\ninclude rules about types. If the language we choose doesn\u2019t enforce types, then\nwe\u2019ll need to define message descriptions or protocol headers. Rules also describe conceptual constraints we choose to place on the architec-\nture. Conceptual constraints allow us to promote specific quality attributes. For example, in the layers pattern (introduced on page 80), an element within\na layer is only allowed to use other elements in the same layer or the layer\ndirectly below it. We created this rule to promote maintainability. Violate this\nrule, and we\u2019ll end up with an unmaintainable bowl of spaghetti. Chapter 8. Manage Complexity with Meaningful Models \u2022 104\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 117", "position": 117, "chunk_type": "semantic", "token_estimate": 390}
{"text": "Here\u2019s an example of one naming progression. In this project, we were: attempting to name a set of elements responsible for fetching data from a web\nservice and transforming it. Name\nStage\nThe thing that does the thing\n1. Missing\nCranberry\n2. Nonsense\nJob Starter Process\n3. Honest\nData Fetcher, Checker, Transformer, and Job\nStarter\n4. Honest and Complete\nData Transformation Job Runner\n5. Does the Right Thing\nData Preparer\n6. Intent\nData Preparation Agent\n7. Domain Abstraction\nThe final name emerged from the realization that there are several Agents\nwith similar responsibilities and interaction rules across the system. The\nconcept of Agents was a powerful idea that let us create clean abstractions\nand an improved meta-model. Now the name Agent carries meaning and\ncommunicates intent for architectural elements bearing that name. Use names as a litmus test to determine how well you understand the concepts\nin the architecture. If your names are nonsense or simply honest, then you\nmay have more work until you understand the concepts you\u2019re designing. Get Your Hands Dirty: Create an Architecture Flipbook\nfor Conway\u2019s Game of Life\nConway\u2019s Game of Life is a zero player simulation in which the universe\nconsists of a two-dimensional grid of cells. 3 For any given iteration of the\ngame, a cell may be either alive or dead. There are four rules that determine\na cell\u2019s state:\n1. Any live cell with fewer than two live neighbors dies (under-population). 2. Any live cell with two or three live neighbors lives on to the next generation. 3. Any live cell with more than three live neighbors dies (over-population). 4. Any dead cell with exactly three live neighbors becomes a live cell (repro-\nduction). 3.\nhttps://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\nChapter 8. Manage Complexity with Meaningful Models \u2022 106\nreport erratum  \u2022  discuss", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 119", "position": 119, "chunk_type": "semantic", "token_estimate": 298}
{"text": "Apply the Vocabulary of the Architecture: Terminology mismatch is a common source of confusion when moving from\narchitectural abstractions to code. The architecture talks about layers, services,\nand filters, but the code implements packages, classes, and methods. The sim-\nplest way to embed a model is to use the vocabulary of the architecture. If we\u2019re using layers, then let\u2019s call our code packages layers. If we\u2019ve adopted\na pipe-and-filter pattern, our classes should be named pipes and filters. If we\ntalk about pilots and navigators in our system metaphors, then we should\nuse these words as names for types and instances. Embedding the domain model into the code is another way to shrink the gap\nbetween models and code. Modeling code after domain concepts is a common\npractice in object-oriented programming. Many frameworks, including object-\nrelational mappers and actor-based systems, assume (or at least strongly\nencourage) a domain model as part of the implementation. Modeling the\ndomain in this way is a core tenet of domain-driven design and several other\ndesign methodologies. Similarly, event-based and reactive patterns lean\nheavily on insights derived from event models derived from domain workflows. Organize Code to Make Patterns Obvious\nGood naming is just the beginning. How we organize the code dramatically\naffects architectural structures in code. A compiler will happily build your\nJava application whether every class is in the same file or classes are logically\norganized around thematic packages. The following example shows how to\norganize layers into their own code packages:\nDisplay\nBusiness \nLogic\nData Access\nModels\nModule View\ncom.foo.application\n    businesslogic\n        account\n        project\n        steps\n    dataaccess\n        user\n        application\n        step\n    display\n        navigation\n        project\n        step\n        widgets\n    models\n        display\n        system\nCode Packages\nLayer\nAllowed to use\nNote: IDE displays packages \nin alphabetical order. Chapter 8. Manage Complexity with Meaningful Models \u2022 108\nreport erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 121", "position": 121, "chunk_type": "semantic", "token_estimate": 300}
{"text": "There are other ways to organize this code. Instead of using traditional layers,: we could have created functionality-oriented modules. With this pattern, all\nclasses required to complete a functional area are contained within a single\npackage. Classes external to the functional package would not be able to\naccess the business logic or data access classes. Organizing code so that it matches the designed module structures should be\na standard best practice. Patterns on a whiteboard don\u2019t promote quality\nattributes. The code does. If you can\u2019t see the pattern in the built system, then\nit doesn\u2019t exist. If the pattern wasn\u2019t implemented, then desired quality attributes\ncan\u2019t be satisfied as designed. Simon Brown has done a lot of work in this area\nand shares several examples in Software Architecture for Developers [Bro16]. Organizing code into packages that correspond to architectural elements is\nthe least we can do. Even better is to enforce the relations so that it becomes\nvirtually impossible to violate the architecture. Enforce Relations Among Elements\nThe problem with most architectures is that they rely on discipline and vigi-\nlance to maintain conceptual integrity. Instead of relying on discipline alone,\nlook for ways to enforce the architecture in code. It is impossible (or at least\nreally difficult) to disobey design decisions enforced by the code. The degree to which we can enforce the architecture depends on the type of\nstructures we\u2019re dealing with, the programming languages, operating environ-\nment, and the other technical factors. Module Structures\nModule structures are the simplest to see in the code but often the most dif-\nficult to enforce. In most modern programming languages, we can enforce an\nallowed to use relation by limiting access to specific modules. If that fails, it\u2019s\nusually possible to distribute modules as a library with decent documentation. When we can\u2019t enforce relations, we can at least monitor them. Use static\nanalysis tools to identify violations of the uses, allowed to use, or requires\nrelations. In some programming languages, you might use types creatively to\nrender relations among elements visible and easy to monitor. Component and Connector Structures\nOne approach to enforcing component and connector models is to design\nthe system to fail fast when the architecture is violated. Design by contract,\nfirst \ndefined \nin \nObject-Oriented \nSoftware \nConstruction \n[Mey97], \nis \nan \napproach\nwhere pre-conditions, post-conditions, and invariants are added to the code\nreport erratum  \u2022  discuss\nBuild Models into the Code \u2022 109", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 122", "position": 122, "chunk_type": "semantic", "token_estimate": 404}
{"text": "and checked at runtime. When a developer violates the contract, the appli-: cation throws an error and execution ceases. Contracts work at many\ngranularities \nof \nabstraction, \nincluding \nobjects, \nservices, \nand \nprocesses \nacross\nthreads. Another common approach to enforcing C&C models is to prevent connections\nbetween components that should not be connected. One example is to require\nauthentication between components, a common practice when connecting to\na data source from a data access tier. The swift rise in popularity of microservices architecture is in part due to the\nfact that the pattern makes domain models visible and enforceable at runtime. Enforcing allowed to use relations within module structures can be challeng-\ning. Turn those modules into components, and we can enforce interaction\nrules at runtime. Allocation Structures\nExpressing the intent behind allocation models in the code used to be\nextremely difficult. It is not possible to describe and enforce allocation models\nin the code thanks to the rise of technologies and paradigms such as platform-\nas-a-service, container technologies (for example, Docker), infrastructure as\ncode, and distributed version control systems. Treating infrastructure as code creates opportunities for static analysis. Automating build and deployment pipelines to take advantage of cloud-based\nplatforms means we can introduce automated architecture checks into the\ndeployment process. Most platform-as-a-service products can test hardware\nallocation limits. We can also use configuration and automation to enforce\nhardware scaling and platform provisioning. Containers are lightweight and disposable compared to physical hardware\nand traditional virtual machines. With containers, it is possible to adopt\nsimple and easy-to-enforce allocation patterns such as installing one process\nper container. Distributed version control combined with web-based tools such as GitHub\nmakes it easy to allocate teams to specific architectural components while\nmaintaining an open, social development culture. Workflows such as fork\nand pull or upstream repository limit access without preventing collaboration. Add Hints as Comments\nCode itself can only take our models so far. We might be able to enforce design\ndecisions, but code constructs won\u2019t tell us why those decisions were made. Chapter 8. Manage Complexity with Meaningful Models \u2022 110\nreport erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 123", "position": 123, "chunk_type": "semantic", "token_estimate": 349}
{"text": "We can infuse some rationale into the code with good naming and an appro-: priate use of known patterns. For everything else, there are comments. Descriptive prose within the code can take many forms. Comments that\ndescribe rationale are essential, and you should link liberally to existing\ndesign documentation. Even exception messages can contain design hints. We can avoid generic errors by briefly explaining the design rationale behind\nthe error. For example, an UNKOWN error is less helpful than ASSUMPTION\n_VIOLATED: Document ID required for validation. Generate Models from Code\nEven when models cannot be seen or enforced in the code, sometimes we can\nautomatically generate models of the system we\u2019ve built. Depending on the\nprogramming language, technologies, and patterns, it may be possible to use\nmodels to verify compliance and monitor design evolution automatically. Any modern object-oriented language can generate UML class and package\ndiagrams. Most programming languages have a dependency analysis tool. Use this generated models to analyze module structures. Component and connector structures are harder to generate automatically. To generate C&C structures, add instrumentation so that runtime models\ncan be observed. Use the recorded data to generate models and perform other\narchitecture compliance analysis. See Activity 33, Observe Behavior, on page\n295 for further thoughts on this topic. Project Lionheart: The Story So Far\u2026\nDevelopment has started, though things got off to a rocky start. The team\nchose to go with conventional tiers pattern for the runtime structures and\nlayers for the code, but there are still many decisions to make. Many team\nmembers use different words to describe the same elements in the architec-\nture. As a result, our design discussions end with everyone nodding heads\nin agreement only to learn later that each person took away a different\nconclusion. The code is already a wreck. It reflects the team\u2019s lack of understanding of\nthe design decisions made so far. The patterns you thought the team selected\nfor the architecture are nowhere to be found within the system. After realizing the problems, you call an impromptu whiteboard jam (described\non page 255) in an attempt to build consensus around the design decisions\nand extract a common meta-model. During the whiteboard jam, you encourage\nteammates to describe the system precisely. Eventually, we settle on some\nreport erratum  \u2022  discuss\nProject Lionheart: The Story So Far\u2026 \u2022 111", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 124", "position": 124, "chunk_type": "semantic", "token_estimate": 390}
{"text": "You might say\u2026: If your goal is to explore\u2026\n\u201cScalability and reliability are our top two quality\nattributes. How can we promote these at the same\nA specific set of quali-\nty attributes\ntime?\u201d (You\u2019ll share the specific scenarios with\neveryone.) \u201cWe\u2019ve decided to use REST for our APIs. Let\u2019s figure\nout what that really means for our system.\u201d\nInterfaces between\ncomponents\n(Assumes everyone knows what is involved with\nRESTful architecture)\n\u201cBased on our stakeholders\u2019 business, we need to\ndefine some common abstractions that we\u2019ll use\nthroughout the system.\u201d\nDomain models\n\u201cWe\u2019re seeing a size and scale of data we didn\u2019t\nanticipate ten years ago when we first designed the\nsystem. Let\u2019s figure out as many options as we can.\u201d\nHow to get out of a\njam\n\u201cWe need to partition the system so we maximize\nparallel development effort.\u201d\nAllocation structures\n\u201cWe need to decide how we\u2019re going to get data from\npoint A to point B. Before we go into pros and cons,\nlet\u2019s understand the options.\u201d\nPattern selection\n\u201cToday we want to see as many different ideas as\npossible. Everyone should try for at least 5 ideas.\u201d\nMany different ideas\nKick Off the Workshop\nStart the workshop by setting the stage for a successful collaboration. Make\nsure everyone has the proper context by sharing what you know so far about\nthe problem and the architecture. Review anything relevant to the area you\nplan to explore. The amount of workshop time devoted to sharing context\nshould be commensurate with the group\u2019s background knowledge. If this is\nthe first time some people have seen business goals or ASRs, spend more\ntime describing the context. After reviewing the context, outline the workshop goals. These goals are used\nthroughout the workshop and keep the group focused. During the workshop,\neveryone will create designs to satisfy the goals. We\u2019ll also critique design\nideas with these goals in mind. Chapter 9. Host an Architecture Design Studio \u2022 116\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 129", "position": 129, "chunk_type": "semantic", "token_estimate": 328}
{"text": "on specific action items. Which ideas seem promising and should receive: more attention? Were any significant risks raised that should be addressed? Are there any experiments that should be started? Take pictures of all the material produced during the workshop. Create write-\nups in a shared repository while the ideas are still fresh in everyone\u2019s minds. Most importantly, record the action items and follow up with individuals to\nmake sure they take the next steps. Choose Appropriate Design Activities\nAs the design studio host, we\u2019re responsible for choosing activities that guide\neveryone through the create-share-critique steps in a fast, effective, and fun\nway. There are many design activities we could use, though not all design\nactivities are appropriate for architecture design. Try to select activities that\nare architecturally focused and effective when thinking about the system as\na whole. Here is an example workshop agenda based on the round-robin design\nactivity. The workshop itself might run anywhere from 90 minutes if we\u2019re\nonly exploring initial ideas to a whole day if we\u2019re well prepared and plan to\nexplore multiple parts of the system deeply. Purpose\nTiming\nActivity\nArm everyone with the knowledge\nthey\u2019ll need to be an active, contribut-\ning participant in the workshop. 15 minutes\nIntroduce the context\nand goals\nPromotes rapid divergence and conver-\ngence to get the workshop rolling. This\n30 minutes\nRound-robin design\nactivity, described on\npage 252\nagenda plans for only one round, but\nyou could do more with more time. Summarize findings as posters so they\ncan be shared more easily among the\ngroup. Start building consensus. 30 minutes\nGroup Poster Activi-\nty, described on page\n249\nAllow about 3 minutes per poster for\npresentations. Use dot voting for the\ncritiques. 15 minutes\nPresent and critique\nposters\nReview how the workshop went and\ndefine next steps to ensure strong fol-\n10 minutes\nReflect and review\naction items\nlow-up. Allow about 10% of the work-\nshop time for this. report erratum  \u2022  discuss\nChoose Appropriate Design Activities \u2022 119", "domains": ["Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 132", "position": 132, "chunk_type": "semantic", "token_estimate": 334}
{"text": "Set Expectations from the Start: Great workshops have some degree of mystery but also let participants know\nup front what they\u2019ll be doing and why you\u2019re here. State the workshop goals\nup front and ensure the group is on board before starting. Start a workshop by sharing the general workshop agenda. It\u2019s not necessary\nto share every detail. Some details we\u2019ll want to keep secret to prevent partic-\nipants from getting confused or \u201cpre-fetching\u201d designs. For workshops running\nmore than a few hours, share estimated start times for agenda items so par-\nticipants can self-select in or out of specific activities. This way participants\nwill be present at the workshop and deal with distractions at times that won\u2019t\ndisrupt the workshop. Set ground rules at the start of the workshop. Here are some examples of\nground rules:\nSample Workshop Ground Rules\nWhen time is up, we move on\nEveryone participates\nAsk questions if you need help\nNo \u201cright\u201d or \u201cwrong\u201d answers\nHave fun (seriously) \u263a\nWatch the clock (I\u2019ll help too)\nIntroduce Activities with the Tell-Show-Tell Approach\nWhen introducing a new activity to the group, always tell participants what\nthey\u2019ll do, show them an example of what it looks like, then review the instruc-\ntions you just gave them. Most people will miss important details the first time\nthey see something new. Reviewing instructions after seeing a concrete example\ngives participants a second chance to ask questions about the activity. It\u2019s best to use examples from previous workshops. When examples don\u2019t\nexist, create a mock-up by staging a picture of the activity or approximating\nan example. Share Tips for Activities\nInevitably when you say Go!, someone will freeze up. For many participants,\nthis workshop could be their first time working collaboratively like this. To help participants get started, share tips for each activity. A simple reminder\nor nugget of advice is an excellent way to help participants avoid blank page\nsyndrome. Keep an eye out for groups or individuals staring at a blank\npage\u2014they may need help getting started. report erratum  \u2022  discuss\nManage the Group \u2022 123", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 136", "position": 136, "chunk_type": "semantic", "token_estimate": 348}
{"text": "After some brief discussion about the sketches, Marie divided participants: into groups. Each group used Google Hangouts and shared Box.com docu-\nments to create a presentation with their ideas for the architecture. At the\nrequested time, everyone rejoined the workshop teleconference to share their\npresentations. During the critiques, Marie and other participants took notes\ntogether in a shared document. Instead of a rapid-fire 90-minute workshop,\nthe design studio ended almost on time after a little more than two hours. Project Lionheart: The Story So Far\u2026\nThe team is at a crossroad. Some team members feel we should use a service-\noriented approach using microservices. Others feel we should play it safe and\nstick with a tried-and-true multi-tier pattern. You need to resolve the conflict\nand create buy-in for the design decision. Since either pattern would probably\nwork out fine, you host a design studio to help the team decide. Your goal for the workshop is to explore the nuances of each pattern and\nflush risks into the open for the team to discuss. You start the workshop with\nsmall-group exercises to generate ideas. The microservices and multi-tiered\npatterns come up, but a few other interesting and unexpected ideas are raised\nas well. After the initial round of presentations and critiques, you have us create\ngroup posters. Unexpectedly, as the team works through the different ideas,\nmicroservices fall completely out of favor! By the end of the two-hour work-\nshop, the team explored a half dozen design options and arrive at a great\nsolution. More importantly, everyone had a say in the final decision and there\nseems to be a genuine sense of shared ownership among the team that didn\u2019t\nexist before the workshop. Next Up\nA design studio is a fantastic method for quickly exploring ideas. Perhaps\neven more important is the journey your team takes to arrive at a decision. Everyone who participates has a stake in the design they helped create. A\nsense of shared ownership encourages greater autonomy and a sense of\nresponsibility. This shared ownership permeates all aspects of design from\ncode to architecture. Collaborative design workshops are a powerful tool, but as we\u2019ve seen so far,\nthere is more to architecture design than group work and sticky notes. A\ndesign studio alone is not sufficient for designing an amazing architecture. Chapter 9. Host an Architecture Design Studio \u2022 126\nreport erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 139", "position": 139, "chunk_type": "semantic", "token_estimate": 398}
{"text": "Legend: Project Lionheart\nComponent Overview\n(Dynamic Structures)\nRead\nRead/Write\nRead\nRead\nDB Driver", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 142", "position": 142, "chunk_type": "semantic", "token_estimate": 13}
{"text": "Zoom In or Out with a Refinement View: I always love that scene in a television crime show when the hero cracks the\ncase by enhancing a blurry image. I can\u2019t see his face. Zoom in. Enhance! The\ncool thing about software, unlike blurry images, is that we actually can zoom\nin and enhance nearly infinitely. Refinement is the process of increasing detail in a model over a series of views. It\u2019s like zooming in on a structure to show the elements\u2019 inner workings,\nenhancing, and then zooming in again. Let\u2019s zoom into the Lionheart Display Business component to take a closer\nlook at some of its static structures. Project Lionheart\nDisplay Business Layers Refinement\n(Static Structures)\nDisplay\nBusiness\nService Access\nModels and \nUtilities", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 143", "position": 143, "chunk_type": "semantic", "token_estimate": 124}
{"text": "Layer: A is allowed to use B\nLegend\nAt one level of refinement, we can see the Display Business component uses\na typical layered pattern: one layer for display, business, and service access\nlogic, with a sidecar layer to organize data models and utility classes. This\ndiagram establishes context, but we might learn more about maintainability\nif we refine further. Project Lionheart\nDisplay Business Packages View\n(Static Structures)\nManage", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 143", "position": 143, "chunk_type": "semantic", "token_estimate": 69}
{"text": "Adapter: Display Layer\nBusiness Layer\nService Access \nLayer", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 143", "position": 143, "chunk_type": "semantic", "token_estimate": 8}
{"text": "Package: A is allowed to use B\nLegend\nLayer\nreport erratum  \u2022  discuss\nShow the Architecture from Different Views \u2022 131", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 143", "position": 143, "chunk_type": "semantic", "token_estimate": 21}
{"text": "In this refinement, we show packages inside the layers and how they interact: with one another so we can reason about maintainability quality attribute\nscenarios. Looking at this refinement, it\u2019s clear that the RFP Package might\nbe too interconnected, which makes testing and debugging difficult. Notice that the Models and Utilities Layer is not shown in this refinement. Everything is allowed to use classes in the Models and Utilities Layer. Including all the relations would make the diagram too cluttered for analysis,\nso we eliminated some relations from this view. Slicing and dicing views is\nuseful but can make the architecture models harder to understand. Refinement views help us focus on the details needed to answer specific\nquestions about the architecture. Coarse-grained refinements provide a big\npicture view of the world. After we\u2019ve established the context, we can show\nfiner-grained refinements by zooming in to show important details needed by\nspecific stakeholders. Use the principles of architecture minimalism described in Preserve Ambigu-\nity, on page 16 to decide when to stop refining a model. Only refine to a level\nof detail necessary to demonstrate specific quality attributes and reduce high-\npriority risks. Show How the Architecture Promotes Quality Attributes\nA quality attribute view demonstrates how the architecture achieves specific\nquality attributes. Quality attribute views might hide details not relevant to\nthe current discussion, or highlight details relevant only to the given quality\nattribute. For example, consider this availability scenario for Project Lionheart\nfrom the table on page 54. A user searches for open RFPs and receives a list of available RFPs 99% of the\ntime on average over the course of the year. To satisfy this quality attribute, we introduced a redundancy pattern. Let\u2019s\ncreate a view as shown in the figure on page 133. Promoting availability means our Lionheart services must be resilient in the\nface of failures. To accomplish this, we\u2019ll need multiple instances of the Display\nBusiness, Search Service, and Search Index components. Since the Display\nBusiness and Search Service components are stateless microservices, we can\neasily deploy multiple instances in any container management system such\nas Kubernetes\n1 or Marathon. 2\n1.\nhttp://kubernetes.io/\n2.\nhttps://mesosphere.github.io/marathon/\nChapter 10. Visualize Design Decisions \u2022 132\nreport erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 144", "position": 144, "chunk_type": "semantic", "token_estimate": 370}
{"text": "Display: Business\nDisplay \nBusiness\nDNS/Load \nBalancer\nSearch Index \n(Secondary)\nNote: Services are \nstateless and auto-scale\nDisplay \nBusiness\nSearch \nService\nSearch Index \n(Primary)\nWeb Service\nLegend\nConfigured\nOff-the-shelf \nComponent", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 145", "position": 145, "chunk_type": "semantic", "token_estimate": 28}
{"text": "Project Lionheart: Availability View\n(Dynamic Structures)\nNote: Assume  sticky  \nsessions, load balancer \npings for health check\nThe Search Index is stateful and a potential performance bottleneck for our\nsystem, so we\u2019ll need to be more careful about data storage. We\u2019ll also need\nto think through routing when there is a fault to avoid downtime and data\npartitioning. To keep things simple, we\u2019ll use a load balancer and Domain\nName System (DNS) to route requests. Let\u2019s use the diagram to determine whether we satisfied the quality attribute\nscenario. Pretend one of the Search Index components fail. The load balancer\ndetects the failure with a health check and routes requests to the secondary\nSearch Index. So far, so good. This view is moving in a good direction but needs more work. How often does\nthe health check occur? What are the requirements for a ping? What happens\nif the load balancer goes down? What happens when a failed Search Index\ncomes back online? These questions and more should be described in\nexplanatory prose accompanying this diagram. One diagram might not be\nenough to thoroughly explain how the architecture satisfies our availability\nscenario. Connect Elements from Different Views\nWith many views in play, it\u2019s useful to see how elements in different views\nare related to one another. A mapping view serves just this purpose by com-\nbining two or more views into a new view that shows how the elements are\nrelated. Two useful mapping views are work assignment and deployment. In a work\nassignment view, we show who works on different parts of the system by\nmapping teams with the elements they\u2019ll build. Deployment views show\nwhere runtime elements from a component and connector view will be\ninstalled and used. report erratum  \u2022  discuss\nShow the Architecture from Different Views \u2022 133", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 145", "position": 145, "chunk_type": "semantic", "token_estimate": 300}
{"text": "Here\u2019s an example of a work assignment view for Project Lionheart:: Notes\nTeam Assigned\nComponent\nTeam consists of front-end web\ndevelopment pros\nHoney Badgers\nWeb UI\nComponent is tightly coupled\nwith Web UI\nHoney Badgers\nDisplay Business\nRed Shirts\nSearch Service\nTeam of experienced Solr\ndevelopers\nRed Shirts\nSearch Index\nTeam has capacity; compo-\nnent directly impacts user\nexperience\nHoney Badgers\nFavorites Service\nFirst team available\nOpen/Unstaffed\nAlerting\nTeam has expertise\nRed Shirts\nCrawler\nInfrastructure experts\nTron\nDNS/Load Balancer\nThey own the databases\nCity of Springfield\nUser metadata and\ncontracts databases\nNotice that this view is not a diagram. Our objective is to communicate design\ndecisions by any means necessary. Sometimes a simple table is all that\u2019s\nneeded to get the job done. Mappings create connections between stakeholders with different concerns. This work assignment view is perfect for a project manager who needs to\ncreate a schedule or staffing plan. Mapping views provide a layer of context that can be difficult for stakeholders\nto piece together on their own. Consider a product manager\u2019s needs. Maybe\nthey want to know when certain features will be ready to ship. A mapping\nbetween architectural components and value-adding features would help\neveryone understand which parts of the software support different features. This tiny smidge of knowledge enables team self-organization and helps\ndevelopers prioritize work with the product manager\u2019s needs in mind. Now\nyou\u2019re empathizing with stakeholders! Let Ideas Breathe with a Cartoon\nAll the views we\u2019ve seen so far have been rather precise. Precision has a cost. Precise models require exacting details and are time-consuming to create. Sometimes precision gets in the way of communication, especially when you\u2019re\nChapter 10. Visualize Design Decisions \u2022 134\nreport erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 146", "position": 146, "chunk_type": "semantic", "token_estimate": 285}
{"text": "Create Custom Views to Show Exactly What You Need: Any view of the architecture that helps you effectively tell a story about the\nsystem to stakeholders is a view worth having. Get creative and make custom\nviews for your particular purpose. Views always combine multiple variables. Elements and responsibilities. Quality attributes and patterns. Elements and project schedules. Inventing\na new view can be as simple as combining new variables with architectural\nelements. Need to show performance bottlenecks in the system? Start with a\ncomponent diagram that shows information flow, color-code components\nbased on execution time, and voil\u00e0, we\u2019ve created a performance view. Remember, all views, even custom views, are governed by an underlying meta-\nmodel as discussed in Design the Meta-Model, on page 101. Draw Fantastic Diagrams\nGreat diagrams are not just beautiful pictures. Great diagrams are accurate\nmodels that reflect the conceptual underpinnings of the architecture. Archi-\ntects may be infamous for drawing box and line diagrams, but there\u2019s more\ngoing on in these diagrams than just coarse-grained abstractions. As you learned in Show the Architecture from Different Views, on page 129, you\ncan show many different design ideas with diagrams. Visualizing the architec-\nture with a diagram makes it tangible in a way that other mediums cannot. Fantastic diagrams make the architecture accessible to everyone. Here are some tips for creating fantastic diagrams:\nAvoid this\nDo this\nDon\u2019t: Assume your readers know your\nnotations (even with the UML). Do: Create a legend that summarizes\nparts of the meta-model relevant to\nthis diagram. Don\u2019t: Try to include everything in a\nsingle diagram. Do: Add a descriptive title and tell\nwhat kinds of structures are in the\ndiagram. Don\u2019t: Use notations that lose meaning\nwhen printed in black and white. Do: Add text annotations to enhance\nclarity. Don\u2019t: Go overboard with superfluous\nflourishes or an excessive variety of\nshapes and lines. Do: Use a consistent notation across\nall diagrams. Don\u2019t: Skip descriptive prose. Do: Make the patterns visible. Let\u2019s explore these tips in more detail. Chapter 10. Visualize Design Decisions \u2022 136\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 148", "position": 148, "chunk_type": "semantic", "token_estimate": 346}
{"text": "Customer: Sales\nData \nScrubber\nAnalytics \nEngine\nAnalytics \nMonitor\nLegend\nBrief description of \nthe diagram\nTells us what the \nsymbols mean\nWe can see immediately that we\u2019re dealing with fine-grained web services and\nthat the communication mechanism relies on Apache Thrift. 3 Downstream\ndesigners responsible for implementing a component in this architecture will\nwant to know these details. Other stakeholders can use this information as\nthe basis for further conversations. The legend introduces the architecture\u2019s conceptual meta-model (introduced\non page 101) to our audience. Draw the legend first and use it to keep our\ndiagrams consistent with reality and turn them into tools for analysis. Now that we have a common understanding of the meta-model, we start to\nnotice mistakes and have questions about the diagram. Should the Analytics\n3.\nhttp://thrift.apache.org/\nreport erratum  \u2022  discuss\nDraw Fantastic Diagrams \u2022 137", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 149", "position": 149, "chunk_type": "semantic", "token_estimate": 139}
{"text": "Monitor and Data Scrubber be microservices? What if I told you the Analytics: Engine service provided a REST interface and not Thrift? Is this a mistake,\ngap in knowledge, or plan for the future? No matter what notation you use, every diagram should have a legend. This\nadvice applies to standardized notations such as the UML as well as custom\nnotations. Not everyone who sees our diagram will be familiar with the dialect\nof UML you use. Legends enhance meaning. Highlight the Patterns\nThe previous diagram is hiding a secret. Look what happens if we move some\nof the components around. Notice that we only changed the elements\u2019 positions. Web Services Interaction View \n(Dynamic Structures)", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 150", "position": 150, "chunk_type": "semantic", "token_estimate": 115}
{"text": "Simon says:: Keep It Simple and Complete\nBy Simon Brown, independent consultant and author of Software Architecture for\nDevelopers [Bro16]\nHaving run diagramming workshops for more than 10,000 people around the world,\nI can say with some confidence that software developers struggle to communicate\nsoftware architecture using diagrams. Many of the diagrams I see focus on the\ndecomposition of software into logical building blocks, although they usually do this\nat the expense of information about technology. After all, we\u2019ve been taught to keep\nthe \u201clogical view\u201d of a software system separate from the \u201cdevelopment view.\u201d Unfor-\ntunately, this tends to result in a collection of diagrams that make little sense when\nviewed individually, with neither diagram providing an accurate reflection of the code. One solution is to merge the logical and development views of a software system, treating\nthe combined diagrams as a collection of zoomable maps on top of a code base. This is\nthe concept at the core of my C4 model\u2014a collection of diagrams that show varying levels\nof abstraction. A System Context diagram shows your software system and how it fits\ninto the environment around it, in terms of users and other software systems. A Container\ndiagram zooms into your system boundary to show how it\u2019s made up of containers\n(applications and data stores). A Component diagram zooms in to a particular container\nto show the components inside it. Optionally, a UML class diagram zooms into a partic-\nular component to show the code-level elements it\u2019s built from. Although UML is still useful, I prefer a simple boxes and lines notation to describe\nsoftware architecture. To avoid confusion, my advice is to keep the notation as simple\nand self-describing as possible, adding a key/legend where necessary. Finally, adding\nmore text to boxes is a great way to add information about responsibilities, providing\na nice, at-a-glance view and removing ambiguity from what is usually just a collection\nof named boxes. We want the patterns to be visible in the diagrams we draw. We can accom-\nplish this in a variety of ways. Choose names that reflect the pattern. Create\nviews that highlight the patterns we\u2019ve selected. Arrange the elements so you\ncan see the pattern. Above all, use patterns as part of your vocabulary for\nsharing designs. Strive for Consistency and Simplicity\nEvery drop of ink in our diagrams means something.", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 151", "position": 151, "chunk_type": "semantic", "token_estimate": 394}
{"text": "Joe asks:: Should I Use an Architecture Description\nLanguage? We\u2019re not going to cover formal Architecture Description Languages (ADLs) in this\nbook, but you should be aware that such a thing exists. Most architects use simple\ndrawing tools such as PowerPoint, Visio, and Graphviz for day-to-day work. Some\npeople even use pencil, paper, and a phone camera to great effect. Simple diagramming tools are easy to use and produce shareable diagrams, but pic-\ntures don\u2019t easily facilitate in-depth analysis. ADLs solve this problem by restricting\nand enforcing the vocabulary used to specify models. ADLs are usually implemented\nin tools, which can run automated checks against the models. Some ADLs can even\ngenerate or reverse-engineer code. ADLs sound awesome but in practice don\u2019t always make life easier. The ADL you\nselect will limit expressiveness of the design. Software tools that support ADLs will\noften save models in proprietary formats. In my experience, most tools are immature\nand have a steep learning curve. My advice is to use an ADL only if you really, really want to use one. You can peruse\nan up-to-date list of ADLs at http://www.di.univaq.it/malavolta/al/. Project Lionheart: The Story So Far\u2026\nSoftware development is in full swing and progressing nicely. Every day we\nlearn something new about the problem we\u2019re solving. The architecture is\nbecoming more mature with every detail. The team draws pictures regularly\nto bounce ideas off each other and work through alternatives. Teammates frequently sketch the same diagrams during design discussions. You take a picture of some whiteboard sketches with your phone and add\nthe pictures to your source code repository along with with a brief write-up. You also start to build out element responsibility views so it\u2019s easier to explain\nhow everything works together. So far these views have been most useful\nwhen we add new elements to the architecture. Up to this point in the project we\u2019ve only shared design decisions informally. And we\u2019ve had a few misses because of this. You decide it\u2019s probably time for\nus to improve our documentation and rely less on tribal knowledge. report erratum  \u2022  discuss\nProject Lionheart: The Story So Far\u2026 \u2022 141", "domains": ["Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 153", "position": 153, "chunk_type": "semantic", "token_estimate": 357}
{"text": "Overview and introduction to the SAD Briefly describes the purpose of the: document as well as the methodology used to organized and create it. Your SAD could be the first time some stakeholders have read an archi-\ntecture description. Take this opportunity to educate them just-in-time\nso they can appreciate the architecture designed for them. Summary of stakeholders, business goals, and architecturally significant\nrequirements Since all decisions in our architecture flow from stakehold-\ners\u2019 concerns, list them before describing the design. I like to summarize\nkey constraints and quality attributes here as well. If you\u2019ve created an\nASR Workbook (introduced on page 60), then add a reference to it. Strive\nto keep the architecture description DRY (Don\u2019t Repeat Yourself), just like\nyour code. Context view Provides an overview of where the software system fits in the\nworld. See Activity 22, Context Diagram, on page 265 for details. Relevant views As we discussed in Show the Architecture from Different Views,\non page 129, architecture is too big and complex to show in one diagram. We need to create multiple views of the architecture to explain how it\nsatisfies quality attributes and other requirements. A list of views is not\nvery consumable, so to help our readers we\u2019ll organize views around a\nrelated set of stakeholder concerns. Each viewpoint shows views needed\nto reason about something a stakeholder cares about, such as a set of\nrelated quality attribute scenarios. You\u2019ll learn more about using view-\npoints in Organize Views around Stakeholders\u2019 Concerns, on page 152. Risks, open questions, future work Include a section for known risks and\nopen questions. The purpose of these sections is to shine a light on the\nland mines you already know about so downstream designers can hope-\nfully avoid them. Appendices At a minimum include a term glossary and list of acronyms with\nexpansions. I recommend you include a quality attribute taxonomy as an\nappendix as well. Some formal documents will also include change proce-\ndures and change request templates. Creating a SAD can be exhausting. Work as a team to complete the document. Designate one person as the Master of the SAD. The Master of the SAD creates\nthe template and decides who will write each section of the document. The\nMaster of the SAD is also responsible for making sure the document is com-\nplete and has a consistent style. Chapter 11. Describe the Architecture \u2022 148\nreport erratum  \u2022  discuss", "domains": ["Design Principles"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 160", "position": 160, "chunk_type": "semantic", "token_estimate": 406}
{"text": "Avoid Wasting Time: For the sake of completeness, there is a quadrant on our grid made up of\ndifficult-to-change, difficult-to-share description methods. If you find yourself\nhere, it\u2019s time to try something different. Let\u2019s look at two examples of waste-\nof-time description methods. One example of a possible waste of time is the slideware architecture\ndescription. Presentations are a powerful tool for architects. The problem with\nslides is that they rarely stand on their own and can be difficult to change. Someone must present them to make sense. Someone spent hours getting\nall the transitions and layered boxes and connecting arrows to look just right. After so much work, people hesitate to change their beautifully laid-out dia-\ngrams, even when the world has changed. Compared to tribal methods, slides\nare etched in stone. The best way to avoid wasting time is by creating great architecture descrip-\ntions. All great descriptions, no matter what method you use, have four traits:\n1. They are custom built with the audience in mind. 2. They show multiple views of the architecture. 3. They clearly define the elements and their responsibilities. 4. They explain the rationale for design decisions. In the next sections, you\u2019ll learn what these traits mean and how to put them\ninto practice to create fantastic architecture descriptions. Respect Your Audience\nAs you learned in The Four Principles of Design Thinking, on page 15, all design\nis social. Who will use your architecture description? What do they need to\nget out of it? How can you best provide the information they need most? When\nempathizing with our stakeholders, we identified and recorded their key\nconcerns. We\u2019ve come up with a plan for addressing their concerns in the\narchitecture and now our job is to share that information. When you know your audience, you\u2019ll be able to create an architecture\ndescription that gives them exactly what they need. The better we do this,\nthe more likely people are to read the architecture description, which in turn\nfurther amplifies the impact of our design decisions. report erratum  \u2022  discuss\nRespect Your Audience \u2022 149", "domains": ["Architectural Patterns and Styles"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 161", "position": 161, "chunk_type": "semantic", "token_estimate": 350}
{"text": "George says:: Tell a Story at Many Levels\nBy George Fairbanks, software engineer at Google and author of Just Enough Software\nArchitecture: A Risk-Driven Approach [Fai10]\nWe\u2019ve all dropped into a project and struggled to understand the code. Perhaps you\nare browsing the repository of an open source project and find just one folder with\nhundreds of source files. It takes a lot of effort for you to infer how things work and\nyou probably make mistakes. It doesn\u2019t have to be that way. You can organize your code as a story at many levels\nso that it makes sense and tells a story as you zoom in or out. Consider what you\nate yesterday evening. You recognize it as dinner, and zooming in you also recognize\ncourses, then dishes, then ingredients. The levels help you think clearly. If you\u2019re wondering how long dinner will last,\nthinking about the number of courses is helpful and thinking about allergies is best\ndone by ingredients. But the reverse doesn\u2019t help at all. People have been thinking about dinner for a lot longer than software, so it\u2019s already\nbaked into our language. You will have to invent your story and levels, though you\ncan lean on developers who have come before you. Architecture patterns give you\ngeneral names to use like connectors and layers, and specific ones like reduce stage\nand broker. Your story at many levels won\u2019t come for free, so you will spend time gardening, making\nminor refactorings as you go so that the story stays clear. Today you might have just\nthree connectors, so they all go in the same folder, but some well-timed gardening should\ncatch it before it grows to dozens. As with most things, a stitch in time saves nine, plus\nit makes you look like you knew what you were doing the whole time. It\u2019s easy to focus your attention on the source code only, but the system\u2019s runtime\ndeserves similar attention, as does how it is allocated to hardware or containers. If\nyou want to think about it clearly, structure it as a story at many levels. Think about your stakeholders and what they value. What are their roles and\nresponsibilities on the project? How do they like to process information? How\nwill this person use the information you give them?", "domains": ["Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 162", "position": 162, "chunk_type": "semantic", "token_estimate": 386}
{"text": "exactly how to use all of UML\u2019s 16 or so diagrams, but not everyone in your: audience has studied UML as intensely. As you learned in Draw Fantastic\nDiagrams, on page 136, always define your notation and the meta-model behind\nit by including a legend on all diagrams. Finally, organize your description so it\u2019s easy to consume. Use a standard\ntemplate for written documents and make it look good. Fix the alignment\nso it\u2019s easy to read. Use text formatting to your advantage. Think about\nhow the information looks in print, digital, and presentation formats. A\ngreat-looking document tells readers the content is trustworthy and was\ncreated by a professional. Avoid this\u2026\nDo this\u2026\nDon\u2019t unnecessarily introduce\nnew concepts. Do define architectural concepts the\nfirst time you use them. Don\u2019t assume everyone intuitively\nunderstands diagram notations. Do speak the language of the problem\ndomain. Don\u2019t use jargon. Do include a legend on diagrams. Do use a common template if one exists. You\u2019ve learned a few techniques for documenting design decisions. You\u2019ve also\nlearned how to think about your audience to design an architecture description\nthat is right for them. Next, we\u2019ll combine these two ideas together by organizing\nthe architecture description relative to stakeholders\u2019 concerns. Organize Views around Stakeholders\u2019 Concerns\nDifferent people want to know different things about the software system you\nare building. Developers on your team will want to know about code organi-\nzation, deployment, and component interaction. Testers on your team will\nwant to know about the interfaces and communication protocols. The product\nowner on your team wants to know about technical dependencies and get a\nsense of the overall progress. New teammates might be overwhelmed by the\nexisting documentation and could benefit with some help getting started. At\na minimum, architecture descriptions should describe design decisions, design\nrationale, and structures in the design. How we organize this information is important too. The Human rule of design\napplies equally to how we share details about the design just as much as it\napplies to the design itself. When we organize views of the architecture and the various design documen-\ntation that goes with it with our stakeholders in mind, then it\u2019s far easier for\nChapter 11. Describe the Architecture \u2022 152\nreport erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 164", "position": 164, "chunk_type": "semantic", "token_estimate": 378}
{"text": "others to understand the architecture. Doing this requires that we think about: what stakeholders want to know. We can then create a view of the architecture\nunique to that set of related stakeholder concerns. Designing usable docu-\nments is how we get people to love our architecture descriptions. Establish the Viewpoints\nA viewpoint defines an approach for describing the architecture from the per-\nspective of a related set of stakeholder concerns. Viewpoints define not only\nwhat views you should show but also who the views are for, as well as the\nnotations, vocabulary, and rules to use when creating it. They are a part of the\nISO/IEC/IEEE 42010:2011 standard defined in ISO/IEC/IEEE 42010:2011\nSystems and software engineering \u2013 Architecture description [Int11]. Viewpoints were designed for use with traditional architecture descriptions,\nbut the general principles apply to any architecture description approach\nwe\u2019ve discussed. Let\u2019s look at an example. We\u2019ve identified several components in Project Lionheart. Eventually, we\u2019ll\nneed to deploy these components somewhere. The development team needs\nto know where to deploy them, and the city IT department will need to be told\nwhat systems to monitor. It sounds like we need a deployment viewpoint. Here\u2019s one possible view from that viewpoint:\nDeployed to\nComponent\nRuns in user\u2019s browser, served by Display Business\n(accessed through load balancer)\nWeb UI\nTomcat on a Linux VM, hosted by cloud provider\nDisplay Business\nTomcat on a Linux VM, hosted by cloud provider,\nVM is independently deployable from Display\nBusiness\nFavorites Service\nSame VM as Favorites service\nSearch Service\nCloud-provided Solr service\nSearch Index\nProcess initiated by cloud scheduler, independent\ncontainer (depends on cloud provider)\nAlerting Process\nLocal server maintained by City IT\nCrawler Process\nCloud-hosted Postgres\nContracts and User\nMetadata DB\nAdditional views for the deployment viewpoint will flesh out dependencies\namong components, platform or third-party software requirements (for\nreport erratum  \u2022  discuss\nOrganize Views around Stakeholders\u2019 Concerns \u2022 153", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 165", "position": 165, "chunk_type": "semantic", "token_estimate": 316}
{"text": "example, a particular Linux version), areas of risk, costs, or network topology.: The viewpoint itself can consist of both graphical and textual views. In practice, the information in this example view can be captured in a few\nADRs or summarized in an architecture haiku. For the Project Lionheart\nteam, it might be enough to capture the tribal knowledge in the deployment\nscripts themselves. Add some comments to the scripts to capture design\nrationale. While this is OK for the development team, a summary table like\nthe one shown will help with the project hand-off to City IT. Always consider\nthe audience when deciding how to document the architecture. Create Custom Viewpoints\nThere are several established viewpoint sets you may use to guide your\narchitecture description practices. 5 I can personally recommend the Software\nEngineering Institute\u2019s views and beyond approach [BBCG10] as well as Phillipe\nKrutchen\u2019s 4+1 view model [Kru95], Rozanksi\u2019s and Woods\u2019s viewpoints and\nperspectives [RW11] approach and Simon Brown\u2019s C4 model [Bro16]. We often organize viewpoints around quality attributes. Viewpoints can also\nbe constructed to satisfy specific stakeholder needs. Here are a few examples:\n\u2022 A scalability, security, or maintainability viewpoint will demonstrate how\nthe architecture satisfies specific quality attribute scenarios. \u2022 A regulatory viewpoint might provide a particular stakeholder group con-\ncerned with regulatory requirements information needed to perform an\naudit. \u2022 A teachability viewpoint or welcome to the team viewpoint might walk a\nnew teammate through your architecture and development practices with\nthe goal of getting them to commit code on day one. \u2022 A business impact viewpoint might show how different parts of the archi-\ntecture contribute business value. Viewpoints are a must in traditional architecture descriptions. With tribal\nand communal approaches, create viewpoints opportunistically and keep\nthem lightweight. For example, once there are several ADRs in your code\nrepository, create a viewpoint page that connects decision records together\nto provide overarching context. Mountains of documentation are not required\nto organize architecture descriptions for human consumption. Be kind to\nyour readers and they will be delighted. 5.\nhttp://www.iso-architecture.org/42010/afs/frameworks-table.html\nChapter 11. Describe the Architecture \u2022 154\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes", "Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 166", "position": 166, "chunk_type": "semantic", "token_estimate": 353}
{"text": "Discussion: Path not taken\nDoesn\u2019t allow us to schedule computationally\nintensive operations\nOne huge web application\nSeveral teammates know Node.js, promote\nmaintainability with JavaScript in the client\nand server\nJava for Display Business\nservice\nDoesn\u2019t give an expressive enough query\nsyntax required by stakeholders\nIndex RFPs in SQL database,\nsearch service reads the\ndatabase directly\nWhile it seems like a good fit, no expertise\non the team\nMongoDB for data storage\nNot enough familiarity with technology. We\ncan ship sooner putting everything on the\nIsolate services to their own\ncontainers\nsame VM. This decision is not binding. We\ncan change strategies later. Get Your Hands Dirty: Describe the Paths Not Taken for a Project\nThink about a recent project. Write down some of the alternative architecture\nchoices that your team considered and why you rejected each option. Of these\ndecisions, who on your team can describe the rationale for the decision? Here are some things to think about:\n\u2022 Were there any major discussions you had as a team? \u2022 What decisions did your team struggle to make? \u2022 What decisions were made under uncertainty? \u2022 Were there any point of no return decisions that forced you down a partic-\nular path? Project Lionheart: The Story So Far\u2026\nThe team has done a good job of making diagrams and sketching during\ndesign discussions, but pictures of whiteboards are not a replacement for a\ngood old-fashioned architecture description. Since our team is small and co-located, you decide to continue using white-\nboard sketches and system metaphors, but you encourage us to also start\nrecording design decisions as architecture decision records. Metaphors and\nwhiteboard drawings let us thrash quickly and cheaply. Recording ADRs as\nwe make decisions creates a public record that is easier to share among the\nteam and with future developers. Chapter 11. Describe the Architecture \u2022 156\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 168", "position": 168, "chunk_type": "semantic", "token_estimate": 312}
{"text": "You decide to delay creating a formal architecture description. A more official: document should be easier to write later in the life cycle. The ideas it contains\nwill also be less likely to expire before we finish preparing the document since\nmost design decisions will be set in code by then. Our primary audience is\nthe next team after us. When the time comes, you think it will make sense\nto create teachability, deployment, and strategic change (extensibility) view-\npoints. Next Up\nArchitecture descriptions can be great. It\u2019s up to you to design them for\nawesomeness. Think about what your audience needs to know and organize\nviews of the architecture to help people see the whole picture. Describe the\nelements, their responsibilities, and why you chose them for this architecture. Take advantage of the breadth of description methods. Stuffy, big documents\nare not the only way to explain design decisions. The most important thing\nis to communicate effectively and explain your vision for the architecture to\nthe world. Creating an architecture description also creates our first opportunity to test\nthe system\u2019s design, even before we\u2019ve written much code. The ability to test\nthe architecture early is great news since, as you\u2019ll see next, the earlier you\ncan evaluate the architecture, the less pain you\u2019ll have down the road. report erratum  \u2022  discuss\nNext Up \u2022 157", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 169", "position": 169, "chunk_type": "semantic", "token_estimate": 226}
{"text": "CHAPTER 12: Explore\nUnderstand\nMake\nEvaluate\nGive the Architecture a Report Card\nSchool report cards are an important feedback loop for students, parents,\nand teachers. Instead of waiting until the end of the year to learn if you pass\nor fail a subject, a quarterly report card can tell you if you\u2019re on track to get\nthe grades you want and show you where you can improve before it\u2019s too late. Taking the time to evaluate our architecture, like school report cards, can\nhelp us catch problems early so we can stay on track to deliver. Instead of thinking of evaluations as taking away time from programming,\nthink of them as a way to make the time we spend programming even more\npowerful. Evaluations can take as little as an hour, and we can even fold\nthem into existing development processes without anyone being the wiser. In this chapter, you\u2019ll learn how to give the architecture a report card. The\nfeedback from an evaluation can be used to educate the team, create buy-in\nfor design decisions, reduce delivery risks, and improve the architecture. Evaluate to Learn\nArchitecture evaluation is a process by which we learn the extent to which an\narchitecture is fit for purpose. A common fallacy when designing software\narchitectures the belief that we should check the architecture only once, at\nthe end of a design phase. If the whole architecture isn\u2019t correct, then every-\nthing fails and the implementation can\u2019t start. This thinking is wrong, wrong,\nwrong. Architectures are never wholly good or wholly bad. Just like we can\u2019t see the\nentire architecture in a single view, we also can\u2019t evaluate the whole architec-\nture in a single go. It\u2019s possible for a single component to be well designed,\nor one area of the architecture to be well understood while others are filled\nwith risk. Not everything is required to be fully baked to begin implementation. report erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 170", "position": 170, "chunk_type": "semantic", "token_estimate": 323}
{"text": "Ipek says:: Lines Are Also First-Class Citizens! By Ipek Ozkaya, senior member of technical staff at the Software Engineering Institute\nat Carnegie Mellon University\nMy work involves helping organizations and teams improve their systems\u2019 quality\nfrom the perspective of the fitness of its architecture. An unavoidable and obvious\nrequest in these engagements is \u201cShow me your architecture.\u201d Over the years, based\non the responses I get, I\u2019ve developed a personal catalog of misconceptions about\narchitecture and architecting. A printout of all of the sequence diagrams for all the use case scenarios you thought\nof so far is not your architecture! While the collection of all your use cases and\ntheir behavioral traces, such as those you capture in sequence diagrams, are\nuseful and important to your system, they do not provide the right level of\nabstraction to reason about classes of behavior of the system. Code review can not replace an architecture review! The bottom line of any archi-\ntecting effort is to design and implement a system that meets its business and\nstakeholder goals. Working code is the inevitable reality. However, architectural\nconcerns cross-cut many elements in the implemented system. An effective\narchitecture review is bound by those architecturally significant requirements\nand all the elements they touch. Traditional code review practices do not cover\nthis end-to-end perspective. Boxes are not the only architectural elements! In cases when a team does have an\nartifact, often called the Software Architecture Document, and sadly referred to\nas SAD, the document contain depictions of ad hoc box-and-line drawings. This\nis a great start, but discussions are long on the boxes while the lines are com-\npletely forgotten. This is unfortunate because many times the lines carry the\nmost critical aspects of the architectural decisions. Of these three misconceptions, the most significant one is to appreciate the importance\nof lines in software architecture diagrams. Think about it. If you aim to increase\nperformance, then you focus on the frequency and volume of the inter-element com-\nmunications. If you want to increase modifiability, you limit interactions between\nelements. If you want to optimize security, you protect the inter-element relationships. All of these are represented by the lines! Many architectural decisions are carried on those thin, often forgotten lines.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 172", "position": 172, "chunk_type": "semantic", "token_estimate": 373}
{"text": "Availability: Availability\nPerformance\nScalability\nLionheart responds even when the index is unavailable. Results are always returned except during maintenance. Results are visible within 5 seconds under average load. The system can expand to handle 5% annual data \ngrowth for the next 7 years. Quality \nAttribute\nScenario\nRating \n(1 - 4)\nRating Scale\n1 = Does not meet expectations for scenario or unable to evaluate\n2 = Partially satisfies scenario or satisfies the scenario but with unacceptably high \n      risk, technical debt, or cost\n3 = Satisfies scenario with acceptable risk, technical debt, and costs\n4 = Satisfies scenario with little or no risk or technical debt and within budgets\nCriteria\nReviewers  \nscores go here\nDefines how to score the criteria\nUsing the ASRs as a guide, we can select a rubric\u2019s criteria. The best rubrics\nmeet the following conditions:\n1\nImportant and essential The criteria in a rubric defines what we think a good\narchitecture should look like relative to the ASRs. Criteria should not\ninclude ideas that are nice to have or frivolous details not required for the\narchitecture to be fit for purpose. Distinct Criteria within the same rubric should not overlap with one another. Each criterion is one facet of the overall fitness of the design. Ideally each\ncriterion can be assessed and scored independently. Observable and measurable Reviewers must be able to assess and score the\ncriteria in the rubric. The artifacts we prepare for the evaluation will make\ncriteria visible. The activities we perform during the assessment will collect\ndata that lets us measure the criteria. Precise and unambiguous Every reviewer should interpret the criteria in the\nsame way. Quality attribute scenarios should already meet these recommendations and\nalways make for good criteria. 1.\nhttp://www.ucdenver.edu/faculty_staff/faculty/center-for-faculty-development/Documents/T\nutorials/Rubrics/\nindex.htm\nreport erratum  \u2022  discuss\nTest the Design \u2022 163", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 174", "position": 174, "chunk_type": "semantic", "token_estimate": 300}
{"text": "Questions: Rubrics\nAssessment\nKey Components of an Architecture Evaluation\nanswered by\ndetermine the\nInsights\ngenerates\ninform\ndesign, which reviewers use to form opinions about how well the design sat-\nisfies the ASRs. We can generate insights in a number of different ways, such as question-\nnaires, directed explorations, risk elicitations, or code analysis. To help decide\nwhich activities will bear the most fruit, we\u2019ll need to figure out what informa-\ntion is required to answer our rubric. Here are a few examples:\nInsights to help score the criteria\nRubric Criteria\nIdentify risks with risk storming (described on page 301)\nor a general risk elicitation workshop; examine the num-\nber and severity of risks identified\nAmount of Risk\nGenerate open questions with a question-comment-con-\ncern workshop (described on page 298); examine the\nAmount of\nUncertainty\nnumber of open questions and estimate how difficult they\nare to answer\nUse multi-voting, surveys, thumbs up/down, and ratings\nReviewer\nConsensus\nList known components and their current design state;\ndefine a threshold for complete and more work needed\nDesign\nCompleteness\nWalk through quality attribute scenarios (described on\npage 307) and identify sensitivity points, problem areas,\nrisks, and questions\nFit for Problem\nList value adding use cases that cannot be implemented\nwith the current architecture; estimate the cost to prepare\nthe architecture for the use case\nTechnical Debt\nCount the number of defects by architectural component\nand define a threshold for high and low quality\nQuality\nreport erratum  \u2022  discuss\nTest the Design \u2022 165", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 176", "position": 176, "chunk_type": "semantic", "token_estimate": 248}
{"text": "The bulk of the effort in an architecture evaluation is spent generating: insights. Since \ninsights \nare \noften \ngenerated \ncollaboratively \nduring \nworkshops,\nlet\u2019s learn more about how to plan and facilitate an architecture evaluation\nworkshop. Get Your Hands Dirty: Ask Seven Good Questions\nGood evaluators ask the right questions. Learning to ask the right questions\ntakes practice. Write down seven or more questions about the architecture\nof a recent project for which you don\u2019t know the answer. Why seven? We want\nto move past the obvious to find interesting things others might have missed. Here are some things to think about:\n\u2022 Be specific. General questions only provide general insights. The more\nspecific the questions, the more actionable your insights. \u2022 What do you know (or not know) about the relations in the architecture? \u2022 Are there one or more views of module, component and connector, and\nallocation structures? \u2022 What worries you? Playing what if\u2026 is not a fun game, but worries are\noften the seed of real engineering risks. Host an Evaluation Workshop\nThe goal of an architecture evaluation workshop is to gather and analyze the\ndata necessary to assess the architecture. By the end of the workshop, we\nshould be in a position to qualify how well the architecture satisfies desirable\nquality attributes and other ASRs. While there are many ways to run an evaluation workshop, all workshops\nfollow the same basic formula:\n1. Prepare\u2014Find or create required artifacts. Define rubrics. Select methods\nto gather data and invite reviewers. 2. Prime the Reviewers\u2014Share the artifacts and rubrics with reviewers. Explain the goal of the evaluation and answer reviewers\u2019 questions. Reviewers should fully understand the artifacts, rubrics, and purpose of\nthe evaluation before starting the assessment. 3. Assessment\u2014Lead reviewers through activities to explore the artifacts\nand generate insights needed to score the rubric. Activities can be collab-\norative or solo. Chapter 12. Give the Architecture a Report Card \u2022 166\nreport erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 177", "position": 177, "chunk_type": "semantic", "token_estimate": 325}
{"text": "4.: Analyze\u2014Compile the data provided by reviewers. Summarize the results\nand look for trends. 5. Follow-up\u2014Decide on next steps based on what you learned during the\nworkshop. Let\u2019s take a closer look at each of these steps. Prepare for the Evaluation\nAs a part of our preparation, we must decide the goals of the evaluation and\ndevelop whatever artifacts we need to meet those goals. Here are some\nexamples:\nYou might need artifacts like\u2026\nIf you want to evaluate\u2026\nViews relevant to the quality attributes of\ninterest, test results, use cases, quality\nattribute scenarios\nHow well a specific quality\nattribute is promoted\nTechnology or pattern descriptions, experiment\noverviews, experiment results, quality attribute\nscenarios\nTechnology or pattern\noptions\nComponent overview, component estimates,\ntechnical dependencies, team capacity\nLikelihood of hitting cost\nor schedule targets\nOverviews of the current and to-be architec-\nture, list of evolution steps\nDesign evolution path\nAn architecture description, questions that\nshould be answerable by looking at the\ndescription, description quality checklists\nArchitecture description\ncompleteness or correct-\nness\nAbuse cases, misuse cases, threat models, data\nstores, views needed to identify sensitivity\npoints and attack vectors\nSecurity\nQuality attribute scenarios, relevant views,\nrelease checklists, test results\nRelease Readiness\nIn addition to preparing artifacts, we\u2019ll need to create rubrics and decide what\ndata is required to score them. If you plan to run the assessment as a work-\nshop, then prepare the agenda and any materials needed to host the workshop. When selecting reviewers, look for stakeholders and non-stakeholder experts\nwho are detail-oriented and care about the system being designed. Ideal\ncandidates will have relevant domain knowledge or expertise in the technolo-\ngies and patterns used in the architecture. They will also be prepared to offer\nreport erratum  \u2022  discuss\nHost an Evaluation Workshop \u2022 167", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 178", "position": 178, "chunk_type": "semantic", "token_estimate": 295}
{"text": "\u2022 Code review, described on page 289, is not reliable on its own for finding: architectural problems but it can identify misalignment between detailed\ndesign and the architecture. Code review is also an excellent tool for\nkeeping tabs on static structures as they emerge. \u2022 If we\u2019ve recorded ADRs for our system (see Activity 20, Architecture Decision\nRecords, on page 260), then we can replay the design decisions and decide\nwhether those decisions still hold true. Proposed ADRs can be evaluated\nfor fit as well. Choose evaluation activities based on what we need to learn, the time avail-\nable, and the stakeholders\u2019 familiarity with architecture evaluations. A small,\nexperienced evaluation team of only 3\u20134 people can generate interesting\ninsights with a simple question\u2013comment\u2013concern activity in as little as 60\nminutes. A less experienced group might yield better results by walking\nthrough scenarios or design decisions explicitly. During an evaluation workshop, we want to determine whether the architec-\nture passes our criteria, but this shouldn\u2019t be the only outcome from the\nworkshop. We also want to learn how to improve the architecture\u2019s design,\nnot just that it needs improvement. Analyze Data and Reach Conclusions\nNo matter what criteria we use during the evaluation, we want a clear and\ndefinitive conclusion. Explicitly state how well the architecture stood up to\nthe criteria used to evaluate it and make concrete recommendations for how\nthe architecture can be improved. The conclusions from an architecture\nevaluation should not be a simple pass or fail. Whether the architecture is fit for purpose is only half the story. It\u2019s just as\nimportant to understand why the design is fit (or not) for purpose. Great\ndesigns can always be improved. Even a poor design will get some things\nright. Use the insights generated during the evaluation to look for trends and\nopportunities. To decide how the architecture is good, look for risks and open\nquestions. Risks show where the design might allow bad things to happen\nrelative to criteria assessed in the workshop. Open questions shine a light on\ngaps in communication or knowledge about the architecture. report erratum  \u2022  discuss\nHost an Evaluation Workshop \u2022 169", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 180", "position": 180, "chunk_type": "semantic", "token_estimate": 359}
{"text": "On a typical system, we might perform only one or two deep evaluations,: dozens of targeted evaluations, and hundreds of quick checks. Deep evalua-\ntions will always be a major milestone in the system\u2019s life. Targeted evaluations\nmight happen as part of a regular cadence, perhaps as often as every 2 to 4\nweeks. Quick checks occur daily\u2014sometimes multiple times each day\u2014and\nbecome a seamless part of the development workflow. Here are some examples of each type of evaluation from the pyramid:\nExamples\nDescription\nHow many? Evaluation\nType\nArchitecture Trade-off\nAnalysis Method\nConsiders the whole sys-\ntem and interplay of sev-\neral ASRs\n1\u20133\nDeep\nEvaluation\nTargeted\nRisk storming, Ques-\ntion\u2013Comment\u2013Con-\nConsiders a single deci-\nsion, component, or ASR\ndozens\nEvaluation\ncern, Architecture\nBriefing\nCode review, story-\ntelling, whiteboard\njam, sanity check\nConsiders discrete design\ndecisions as they are\nmade, often used to rein-\ncountless\nQuick\nCheck\nforce understanding or\nevaluate details\nJust because we evaluate the architecture continuously, it does not mean we\nare doing a good job of it. We also need to look for a variety of issues during\nour evaluations to ensure we have good coverage. Look for Different Kinds of Issues\nEat the rainbow is something I tell my son to make sure he eats a variety of\nfresh fruits and vegetables. Fresh foods are different colors because they have\nan abundance of different vitamins. Eating different colors ensures he gets\nall the vitamins and minerals a healthy body needs. Variety is as important\nfor healthy architectures as it is for healthy bodies. Most of the methods discussed in this chapter and in Chapter 17, Activities\nto Evaluate Design Options, on page 285 can be adapted to draw out different\nkinds of issues. An issue, in the general sense, is any topic that requires\nadditional investigation or thought. To ensure we have a healthy architecture,\nlook for issues from across the architectural issues rainbow as shown in the\nfigure on page 173. Chapter 12. Give the Architecture a Report Card \u2022 172\nreport erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 183", "position": 183, "chunk_type": "semantic", "token_estimate": 341}
{"text": "CHAPTER 13: Explore\nUnderstand\nMake\nEvaluate\nEmpower the Architects on Your Team\nIt takes a village to develop a modern software system. Technology advances\nsuch as containerization, super cheap computers, and on-demand cloud\ninfrastructure put tremendous power and flexibility directly in developers\u2019\nhands. In response to these new technologies, emerging architecture patterns\nsuch as microservices and function-as-a-service assume developers have a\ngreater awareness of how their decisions influence quality attributes and\nother system properties. On modern software systems, there is little difference between a developer\nand an architect. This isn\u2019t to say that modern software development teams\ndon\u2019t have technical leaders. They do, though today\u2019s software architects don\u2019t\nalways self-identify as architects. Modern software development teams need\na different kind of leader than the traditional, top-down architect. Modern software architects design with their team, not for their team. Today\u2019s\narchitects are equal parts coach, mentor, and technical guru. We started this\nbook by discussing essential architecture and design principles. Throughout\nPart II you learned how to put those principles into practice. In this chapter,\nyou\u2019ll learn how to grow and empower your team as you design awesome\nsoftware architectures together. Promote Architectural Thinking\nTeams who embrace the idea of software architect as a way of thinking instead\nof as a role on the team produce better software. When the majority of the team\nis an architect, the team can explore more design decisions faster. Software\nquality increases since more eyes can critically evaluate design decisions. Doc-\numentation is leaner and conveys more knowledge with less effort. report erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 188", "position": 188, "chunk_type": "semantic", "token_estimate": 260}
{"text": "Pair Design: Pairing is one of the simplest and safest ways to practice design. Start by\nworking one-on-one with teammates while you\u2019re doing design work. If you\nneed to think through a model, invite a teammate to join you for a whiteboard\njam, introduced on page 255. If you have a meeting to talk to stakeholders\nabout quality attributes, take a teammate with you. Ask a teammate to review\na document filled with decisions before you share it with the whole team. Create Scaffolding\nIn education theory, instructional scaffolding refers to support structures\ngiven to individual students to promote and reinforce learning. In school, you\nlikely experienced many scaffolding techniques such as detailed feedback on\na test, handouts, rubrics, and homework templates. We can use similar\ntechniques when teaching our team about architecture. Here are a few\nexamples:\n\u2022 Build templates to support commonly delegated design work. \u2022 Provide constructive criticism during peer reviews. See Activity 31, Code\nReview, on page 289. \u2022 Create a code skeleton for new components. The code skeleton should\nsketch the module patterns planned but still require work to put meat\non the bones. Bonus: Pair with someone to create the skeleton. \u2022 Describe expectations for a particular artifact and share an example of\nwhat better and worse versions of that artifact look like. \u2022 Create checklists for different design mindsets and tasks to help team-\nmates internalize architectural thinking. Introduce Architectural Guide Rails\nAn architectural guide rail restricts design options to ensure detailed design\nstays within the bounds of the desired architecture. Guide rails are a form\nof constraint we choose for ourselves. We can use guide rails to make design\nsimpler (see Limit Design Options with Constraints, on page 49), but we can\nalso use guide rails to create opportunities for safe practice. Imposing guide\nrails decreases the chances that we\u2019ll mess up the architecture. Guide rails come in many forms and varying strengths. A design policy,\ninstructions that describe something to do or avoid doing, is a simple guide\nrail but difficult to enforce. We can temporarily impose design policies when\nChapter 13. Empower the Architects on Your Team \u2022 180\nreport erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 191", "position": 191, "chunk_type": "semantic", "token_estimate": 363}
{"text": "Decide trade-offs among quality attributes. Architects help the team reconcile: trade-offs as design decisions are made and as the architecture evolves\nover time. We use risk to determine how much design work is required\nand where to focus the team\u2019s attention. Manage technical debt. Architects deal with the reality of shipping software\nby identifying technical debt and devising strategies for paying it back. We recognize that technical debt is an unavoidable consequence of success\nand work to manage debt strategically over the life of the software system. Grow the team\u2019s architecture skills. Architects empower their teams to take\nownership of the system by ensuring the team has the knowledge and\nskills required to understand, explore, make, and evaluate an architecture. We prefer to design the architecture with our team instead of designing\nthe architecture for our team. For many teams programming is the easy part. Understanding what the\nproblem is and deciding how the broader system comes together to solve that\nproblem can be tough. The better everyone understands the architecture, the\nmore prepared your team will be to tackle the challenges of software develop-\nment. Designing the system together creates this deeper understanding. Project Lionheart: The Epic Conclusion\nMayor van Damme is pleased. We completed the project only a few weeks\nbehind our original schedule despite the constant stream of changes that\noccurred nearly from the start. We satisfied all the high-priority quality\nattributes, though there were a few hiccups during load testing before the\nofficial public release. Other than that everything went well. The team strongly feels that the foundation provided by our architecture made\nit all possible. Our decision to do less architecture design up front worked\nout fine. The team had prior experience with most of the frameworks and\ntechnologies we used. In the beginning, we focused on the areas of greatest\nrisk and worked to build consensus around the architecture. We had a few\nlucky breaks, such as stumbling upon a major problem with two web services,\nbut we found the problems early enough that we had time to rewrite them\nfrom scratch. The final iterations of the project were stressful but not\nunbearably so. Our last official work on Project Lionheart is to create maintenance documen-\ntation for the city\u2019s IT department. The team is writing a moth ball document,\na user\u2019s guide, and cleaned-up versions of relevant architecture views. The\noriginal architecture driver\u2019s specification maybe only 50 percent accurate at\nChapter 13.", "domains": ["Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 197", "position": 197, "chunk_type": "semantic", "token_estimate": 409}
{"text": "Decide trade-offs among quality attributes. Architects help the team reconcile: The team is writing a moth ball document,\na user\u2019s guide, and cleaned-up versions of relevant architecture views. The\noriginal architecture driver\u2019s specification maybe only 50 percent accurate at\nChapter 13. Empower the Architects on Your Team \u2022 186\nreport erratum  \u2022  discuss", "domains": ["Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 197", "position": 197, "chunk_type": "semantic", "token_estimate": 53}
{"text": "this point. We never created a formal architecture description. We\u2019ll retain: these documents for historical purposes and create a new teachability view-\npoint to walk new developers through the architecture as it exists in the code. The mayor\u2019s office estimates the application we built will save the city nearly\n$1 million in the first year. It feels good to see how our design decisions help\nthe city meet its goals in the real world. Next Up\nArchitects are leaders. This fact does not mean architects choose every element\nand relation in the architecture by themselves. Software architects strengthen\ntheir influence over the design by enabling others. Grow your team\u2019s architec-\nture skills by collaborating with them and by creating safe opportunities for\npractices. This growth is just as important as making good design decisions. The principles and practices you learned in Parts I and II give you most important\nthings you need to know about software architecture design. Master this infor-\nmation and you will be an amazing software architect. What we covered here is\nfar from the whole story. Many excellent resources are available that go deeper\ninto \ndocumentation, \nviewpoints, \npatterns, \nevaluations, \nand \nspecific \ntechnologies. As you grow as an architect, never stop going deeper, learning more. Your next step? Use what you learned to build amazing software! To help get\nyou started on your journey as an architect, Part III includes a collection of\npractical design methods organized around the four design thinking mindsets. I call it the silver toolbox as an homage to Fred Brooks\u2019s seminal No Silver\nBullet [Bro86] essay. No single software engineering practice provides an order of magnitude\nimprovement in productivity, reliability, or simplicity. Although there are no\nsilver bullets, we all have a silver toolbox, a collection of software engineering\nmethods that, when used together, make vast improvements possible. I hope\nyou have already found a few useful tools in this book that you can add to\nyour silver toolbox. The state of software design practice ten years ago looked very different than\nit does today. Ten years from now the way we design software systems will\nbe different still. You\u2019re now a part of the community who will shape the\nfuture. Don\u2019t worry\u2014it\u2019ll be fun. And we\u2019ll build some awesome software along\nthe way. report erratum  \u2022  discuss\nNext Up \u2022 187", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 198", "position": 198, "chunk_type": "semantic", "token_estimate": 390}
{"text": "4.: Briefly discuss why the option was selected. This discussion is often more\nimportant than the option picked. 5. Pick another set of architecturally significant requirements that are in\ntension with one another and play again. Guidelines and Hints\n\u2022 Play this game before things get too difficult. This conversation is easier\nwhen it\u2019s hypothetical than when it\u2019s real. \u2022 Quality attributes that are in tension with one another should be pitted\nagainst one another. \u2022 Use this activity to prioritize influential functional requirements. \u2022 This technique works well as an informal conversation to help get better\nunderstanding of stakeholders\u2019 true need. Example\nHere are a few scenarios one team posed to some stakeholders and how things\nplayed out when stakeholders were asked to choose one thing:\nStakeholder\u2019s Choice\nMatchup\nFaster performance, assuming accuracy met a\nrequired minimum threshold. Faster performance or\ngreater accuracy\nTime-to-market; stakeholders were willing to\naccept greater technical debt to get required\nfeatures by a specific date. Cost vs. time-to-market\nSecurity; this was the number one quality\nattribute and surprisingly beat several other\nimportant quality attributes. Usability vs. security\nAvailability; achieving high availability on this\nparticular system required potentially expensive\nAvailability vs. cost\nredundancy for which stakeholders would\nwillingly pay (up to a point) if required. report erratum  \u2022  discuss\nChoose One Thing \u2022 193", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 202", "position": 202, "chunk_type": "semantic", "token_estimate": 219}
{"text": "Alternatives: Instead of pitting one alternative against another, use trade-off sliders to let\nstakeholders make multiple comparisons. To use this activity, identify 3\u20135\nrelated alternatives. Each item can receive a number 1 \u2013 N, where N is the\nnumber of items in the list. No two items can have the same number. This\nactivity is often presented visually using sliders. Performance\nScalability\nAgility\n1              2             3              4\n1              2             3              4\n1              2             3              4\nReliability\n1              2             3              4\nChapter 14. Activities to Understand the Problem \u2022 194\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 203", "position": 203, "chunk_type": "semantic", "token_estimate": 93}
{"text": "3.: Brainstorm tasks this person does, artifacts this person makes, things\nthis person says, and feelings this person may have. 4. Write each idea on a sticky note and place it in the corresponding quadrant. 5.\nReview the empathy map and highlight insights. Guidelines and Hints\n\u2022 Be specific. Pick a person to empathize with, not a general role. \u2022 Validate the findings from your empathy map with stakeholders. \u2022 Mention quality attributes, risks, or other concerns this person may find\nrelevant. \u2022 Adapt this method for understanding application end users, external\nsystems (for interface design), or for use with proxy stakeholders to\nunderstand quality attributes. \u2022 Use software such as Mural\n1 when participants are distributed. Example\nThere is an example empathy map for a developer stakeholder persona on\npage 197. Alternatives\nThe quadrants of an empathy map can be changed. Another common schema\nis hear, see, do (or say), and think (or feel). Empathy maps are also useful for quality attribute analysis. 2 This approach\nis especially useful when your stakeholders are unable to participate in\nother workshops, such as the Activity 7, Mini-Quality Attribute Workshop,\non page 210. Instead of focusing on what the stakeholders do, say, or think,\nwe focus on how stakeholders react to specific quality attributes. Obviously,\nit\u2019s better to ask stakeholders directly. When they are not available, this is\na good substitute. 1.\nhttps://mural.co/\n2. Thijmen de Gooijer. Quality Requirements on a Shoestring. SATURN 2015.\nhttp://resources.sei.cmu.edu/library/asset-view.cfm?assetID=436426\nChapter 14. Activities to Understand the Problem \u2022 196\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 205", "position": 205, "chunk_type": "semantic", "token_estimate": 256}
{"text": "Activity 6: Quality Attribute Web\nThe quality attribute web is a brainstorming and visualization activity to help\nelicit, categorize, refine, and prioritize stakeholder concerns and raw quality\nattribute scenarios. A quality attribute web captures stakeholders\u2019 concerns. We write each concern on individual sticky notes. The web is drawn as a\nsimple radar chart with relevant quality attributes written around the edge\nlike this:\nAvailability\nReliability\nPerformance\nTestability\nSecurity\nModifiability\nQuality \nAttributes\nWeb \nVisualization\nRaw \nScenarios\nBenefits\n\u2022 Guide stakeholders to think about quality attributes instead of features. \u2022 Provide a visualization that shows how one system is different from\nanother based on highly desirable properties. \u2022 Help stakeholders prioritize quality attribute scenarios before refining\nthem. report erratum  \u2022  discuss\nQuality Attribute Web \u2022 207", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 216", "position": 216, "chunk_type": "semantic", "token_estimate": 124}
{"text": "Example: In this example, quality attributes were brainstormed when the activity began\nand written on a whiteboard. In this particular workshop, you can see that\navailability and reliability tended to be on everyone\u2019s minds slightly more than\nother quality attributes. Of the twenty or so raw scenarios created during the\nhour long activity, only six or seven were prioritized highly by stakeholders. The remainder helped the team gain necessary context about the stakeholders\u2019\nconcerns. report erratum  \u2022  discuss\nQuality Attribute Web \u2022 209", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 218", "position": 218, "chunk_type": "semantic", "token_estimate": 83}
{"text": "Preparation and Materials: \u2022 Before the workshop, prepare a quality attribute taxonomy. The quality\nattribute taxonomy is a set of predefined quality attributes highly relevant\nto the type of system you are building. An example of a quality attribute\ntaxonomy for service-oriented architectures is available from the Software\nEngineering Institute. 6 The taxonomy will be used to facilitate structured\nbrainstorming. \u2022 Prepare graphical quality attribute scenario templates in the style of the\nexamples on page 53. Use these templates to capture scenarios during\nthe workshop. \u2022 If desired, prepare a quality attribute web, shown on page 207, on poster-\nsized paper for use during the workshop. If not using a pre-printed taxon-\nomy web, draw a web at the start of the workshop. \u2022 Sticky notes and markers for participants\nSteps\n1. Present the workshop goals and agenda. 2. Teach participants what they need to know about quality attributes. Describe the quality attribute taxonomy you\u2019ll use during the workshop. 3. Display or draw the quality attribute web so everyone can see it. 4. Brainstorm raw quality attribute scenarios using either structured\nbrainstorming or a questionnaire. Instruct participants to write one idea\nper sticky note and place them directly on the displayed taxonomy web. Read the posted raw scenarios out loud as they are placed on the web. If\nthis prompts participants to think of new scenarios, record and post them\non the web too. 5. After the brainstorming phase, prioritize the quality attributes and raw\nscenarios using dot voting. Participants get 1/3 the number of identified\nraw scenarios. For example, if there are 25 sticky notes on the web,\neveryone gets 8 votes to spend however they please. Participants also get\n2 votes for overall quality attributes. Everyone votes at the same time. 6. Liam O\u2019Brien, Len Bass, and Paulo Merson. Quality Attributes and Service-Oriented\nArchitectures. http://resources.sei.cmu.edu/library/asset-view.cfm?assetid=7405\nreport erratum  \u2022  discuss\nMini-Quality Attribute Workshop \u2022 211", "domains": ["Architectural Patterns and Styles"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 220", "position": 220, "chunk_type": "semantic", "token_estimate": 316}
{"text": "\u2022 Choose an outrageous response measure when your confidence is low: to help find the boundaries around acceptable behavior. 2. Label the scenarios as having a straw man response measure to avoid\npotential future confusion. 3. Validate the scenarios and their response measures with stakeholders,\nsuch as during a stakeholder interview, described on page 202, or mini-\nQAW, described on page 210. Guidelines and Hints\n\u2022 Use a straw man to understand the boundaries around acceptable\nbehavior. \u2022 Responses should be correct for the scenario. The point is to zero in on\nan accurate and reasonable response measure. \u2022 Listen to your stakeholders once you get them talking. When presented\nwith a wrong answer, many stakeholders will react with useful information. \u2022 Keep an eye out for anchoring. Anchoring is a cognitive bias where people\nlet the first information they hear drive their decision making. The straw\nman should be a reasonable estimate or so outrageous it will be rejected\noutright. Exercise caution if your outrageous estimate is accepted. Example\nHere are some examples of response measure straw men created for a cloud-\nbased information system:\nAccepted Response\nMeasure\nStraw Man Response\nMeasure\nResponse\nQuality\nAttribute\n2 iterations\n6 months\nTime required to add\na new algorithm\nChangeability\n4 person-days\n3 person-months\nEffort required to move\nto new cloud provider\nPortability\n3 seconds max\n1 minute\nAverage response time\nunder typical load\nPerformance\n140 requests per\nsecond\n10 requests per\nsecond\nUser load the system\nshould be able to\nhandle\nScalability\nChapter 14. Activities to Understand the Problem \u2022 220\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 229", "position": 229, "chunk_type": "semantic", "token_estimate": 264}
{"text": "Activity 13: Component Responsibility Collaborator Cards\nUse Component Responsibility Cards (CRC cards) to propose architectural\nelements, describe their responsibilities, and show how they come together\nto form a view of the architecture. This exercise is an extension of the Class\nResponsibility Collaborator cards described by Kent Beck and Ward Cunning-\nham in A Laboratory for Teaching Object-Oriented Thinking [BC89] and Scott\nAmbler in The Object Primer: Agile Model-Driven Development with UML 2.0\n[Amb04]. This technique also works well for modeling domain concepts. CRC Card Template\nExample CRC Card\nComponent Name\nNotices Service\nResponsibilities\nCollaborators\nForward notices \nto index (fa\u00e7ade)\nValidate notices\nNotices Index\nCluster \nmanagement \nservice\nUnknown callers\nBenefits\n\u2022 Quickly iterate through design alternatives. \u2022 Create group buy-in and shared understanding of the architecture. \u2022 Create a connection between architecturally significant requirements and\ndesign alternatives. \u2022 Identify potential gaps in the architecture. Activity Timing\n30\u201390 minutes\nParticipants\nThe development team works in small groups of 3\u20135 people. This is also a\ngood exercise for solo work. Chapter 15. Activities to Explore Potential Solutions \u2022 232\nreport erratum  \u2022  discuss", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 240", "position": 240, "chunk_type": "semantic", "token_estimate": 180}
{"text": "Preparation and Materials: \u2022 Index cards and markers for writing components and responsibilities. Host the activity at a large table where all participants can see the cards. \u2022 Before starting this activity, you should know some of your system\u2019s\nfunctional requirements (use cases, stories, or similar) and quality attribute\nscenarios. Steps\n1. Introduce the goals for the exercise and share an example CRC card. 2. Read aloud a functional requirement or quality attribute scenario. 3. Create a card to represent the user or source for a quality attribute sce-\nnario. Write the user or source\u2019s name at the top of the card. Underneath\nwrite the trigger that initiates the use case or scenario. 4. Add a new card to the table to represent the architectural element with\nwhich the trigger card first interacts. Write the name of the element at\nthe top of the card. 5. Evolve the architecture by adding cards for known elements or creating\nnew elements as needed. Write the responsibilities of each element\ndirectly on the cards. Record relationships to other elements on the side\nof each card. During the session, physically arrange cards to visualize\nrelationships. 6. As design alternatives emerge, keep all the cards on the table. Move cards\nto the side in case they are needed later. This lets you see and quickly\nevaluate alternatives. 7. Pick a new functional requirement or quality attribute scenario and walk\nthrough the architecture again. Add or change cards as needed. Alterna-\ntively, change assumptions about scenarios and see how that affects the\narchitecture. 8. Repeat steps 4\u20138 until time runs out or the available functional require-\nments and quality attribute scenarios are addressed. 9. At the end of the session, record the elements and their assigned responsi-\nbilities. Also record key decisions and design principles that emerged during\nthe session. report erratum  \u2022  discuss\nComponent Responsibility Collaborator Cards \u2022 233", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 241", "position": 241, "chunk_type": "semantic", "token_estimate": 314}
{"text": "Training Prep, will prepare the transformed data for the Trainer element. We: also identified a new element, the Training Monitor, but it\u2019s not relevant in\nthis current flow. Again examining the emerging model, the Training Data Repo (top of third\ncolumn) appears to have overloaded responsibilities. Can those responsibilities\nbe reasonably moved to new elements? It turns out we can focus only on the jobs workflow and remove all responsi-\nbilities for writing user data from this element. We moved the old Training\nData Repo card to the side and added a new element with fewer responsibilities\nnamed Jobs Service (top of the third column from the left). Next we will record a snapshot of these models, introduce a new scenario,\nand adjust or create CRC cards to support the new scenario. report erratum  \u2022  discuss\nComponent Responsibility Collaborator Cards \u2022 235", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 243", "position": 243, "chunk_type": "semantic", "token_estimate": 142}
{"text": "Example: Let\u2019s look at the divide-and-conquer path one team took over the course of\nthree one-week explorations. In this case, the team\u2019s general mission was to\ncreate a set of cloud-based microservices, which reused core legacy compo-\nnents where possible. The most important risks and open questions centered\naround the reusability of strategic components and choosing new technologies. Here are the exploration goals for Week 1, with a summary of what was shared\nduring the show-and-tell meeting:\nShow and Tell\nExploration Plan\nGroup\nShowed primary interfaces and\nclasses for the refactoring, which\ndemonstrates the plan is feasible. Refactor plug-in framework\nto see if it\u2019s possible to extract\nfrom legacy codebase. One\nDemo of a Ruby-based client talking\nto a service implemented in Java. Hello world gRPC\n2 web\nservice. Two\nDraft concept map. Feedback from\nthe group indicated that more work\nwas needed. Create a concept map and\ndraft microservice\npartitioning. Three\nBased on what group 1 learned in the first week, they chose to focus on the\nnext risk for the legacy components. Groups 2 and 3 remixed their members. Show and Tell\nExploration Plan\nGroup\nThis turned out to be more work\nthan expected. Described roadblocks\nand remediation plans. Command-line invocation\nof legacy plug-ins. One\nThree demos of different database\ntechnologies with a quick peek at the\ncode. Recommend database\ntechnology. Two\nConcept map and microservice\noverview. Revise concept map, draft\nmicroservice partitioning. Three\n2.\nhttps://www.grpc.io/\nChapter 15. Activities to Explore Potential Solutions \u2022 242\nreport erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 250", "position": 250, "chunk_type": "semantic", "token_estimate": 251}
{"text": "By the third iteration the groups were starting to get a good groove for the: rapid, time-boxed nature of the work. The demos in Week 3 were tightly\nfocused. Show and Tell\nExploration Plan\nGroup\nDemo of a single plug-in run-\nning independently of legacy\nsystem, list of next steps. Command-line invocation of legacy\nplug-ins. This is the same goal as\nlast week with the plan updated to\nreflect specific problem areas. One\nPartially working demo of\nEureka with two simple\nmicroservices. Microservice discovery examples\nusing Eureka. 3\nTwo\nDraft gRPC .proto files. Draft APIs for the first services. Three\nBy the end of Week 3 the team had reduced risks enough to begin implemen-\ntation and detailed design for specific microservices while they worked to\nrefine the architecture as a whole. 3.\nhttps://github.com/Netflix/eureka/\nreport erratum  \u2022  discuss\nDivide and Conquer \u2022 243", "domains": ["Architectural Patterns and Styles", "Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 251", "position": 251, "chunk_type": "semantic", "token_estimate": 143}
{"text": "Activity Timing: An initial event map can be created in 30\u201345 minutes. Workshops should\nrun at least 90 minutes to allow for setup and reflection. It\u2019s often useful to\nallow additional time to try different domain models. Participants\nSubject matter experts knowledgeable in the problem domain must participate. A few members of the development team should also participate to take\nadvantage of the learning opportunity. If knowledgeable subject matter experts\nare not available, the workshop may not have great outcomes. This workshop can be run with as few as 2\u20133 participants and as many as a\ndozen or more, depending on the workspace and facilitator\u2019s experience. Preparation and Materials\n\u2022 Large roll of paper, tape, lots of sticky notes (at least six colors), markers. \u2022 To prepare the room, tape the paper to the wall to create a large workspace. Remove any impediments such as tables or chairs that might prevent\nparticipants from accessing the paper. Steps\n1. Before the workshop starts, verify that you have the right mix of partici-\npants from both technical and business domains. If you suspect the\ncombination of stakeholders is not right, it\u2019s better to postpone the\nworkshop. 2. Start the workshop by sharing the goals for the activity. You might say\nsomething like, our goal in this workshop is to create an event map for the\nHamster Production Line system. 3. Introduce participants to the idea of domain events and describe the dif-\nferent kinds of events to be mapped. Assign each event type a color. Domain event (orange) An event relevant to domain experts that happened\nin the past. Domain events might be a step in a business process,\nscheduled, or happen as a result of another event. User command (blue) An action initiated by a user. Record who the user\nis on a yellow sticky note next to the command. report erratum  \u2022  discuss\nEvent Storming \u2022 245", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 253", "position": 253, "chunk_type": "semantic", "token_estimate": 317}
{"text": "External system event (purple) Events that originate from an external: system. Record the system on a yellow sticky note next to the event. Passage of time (green) Indicate how much time has passed when time\nis relevant to the flow of events. Consequences (white) An observable change in the business process\nthat directly resulted from an event. Questions, comments, concerns (pink) Discussion points that a partic-\nipant wants to raise. Capturing issues and deliberation on a sticky\nnote instead of talking about it encourages participants to continue\nmoving forward, avoids analysis paralysis, and creates a visual indi-\ncator of potential trouble spots. Help participants to use this informa-\ntion to address issues during the workshop. 4. Set expectations for participation. Explain that all participants are\nexpected to contribute and encourage participants to favor creating a\nsticky note over discussing whether or not a sticky note is required. 5. Make sure everyone has a marker in hand. Have everyone write down an\nevent. The facilitator should place the first sticky note on the paper. Placing the first sticky note signals that it is OK to get started. Once the\nfirst event is on the wall, the activity has officially begun. 6. Participants place events in the order they occur from left to right. As the\ngroup discovers new events, move sticky notes around to make room. Add subflows underneath the initial event with more detail. 7. As the activity progresses, the facilitator should review events and look\nfor issues. An event might take place in the future instead of the past or\nbe abstract instead of concrete. As you find events that need help, rotate\nthem a quarter turn so they look like a diamond on the map. 8. Encourage all participants to work at the same time to build the map. Help participants find areas where they can contribute. Point out hot\nspots or areas they should review. A smooth-running workshop will appear\nslightly chaotic to an outside observer. 9. After 15\u201320 minutes or if you notice participants winding down, encourage\nthe group to review the map and revise events as necessary. 10. Once time has expired, discuss the map as a group. Are there concepts\nthat seem awkward or still in need of refinement? Are there gaps or major\nquestions in the map? Chapter 15. Activities to Explore Potential Solutions \u2022 246\nreport erratum  \u2022  discuss", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 254", "position": 254, "chunk_type": "semantic", "token_estimate": 397}
{"text": "Alternatives: The general organization of the workshop is similar in nature to User Story\nMapping [Pat14]. Event storming can be modified to include different experts and emphasize\ndifferent modeling outcomes. Here are some ideas from Brandolini:\n\u2022 Focus on big picture ideas and include many stakeholders when starting\na new system or project. \u2022 Dig into specifics required to implement event sourcing\n4 or CQRS\n5 systems\nby focusing more narrowly on a specific topic area. \u2022 Include user experience experts and overlay a user\u2019s journey onto the\nevent map. \u2022 Use as the basis for evaluation to identify areas of the system that may\nneed to be expanded or can be refactored. \u2022 Run a workshop with new teammates and stakeholders to teach them\nabout the problem domain. 4.\nhttps://martinfowler.com/eaaDev/EventSourcing.html\n5.\nhttps://martinfowler.com/bliki/CQRS.html\nChapter 15. Activities to Explore Potential Solutions \u2022 248\nreport erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 256", "position": 256, "chunk_type": "semantic", "token_estimate": 146}
{"text": "4.: Groups create a common vision for the architecture within the scope of\nthe agreed goals. 5. When time expires, each group shares their poster. Give each group 3\nminutes to present their poster. Questions and comments should be held\nuntil after the presentation. 6. Allow 3\u20135 minutes to critique the poster after each presentation. 7. Once all posters have been shared, briefly discuss any trends or general\nobservations about the posters together. 8. Initiate a round of dot voting. Given each participant 1 vote for best\noverall poster and 3 votes for interesting design ideas that appear on any\nposter. Discuss the outcomes of the voting. Guidelines and Hints\n\u2022 Remind participants to include a legend and think about which views of\nthe architecture they are sketching\u2014module, component and connector,\nor allocation. \u2022 It\u2019s OK to sketch more than just structures. Sketches of domain models,\nsequence diagrams, or state diagrams can all be useful. \u2022 Encourage participants to jot down open questions or risks that arise\nduring their group discussions. \u2022 Monitor participant progress closely and adjust time up or down to ensure\ngroups are creating effective posters. \u2022 During the critiques, remind participants to focus on facts and avoid \u201cI\nlike\u2026\u201d kinds of remarks. \u2022 Record video or audio of the poster presentations for later review. \u2022 Keep the posters and hang them in your workspace. Chapter 15. Activities to Explore Potential Solutions \u2022 250\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 258", "position": 258, "chunk_type": "semantic", "token_estimate": 241}
{"text": "Activity 20: Architecture Decision Records\nCapture architecture design decisions as they are made using a lightweight,\ntext-based template. Lightweight decision records are a developer-friendly\napproach to a time-tested architecture practice. Documenting design decisions\nmakes it easier to share and analyze them. Retaining a history of decisions\nprovides context for the current architecture relative to its evolution. Benefits\n\u2022 Make recording design decisions a team responsibility. \u2022 Keep key decisions close to the code by storing them in the code repository. \u2022 Combine with other artifacts to create a holistic description strategy. \u2022 Capture history to gain perspective on the evolution of the design. \u2022 Involve the whole team in the design process. \u2022 Train teammates in architectural thinking by providing ADR templates. \u2022 Enable peer review of design decisions using standard development tools\nand an existing peer review workflow. Description\nWrite down key architecture design decisions along with the context and\nimplications of the decision. Each decision record should describe a single\ndecision. What makes a decision architectural and not simply detailed design\nvaries from system to system and team to team. Here are some ideas that\nmay indicate you are dealing with an architectural decision. \u2022 The decision directly affects another component or team. \u2022 The decision changes how the system influences one or more quality\nattributes, for better or for worse. \u2022 The decision was precipitated by a business or technical constraint. \u2022 The decision has a far-reaching, significant impact such as a framework\nor technology choice. Chapter 16. Activities to Make the Design Tangible \u2022 260\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 267", "position": 267, "chunk_type": "semantic", "token_estimate": 263}
{"text": "\u2022 Establish a common vocabulary for architectural concepts so everyone: speaks the same language. \u2022 Set aside time to explore design options before starting. \u2022 Treat the architecture haiku as a living document. \u2022 Use the architecture haiku as an outline or executive summary for a\nlonger architecture description. \u2022 The architecture haiku is not a replacement for other design artifacts. Example\nHere\u2019s a partial architecture haiku for Project Lionheart. There is also a tem-\nplate available on my website to help get you started. 6\nProject Lionheart is a publicly available web application that will help the\nSpringfield Office of Management and Budget manage the city\u2019s requests\nfor proposals (RFPs) and local businesses to find RFPs of interest. Key Decisions and Rationale\nBusiness Goals\n\u2022 Node.js for web app\u2014team has\nexperience\n\u2022 Reduce procurement costs\nby 30%\n\u2022\n\u2022\nImprove city engagement with\nlocal businesses\nMySQL database\u2014free, open\nsource\n\u2022\n\u2022\nApache Solr\u2014free, open source\nCut the time required to publish\na new RFP in half\n\u2022 SOA with REST\u2014decouple com-\nponents, team interested in\nTop Quality Attributes\nexperimenting with emerging\ntech trends\nSecurity > Availability > Performance\nArchitecture Patterns Used\n\u2022 Java for web services\u2014open\nsource, low-risk, great tool\nsupport\nService-Oriented Architecture (SOA),\nLayered web application, REST APIs\nfor web services\n6.\nhttp://neverletdown.net/2015/03/architecture-haiku.html\nChapter 16. Activities to Make the Design Tangible \u2022 264\nreport erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 271", "position": 271, "chunk_type": "semantic", "token_estimate": 229}
{"text": "\u2022 Take advantage of design artifacts from third-party sources. For example,: if a pattern you are using is explained in a framework\u2019s documentation\nor a blog post on the web, use it instead of creating your own document. \u2022 Include links to reference material that defines important concepts in the\narchitecture as well as design artifacts. Example\nHere is an excerpt of a Greatest Hits Reading List from one team\u2019s code\nrepository:\nWIRE/FIRE/PIRE/TIRE Project: Greatest Hits Reading List\n   \n\uf0b7 \n Context Diagram - Get a feel for the lay of the land\n\uf0b7 \n Inception Deck - Created in the first weeks of the project. Much of \nwhat's here has changed but it tells why we're building this system. \uf0b7 \n Original system use cases - Largely abandoned but still useful context, \nskim only. \uf0b7 \n ASR Workbook - Mostly up to date. The top quality attributes still apply. \uf0b7 \n Checkpoint #2 Presentation - Created in March. Includes the most \nrecent architecture diagrams that were shared with all stakeholders. \uf0b7 \n Search and Train sequence diagrams - Shows how different \ncomponents interact during specific use cases. Useful for availability \nanalysis. \uf0b7 \n Layers Overview - Shows how the code is organized\nChapter 16. Activities to Make the Design Tangible \u2022 268\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 275", "position": 275, "chunk_type": "semantic", "token_estimate": 209}
{"text": "Activity 25: Modular Decomposition Diagram\nShow how the architecture is composed of varying abstractions that come\ntogether to create a coherent whole. A modular decomposition diagram is a\nsimple tree diagram that shows how varying granularities of abstraction are\nrelated to one another. The word decomposition in this context means to\nbreak into smaller pieces, not to rot. Modular decomposition is a general technique that can be used in many cir-\ncumstances\u2014from code package organization to organization charts to work\nbreakdown structures used in project planning. Benefits\n\u2022 Uniquely name concepts at different granularities of abstraction. \u2022 Map refinements in the architecture. \u2022 Use to analyze organizational alignment with the system\u2019s composition. \u2022 Reduce complexity without losing traceability to related elements. \u2022 Promote system thinking within the architecture. Description\nModular decomposition diagrams are nearly always drawn as a tree. The root\nnode of the tree is the system. Each level of the tree breaks down (decomposes)\na specific module to show finer-grained details. In a large system, the bottom-\nmost leaf nodes might represent a module implemented by a single team. In\na smaller system, the bottommost leaf nodes might represent a specific\npackage or class in the architecture. Each level of the tree is an opportunity to group architectural concepts and\nshow how they are related to ideas that are both bigger picture and also more\ndetailed. Guidelines and Hints\n\u2022 Use the diagram to help reason about quality attributes such as agility,\nmaintainability, time-to-market, costs, buildability, and deployability. \u2022 Use software to make drawing a tree simpler. Chapter 16. Activities to Make the Design Tangible \u2022 272\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 279", "position": 279, "chunk_type": "semantic", "token_estimate": 273}
{"text": "Analysis: Framework\nCommand \nLine\nGraphical\nMetrics\nMessage \nPackages", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 280", "position": 280, "chunk_type": "semantic", "token_estimate": 8}
{"text": "Plugins: Widgets\nUpdater\nHere is the same decomposition drawn as a tree map with some additional\ninformation. In this map, size represents the amount of relative technical\ndebt in the module. report erratum  \u2022  discuss\nModular Decomposition Diagram \u2022 273", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 280", "position": 280, "chunk_type": "semantic", "token_estimate": 40}
{"text": "Example: Here is an example of paths not taken for a hybrid cloud project in which an\non-premise, shrink-wrapped software system was required to integrate with\na rapidly evolving cloud platform on a continuous delivery schedule. The\nshrink-wrapped software was released quarterly. The scope of the decision\ncentered on the integration between the two platforms. Why the Path Was Rejected\nPath Not Taken\nHeavy maintenance costs, benefits in features and\nquality attributes not required for MVP release, costs\noutweigh benefits\nCreate a cloud-based\n\u201cservices adapter\u201d\nto buffer against\nchanges in third-\nparty services\nExtra steps to deployment inhibits adoption, concern\nthat unmodified defaults could introduces security\nRelease adapter as\nopen source, have\nrisks, concerns about training customers and con-\nsultants, does not reduce maintenance costs\ncustomers load it\nthemselves\nThe client library will likely always be out of date\n(services ship continuously, shrink-wrap software\nOffer a client-side\nlibrary\nships once per quarter). Customers must learn both\ncloud services and how to use the client library. Documentation costs are highest. There is high risk\nthe software will not be ready by the deadline. Does not improve the user experience, customers\nrequire guidance with emerging patterns and\nparadigms\nNo new support for\nweb services integra-\ntion in the client\nsoftware\nThe final decision was to release sample code for high-priority use cases in\nthe documentation. The team was not responsible for maintaining the sample\ncode. Customers were on their own if they chose to use or extend the sample\ncode. Stakeholders felt this struck the right balance between costs and value. This minimally viable release allowed the product manager to collect data on\nthe usefulness of the integration before investing further into the architecture. report erratum  \u2022  discuss\nPaths Not Taken \u2022 275", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 282", "position": 282, "chunk_type": "semantic", "token_estimate": 291}
{"text": "Activity 27: Prototype to Learn or Decide\nDevelop or use software so you can test a hypothesis, learn information\nneeded to make a design decision, prove a quality attribute, or gain experience. Sometimes the only way to learn what you need to know is to do it yourself. This adage is especially true of technology and frameworks. We prototype to learn when we need to figure out how to do something or how\nsomething works. We prototype to decide when we need to gather information\nthat will help us choose between multiple options. Building a prototype to decide is like running an experiment. The technology\nor pattern under investigation is hypothesized to solve a specific design\nproblem. The purpose of the prototype is to test the hypothesis. Benefits\n\u2022 Gather information through firsthand experience. \u2022 Generate data to use in decision making. \u2022 Allow stakeholders to experience a part of the system. \u2022 Learn how something works quickly and inexpensively. Description\nThe difference between a useless prototype and overdoing it is a razor-thin\nline. To increase your chances of success when prototyping, you need a plan. Let\u2019s look at what is involved in creating a prototyping plan. 1. Define the learning objectives and scope for the prototype. What questions\nwill this prototype help you answer? 2. Decide on the prototype\u2019s budget and establish a delivery time line. When\nwill you pull the plug on the prototype? How much are you willing to\nspend to meet the learning objectives? Limit costs and time as much as\npossible. 3. Decide how the outcomes will be delivered. Who is the audience for the\nprototype and how will you share it? For example, will you share a demo,\nwhitepaper, presentation, or something else? Chapter 16. Activities to Make the Design Tangible \u2022 276\nreport erratum  \u2022  discuss", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 283", "position": 283, "chunk_type": "semantic", "token_estimate": 303}
{"text": "The goal is always to implement the prototype as quickly and cheaply as: possible. As the prototype comes together, review the implementation relative\nto the plan. Once you\u2019ve achieved the objectives, the prototype is complete\nand it\u2019s time to share the outcomes. After the prototype is complete, perform the minimum clean-up necessary\nso it can be used again if required. Archive code and instructions for future\nreference. Guidelines and Hints\n\u2022 Look for ways to meet your learning objectives without writing software. \u2022 Decide up front whether the prototype is evolutionary or throw-away. \u2022 Keep tabs on the prototype implementers. Prototyping often requires that\nyou trade quality for speed of delivery and completeness. This is a chal-\nlenge for many developers who are proud of their craft. \u2022 Time-box the prototype aggressively, but allow sufficient time to complete\nthe work. \u2022 Sketch out a high-level design for the prototype with the implementers\nbefore starting development. Example\nHere\u2019s an example of prototyping to learn. The team needed to understand\nthe performance limitations of specific Apache Solr APIs. To learn this, a\nsingle developer over the course of one week developed a simple test driver\nusing Apache JMeter,\n8 ran several load tests, collected data, and wrote a two-\npage report summarizing the findings. Using Apache JMeter let the team\nquickly gather data with minimal effort. Here\u2019s an example of prototyping to choose. The team needed to select a\nserver-side web framework. To help them decide, the team implemented a\nsimple blog application using the top two frameworks. The activity was time-\nboxed to two days. At the end of the second day, the team discussed pros and\ncons of each framework based on their experiences and chose a framework. 8.\nhttp://jmeter.apache.org/\nreport erratum  \u2022  discuss\nPrototype to Learn or Decide \u2022 277", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 284", "position": 284, "chunk_type": "semantic", "token_estimate": 301}
{"text": "Guidelines and Hints: \u2022 Reason about distributed systems, microservices, object communication,\nand other dynamic structures. \u2022 Informal notations are fine as long as you are consistent. \u2022 A closed arrow with a solid line indicates a synchronous request message. \u2022 An open arrow with a solid line indicates an asynchronous request message. \u2022 An arrow with a dotted line indicates a response message. \u2022 Use a tool that renders text-based notations so you can store the diagrams\nwith your code. Example\nHere is a sequence diagram for a set of microservices responsible for saving\nan item to a shopping cart, generated using js-sequence-diagrams. 9\nSave an Item to a Shopping Cart\nFront-End Gatekeeper\nFront-End Gatekeeper\nSessions\nSessions\nShopping Cart REST\nShopping Cart REST\nShopping Cart Store\nShopping Cart Store\nDatabase\nDatabase\nVerify Session\nSession ID\nPOST /sessions/{session_id}/items/{item_id}\nSaveItem(session_id,\nitem_id)\nAdd Item\nAdded! OK, echo cart\nOK, cart as JSON\n9.\nhttps://github.com/bramp/js-sequence-diagrams\nreport erratum  \u2022  discuss\nSequence Diagram \u2022 279", "domains": ["Architectural Patterns and Styles", "Design Principles"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 286", "position": 286, "chunk_type": "semantic", "token_estimate": 159}
{"text": "This is the text notation used to generate the diagram:: Title: Save an Item to a Shopping Cart\nFront End Gatekeeper -> Sessions: Verify Session\nSessions --> Front End Gatekeeper: Session ID\nFront End Gatekeeper -> Shopping Cart REST:\nPOST /sessions/{session_id}/items/{item_id}\nShopping Cart REST -> Shopping Cart Store:\nSaveItem(session_id,\\n item_id)\nShopping Cart Store -> Database: Add Item\nDatabase --> Shopping Cart Store: Added! Shopping Cart Store --> Shopping Cart REST: OK, echo cart\nShopping Cart REST --> Front End Gatekeeper: OK, cart as JSON\nWith the sequence diagram drawn, it\u2019s easy to see a potential flaw in the\ndesign. The first step of verifying the session creates an opportunity to validate\na session that could be closed\u2014for example, if the user checks out before the\nitem is added. This API call by the Gatekeeper is redundant at best. More\nlikely the diagram has exposed an inappropriate assumption about the state\nof the user\u2019s session when saving an item in the Shopping Cart Store service. Chapter 16. Activities to Make the Design Tangible \u2022 280\nreport erratum  \u2022  discuss", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 287", "position": 287, "chunk_type": "semantic", "token_estimate": 178}
{"text": "\u2022 If a common reference point does not exist, then create a shared experience.: \u2022 Pop culture and food are common points of reference for many metaphors. \u2022 Common architecture patterns serve the same purpose as system\nmetaphors and can be used in the same way. Example\nIn Project Lionheart we plan to build a simple data crawler, which pulls data\nfrom the city\u2019s contracts database, normalizes the data, and pushes it into a\nsearch index. To do this efficiently, we\u2019ll need a multithreaded crawler. But\nthere\u2019s a catch. If the crawler is too aggressive, we might crash the database\nand disrupt city services. If the crawler is too slow, we might not index the\ndata fast enough to satisfy reliability quality attributes. To help us think through and share the design, we created the following\nsystem metaphor. The musical Newsies\n10 tells the story of the New York City Newsboy Strike of\n1899. In the movie (and history), the newsboys (newsies) purchase newspapers\nfrom a paper distribution center every morning and then resell the newspapers\nto the people of New York. Our crawler threads are just like the newsies. Each\nthread visits a distribution center, requests some rows to fetch from the\ndatabase, and receives a block of rows to fetch and index. Any rows not fetched\nare forgotten. We can always sell more papes\u2014pick up missing rows\u2014\ntomorrow. Let\u2019s walk through our checklist to see if this is a good metaphor:\n\u2022 Represent a single view. In this metaphor, we\u2019re considering a single view\nof a single component, specifically the threading model in the crawler. Check. \u2022 Deal with only one type of structure. We\u2019re only dealing with C&C struc-\ntures, so there are no mixed models in play. Check. \u2022 Give clear guidance concerning design decisions. Newsies sieze the day\nand also fetch data to index while the distribution center provides a set of\nrows from the database. Only one newsie can have a database row at a\ntime and the newsies are fully responsible for the rows once received from\nthe distribution center. Leftover papers\u2014database rows not crawled\u2014are\nskipped. Check. 10. http://www.imdb.com/title/tt0104990/\nChapter 16. Activities to Make the Design Tangible \u2022 282\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 289", "position": 289, "chunk_type": "semantic", "token_estimate": 370}
{"text": "\u2022 Shed light on system properties. This metaphor is trying to describe how: we\u2019ll address performance. We can control our aggressiveness by control-\nling the number of newsies working at the same time. Check. \u2022 Draw on shared experiences. The movie is a piece of 1990s cinematic gold\nstarring a young Christian Bale. If teammates haven\u2019t seen it, create a\nshared experience by ordering pizzas and having a movie night, or at least\nwatching YouTube videos. Check and team building bonus! report erratum  \u2022  discuss\nSystem Metaphor \u2022 283", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 290", "position": 290, "chunk_type": "semantic", "token_estimate": 89}
{"text": "Example: Here is one possible outline for architecture briefings. The specific outline\nmay vary depending on the type of systems you build. Elevator pitch: what overall business problem are you solving? Overview and context\nTop quality attributes\nRelevant views\nKey design decisions with rationale\nAlternatives considered\nCurrent status: quality, work remaining, next steps\nCosts\nTop risks and other concerns\nFuture plans\nHalloway included an example briefing and an alternative outline in a talk\navailable in his GitHub repository. 3\n3.\nhttps://github.com/stuarthalloway/presentations/wiki/Architectural-Briefings\nChapter 17. Activities to Evaluate Design Options \u2022 288\nreport erratum  \u2022  discuss", "domains": ["Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 294", "position": 294, "chunk_type": "semantic", "token_estimate": 94}
{"text": "\u2022 Code review is not a replacement for design evaluations. Use reviews to: monitor architectural drift and learn how you can better serve your team\nas an architect. Example\nCode review checklists improve consistency and show teammates what to\nlook for during a review. In addition to looking at detailed design concerns,\nhere are some architectural ideas you should look for when reviewing code:\n\u2022 Correctness\u2014Are the changes consistent with the established patterns\nin the architecture? Are there pattern violations? Is there an opportunity\nto use an architecture pattern or refactor the code so that an intended\npattern becomes more obvious? \u2022 Consistency\u2014Look at the naming. Do the concepts at play make sense? Do any names surprise you? Are you able to form a mental model in your\nhead of where the changes fit? How well does this jive with your expecta-\ntions of what these changes would entail? \u2022 Testability\u2014Are there clean unit tests included with the changes? Can\nthe tests be run with every build? Is there an opportunity for the tests to\nbe flaky or inconsistent? Are common patterns such as inversion of control\nused appropriately and correctly? \u2022 Modifiability/maintainability\u2014Are there hard-coded constants or values\nthat should be injected via configuration? What assumptions are baked\ninto the code under review about what will change in the system? Can\nthe code be made more flexible? Were any new dependencies introduced? Why were they introduced? Was it right to include them? \u2022 Reliability\u2014Are exceptions handled consistently? Are there opportunities\nfor errors to propagate in unexpected or unhandled ways? Does the system\nattempt to retry when appropriate? Does the system fail fast when no\nrecovery action can be attempted? How is error prevention (including from\nhuman mistakes) built into the design? \u2022 Scalability\u2014Does the code introduce potential for rampant memory use? Are the algorithms at least nominally efficient? Are thread-safe data\nstructures used when appropriate? report erratum  \u2022  discuss\nCode Review \u2022 291", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 297", "position": 297, "chunk_type": "semantic", "token_estimate": 323}
{"text": "Steps: 1. Identify evaluation factors. Collaborate with stakeholders to agree on the\nfactors used to compare and contrast alternatives. 2. Establish a rubric. Collaborate with stakeholders to decide how design\nalternatives will be scored. For guidance on defining a rubric, see Define\na Design Rubric, on page 162. 3. Do the analysis and fill in the matrix. 4. Share the matrix with stakeholders. Verify the analysis and discuss your\nrecommended decision. Guidelines and Hints\n\u2022 Use qualitative comparisons unless you performed quantitative analysis. For example, performance or availability can only be quantified if you ran\ntests. \u2022 Consider no more than seven factors in the same matrix. \u2022 Compare up to five design options in the same matrix. Use multiple\nmatrices with a larger number of options. \u2022 Take good notes when filling in the matrix. The analysis is as important\nas the results and can provide design rationale for decisions. report erratum  \u2022  discuss\nDecision Matrix \u2022 293", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 299", "position": 299, "chunk_type": "semantic", "token_estimate": 159}
{"text": "Example: Here is a sample decision matrix. Additional examples are shown in Create\na Decision Matrix, on page 71. Project Lionheart Decision Matrix\nAvailability \n(Database unavailable)\nAvailability\n(Uptime requirements)\nPerformance\n(5-second response time)\nSecurity\nScalability\n(5% annual growth)\n3-Tier\nPublish - \nSubscribe\nService \nOriented\n+\n+\nMaintainability\n(Team knowledge)\nBuildability\n(Implementation risks)\n++\n+\n+\n+\n+\n++\nPromotes\nStrongly Promotes\nStrongly Inhibits\nInhibits\nNeutral\nLegend\nChapter 17. Activities to Evaluate Design Options \u2022 294\nreport erratum  \u2022  discuss", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 300", "position": 300, "chunk_type": "semantic", "token_estimate": 79}
{"text": "Steps: 1. Define the goals of the analysis. What question are you trying to answer? Use Activity 3, Goal-Question-Metric (GQM) Workshop, on page 199 to\nidentify candidate metrics and the data required to compute those metrics. 2. Decide how to generate data and design tests to drive the system. 3. Add the required instrumentation and logging to the software system. Verify\nthat your changes work before attempting meaningful analysis. You don\u2019t\nwant to spend a week running tests only to learn that your logging failed! 4. Implement and execute tests, or allow the software system to be used as\nit normally would. 5. Once data has been collected, perform the analysis. Compute metrics and\nanswer the questions established in step 1. If you are unable to answer\nquestions, then make adjustments and try again. 6. Prepare and share findings with relevant stakeholders. Guidelines and Hints\n\u2022 Observability is a quality attribute and must be designed into the archi-\ntecture. Instrumentation can be added late, even after the system is in\nthe wild, as long as you\u2019ve designed the ability to produce and collect\nsystem events into the architecture. \u2022 As you answer questions about the software system, think about how the\ndata can be used in automated analysis. Consider adding your metrics\nto system dashboards and alerting systems. \u2022 In theory, any runtime property of the system can be observed, including\nsecurity, performance, availability, and reliability, among others. Example\nSome patterns such as event sourcing publish-subscribe (described on page\n88) have observability baked in. Observability is a must-have for all modern\ndistributed systems, especially microservices. Chapter 17. Activities to Evaluate Design Options \u2022 296\nreport erratum  \u2022  discuss", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 302", "position": 302, "chunk_type": "semantic", "token_estimate": 278}
{"text": "Netflix has done extensive work in this area and made much of their work: available as open source. 4 One example is the Hystrix Dashboard, which\nallows developers to observe metrics produced by the Hystrix fault tolerance\nlibrary for the JVM. 5 Another example is the Simian Army, a suite of tools\nused to stimulate a service-oriented system in various ways. 6\nIn the simplest case, you can use any logging platform to record observed\ninformation. Take a look at logging platforms such as LogStash,\n7 Splunk,\n8 or\nGraylog\n9 for storing, visualizing, and analyzing system events. Keep in mind\nthat though these tools are powerful, their effectiveness depends heavily on\nhow you\u2019ve instrumented the system. 4.\nhttps://netflix.github.io/\n5.\nhttps://github.com/Netflix/Hystrix\n6.\nhttps://github.com/Netflix/SimianArmy\n7.\nhttps://www.elastic.co/products/logstash\n8.\nhttps://www.splunk.com/\n9.\nhttps://www.graylog.org\nreport erratum  \u2022  discuss\nObserve Behavior \u2022 297", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 303", "position": 303, "chunk_type": "semantic", "token_estimate": 137}
{"text": "Guidelines and Hints: \u2022 Avoid turning the review into a witch hunt. The whole point is to find\npotential problems while they are still cheap to fix\u2014on paper. Finding\nissues is a good thing. \u2022 To keep the meeting moving, the time spent on each scenario should be\ntime boxed. \u2022 Avoid problem solving during the review. The purpose of this activity is\nto surface issues, not solve them. \u2022 The reader and recorder roles can be combined but should be separate\nfrom the architect role. \u2022 Rotate roles to help build teammates\u2019 skills. \u2022 Write or project the current the quality attribute scenario so reviewers\ncan see it during the walkthrough. If this is not practical, distribute a\npacket with quality attribute scenarios. \u2022 Record new quality attribute scenarios raised during the walkthrough. Example\nLet\u2019s walk through an availability scenario from Project Lionheart. A user\u2019s\nsearches for open RFPs and receives a list of available RFPs 99 percent of the\ntime on average over the course of the year. To walk through an availability\nscenario we\u2019ll need to focus on specific conditions. Recall that Project Lionheart\nconsists of a small handful of web services, a few databases, and a search\nindex. Here\u2019s a specific quality attribute scenario:\nRFP listings are \nreturned\nSearch Service\nUser\nFailed Cloud Region\nSearches for \nan RFP\nIn 2 seconds or less\nRaw Scenario:  RFPs can be searched during \ncloud region outage. Quality Attribute: \nAvailability\nreport erratum  \u2022  discuss\nScenario Walkthrough \u2022 309", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 315", "position": 315, "chunk_type": "semantic", "token_estimate": 248}
{"text": "The City of Springfield\u2019s IT Department has decided to host Project Lionheart: services using a popular cloud provider. Services and processes are hosted\nin Docker containers in two different cloud regions. This way, when one region\nfails another is still available. Display \nService\nFavorites \nService\nSearch \nService\nRegion A DNS\nCross-Region Load Balancer\nDisplay \nService\nFavorites \nService\nSearch \nService\nRegion B DNS\nFavorites\nRFP Index\nFavorites\nRFP Index\nProject Lionheart\nAllocation View\nCloud Deployment\nCloud Provider Infrastructure\nCity Infrastructure\nDatabase\nNetwork communication\nLegend\nHere is one potential walkthrough for the given quality attribute scenario:\nReader:\nThe next scenario covers availability during a region failure. Let\u2019s start\nby assuming everything is up and running. OK, bam! Region A just went down. Architect:\nWithin 60 seconds, our cross-region load balancer will detect the failure\nand automatically route traffic to the available region. If a user was unlucky enough\nto be on the website at that moment, they\u2019ll get a failure. Refreshing the browser\nshould fix the problem. Reviewer 1:\nWhere is the multiregion load balancer hosted? Architect:\nIn the closet across the hall. Reviewer 1:\nSo all site accessibility is determined by load balancers we\u2019re manag-\ning? Why bother with the cloud platform at all if our weakest link is in the building? Reader:\nReviewer 1, let\u2019s work to keep our conversation constructive. Can you try\nto phrase your concern as a risk? Reviewer 1:\nSorry, I was just a bit surprised. How about this: There is a single\npoint-of-failure in our cross-region strategy; might not be able to meet required ser-\nvice-level agreements. (Recorder verifies the concern is captured.) Reviewer 2:\nHow is the data kept up to date in the proposed multiregion\ndeployment\u2026\nChapter 17. Activities to Evaluate Design Options \u2022 310\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 316", "position": 316, "chunk_type": "semantic", "token_estimate": 296}
{"text": "Example: In this example, the team was struggling with a few ideas. Parts of the software\nsystem were undergoing major refactoring and the team had a strong desire\nto avoid rework if possible. Several new responsibilities needed a home and\ntwo alternatives had been proposed. A deadline was looming and a decision\nhad to be made with imperfect information. In this case, the team sketched diagrams of the current and possible future\ndesigns. Some team members were not satisfied with the current architecture. After seeing how it compared to the potential future state, they were much\nmore willing to go along with the current design. The discussion that went\nwith these sketches also created a shared understanding for the future\ndirection of the system and identified areas with potential technical debt. report erratum  \u2022  discuss\nSketch and Compare \u2022 313", "domains": ["Design Patterns"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 319", "position": 319, "chunk_type": "semantic", "token_estimate": 140}
{"text": "[Mey97]: Bertrand Meyer. Object-Oriented Software Construction. Prentice Hall,\nEnglewood Cliffs, NJ, Second edition, 1997. [Mug14]\nJonathan Mugan. The Curiosity Cycle: Preparing Your Child for the Ongoing\nTechnological Explosion. Mugan Publishing, Buda, TX, Second edition,\n2014. [Pat14]\nJeff Patton. User Story Mapping: Discover the Whole Story, Build the Right\nProduct. O\u2019Reilly & Associates, Inc., Sebastopol, CA, 2014. [PML10]\nHasso Plattner, Chrisoph Meinel, and Larry Leifer. Design Thinking:\nUnderstand - Improve - Apply (Understanding Innovation). Springer, New\nYork, NY, 2010. [PP03]\nMary Poppendieck and Tom Poppendieck. Lean Software Development: An\nAgile Toolkit for Software Development Managers. Addison-Wesley, Boston,\nMA, 2003. [Ras10]\nJonathan Rasmusson. The Agile Samurai: How Agile Masters Deliver Great\nSoftware. The Pragmatic Bookshelf, Raleigh, NC, 2010. [RW1\n1]\nNick Rozanski and Eoin Woods. Software Systems Architecture: Working\nWith Stakeholders Using Viewpoints and Perspectives. Addison-Wesley,\nBoston, MA, Second edition, 2011. [Sim96]\nHerbert Simon. The Sciences of the Artificial. MIT Press, Cambridge, MA,\nThird edition, 1996. [TA05]\nJeff Tyree and Art Akerman. Architecture Decisions: Demystifying Archi-\ntecture. IEEE Software. 22[2]:19\u201327, 2005, March/April. [VAH12]\nUwe Van Heesch, Paris Avgerioum, and Rich Hilliard. A documentation\nframework for architecture decisions. Journal of Systems and Software. 85[4]:795\u2013820, 2012, April, December. [WFD16]\nJonathan Wilmot, Lorraine Fesq, and Dan Dvorak. Quality attributes for\nmission flight software: A reference for architects. IEEE Aerospace Confer-\nence. 5\u201312, 2016, March. [WNA13]\nMichael Waterman, James Noble, and George Allen. The effect of complex-\nity and value on architecture planning in agile software development. Agile\nProcesses in Software Engineering and Extreme Programming (XP2013). 2013, May. [Zwe13]\nThomas D. Zweifel. Culture Clash 2: Managing the Global High Performance\nTeam. SelectBooks, New York, NY, 2013. Bibliography \u2022 320\nreport erratum  \u2022  discuss", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 325", "position": 325, "chunk_type": "semantic", "token_estimate": 277}
{"text": "architecturally evident coding: style, 107, 146\narchitecturally significant re-\nquirements (ASRs), 49\u201362,\nsee also constraints; influ-\nential functional require-\nments; quality attributes;\narchitecture design stu-\ndios, 115\narchitecture evaluation,\n160, 162, 164, 166\narchitecture evaluation\nworkshops, 166\narchitecture flipbook, 229\nASR Workbook, 60\u201362, \n148\nchoose one thing, 192\ndecision matrix, 292\ndefined, 49\nidentifying, 49\u201362\ninterviewing stakehold-\ners, 202\nlist assumptions activity,\n205\nother influences, 49, 58\u2013\n59\nselecting architecture\nand, 65\u201375, 101\nsoftware architect\u2019s role,\n4, 185\nstructure and, 63\nin traditional software\narchitecture descrip-\ntion (SAD), 148\nunderstanding the prob-\nlem activities, 191\u2013\n192, 205\narchitecture, see also architec-\nture decision records; archi-\ntecture design studios; ar-\nchitecture evaluation; de-\nsign\narchitectural mismatch,\n88\nchange and, 75\u201376\ndecision matrix, 71\u201373, \n292\u2013294\ndefined, 7\u20139\ndesign exploration and\ndivergence and conver-\ngence, 63\u201365, 118\nminimalist, 17\nmoving design decisions\nout of, 76\nnotional, 37, 56, 270\npersonify the architecture\nactivity, 120, 184, 226\nselecting, 63\u201377, 101\nunintended, 63, 101\narchitecture briefings, 184, \n286\u2013288\narchitecture cartoons, 134\narchitecture decision records,\n146, 155, 260\u2013262, 274\nArchitecture Decisions: Demys-\ntifying Architecture, 262\nArchitecture Description\nLanguages (ADLs), 141\narchitecture descriptions,\n143\u2013157\narchitecture evaluation\nworkshops, 169\nbenefits, 143\nmatching method to situ-\nation, 145\u2013149\nmethod types, 145\nnotation, 151\norganization, 152\u2013155\npaths not taken, 155\ntips for, 149\u2013155\nviewpoints, 153\u2013155\narchitecture design studios,\n113\u2013126\nactivities, 119, 123\nexercises, 120\nmanaging groups, 121\u2013\n126\nparticipants, 120\u2013122\nplanning, 113\u2013126\nProject Lionheart, 126\nremote teams, 124\nstructure, 114\u2013126\narchitecture evaluation, 159\u2013\n176\nactivities for, 168, 285\u2013\n313\nadvantages, 159\nArchitecture Trade-off\nAnalysis Method\n(ATAM), 170\ncontinuous, 171\u2013175, \n285\ncoverage, 171\u2013175\ndeep evaluation, 171\nevaluation pyramid, 171\u2013\n172\nevent storming, 248\nexercises, 166\nimportance of lines, 161\ninsights, 164\nlow ceremony, 174\nquick checks, 171\nrubrics, 160, 162\u2013164, \n167\nsign-off evaluation, 160\ntangible artifacts, 160\ntargeted evaluation, 171\nworkshops, 166\u2013170\narchitecture evaluation work-\nshops, 166\u2013170\narchitecture flipbook, 106, \n228\u2013231, 238\narchitecture haiku, 146, 184, \n263, 274\nArchitecture Trade-off Analy-\nsis Method (ATAM), 170\narrows in sequence diagrams,\n279\nartifacts, see also documenta-\ntion; models\nin quality attribute sce-\nnarios, 53\ntangible artifacts for archi-\ntecture evaluation, 160\nASR Workbook, 60\u201362, 148\nASRs, see architecturally sig-\nnificant requirements\n(ASRs)\nassumptions\ncode reviews, 291\nComponent Responsibili-\nty Cards (CRC cards),\n233\nconcept map, 238\nlist assumptions activity,\n59, 205\u2013206\nasynchronous request mes-\nsages in sequence dia-\ngrams, 279\nATAM (Architecture Trade-off\nAnalysis Method), 170\nATAM: Method for Architecture\nEvaluation, 170\naudience\narchitecture descriptions\nand, 149\u2013152, 154\nprototypes, 276\nUnified Modeling Lan-\nguage (UML), 136, 138\nauthority and team develop-\nment, 179, 181\u2013185\navailability, see quality at-\ntributes\nAvgerioum, Paris, 262\nB\nBasili, Victory, 199\nBass, Len, xvii, 66\nbatch sequential pattern, 84\nBeck, Kent, 232, 281\nbehavior, observing, 295\u2013297\nIndex \u2022 322", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 327", "position": 327, "chunk_type": "semantic", "token_estimate": 451}
{"text": "belongs to relation, 92: Belshee, Arlo, 105\nbenevolent dictator, 95\nbias, cognitive, 220\nbig ball of mud pattern, 96\nblender example, 68\nBoehm, Barry, 29, 32\nBollhoefer, Bett, xvii, 40\nBooch, Grady, 13, 64\nbounded rationality, 27\nbox-and-line diagrams\nconcept map, 237\nelement-responsibility\nviews, 130\nimportance of lines, 161\nusing, 139\nbrainstorming, see also activ-\nities\narchitecture evaluation,\n168\nevent storming, 244\u2013248\nin explore design mind-\nset, 19\nmini-Quality Attribute\nWorkshop (mini-QAW),\n213\nquality attribute web,\n198, 207\u2013209\nquestion-comment-con-\ncern activity, 168\nrisk storming, 168\ntime limits, 213\nBrandolini, Alberto, 244, 248\nbreadth-first approach, 241\nBredemeyer, Dana, 17\nbriefings, architecture, 184, \n286\u2013288\nBrooks, Fred, 58, 187\nBrown, Simon, xvii, 96, 109, \n139, 154, 301\nBuilding Models Quickly and\nCarefully, 231\nbusiness constraints, 50, 66\nbusiness goals\namount and relative im-\nportance, 44\narchitecture design stu-\ndios, 115\ndefined, 43\nexercises, 46\nfunctional requirements\nand, 59\nGoal-Question-Metric\n(GQM) Workshop, 199\u2013\n201\ninception deck, 270\nlist assumptions activity,\n205\nstakeholders and, 43\u201346, \n59\nstatements, 44, 218\nin traditional software\narchitecture descrip-\ntion (SAD), 148\nbuyer\u2019s remorse, 311\nC\nC & C structures, see compo-\nnent and connector struc-\ntures\nC4 model, 139, 154\ncalculator app example, 10, \n57\nCaldiera, Gianluigi, 199\nCarnegie, Dale, 61\ncartoons, 134\ncase study, see Project Lion-\nheart\ncenter of competence pattern,\n93\nchainsaw blender, 68\ncharrettes, 113, see also archi-\ntecture design studios\ncheck loop, see think, do,\ncheck loop\nchecklists\ncode reviews, 291\nteam development, 180\nchoose one thing activity, 73, \n192\u2013194, 270\nclarification and architecture\ndescriptions, 144\nCoC pattern, 93\nCockburn, Alistair, 82\nCOCOMO II, 32\ncode\nbuilding models into,\n107\u2013111\ncode skeleton, 180\ncomments, 110\ngenerating models from,\n111\norganizing as story, 150\norganizing to make pat-\nterns obvious, 108\nreview, 161, 168, 180, \n289\u2013291\ncode reviews, 161, 168, 180, \n289\u2013291\ncode skeleton, 180\ncognitive bias, 220\ncohesion and layers pattern,\n81\nCohn, Mike, 171\ncollaboration\nactivities, 184\narchitecture design stu-\ndios with remote\nteams, 125\ncollaborator cards, 75\nComponent Responsibili-\nty Cards (CRC cards),\n75, 232\u2013235\ndelegating authority, 184\nevolution of problem\nsolving, 99\nhuman-centered design,\n13, 16\ncolor\ndiagrams, 136, 139\nmeta-models, 103\nquestion-comment-con-\ncern activity, 299\ncomments\ncode, 110\nquestion-comment-con-\ncern activity, 168, 175, \n184, 298\u2013300\ncommunal architecture de-\nscription method, 145\u2013146\ncommunicates with relation,\n92\ncommunication\nactive listening, 61\narchitecture descriptions,\n151\narchitecture design stu-\ndios, 114\nbusiness goals, 44\nmake design mindset, 19\nresources on, 61\nsanity check, 304\ntangibles, 259\ncompare activity, sketch and,\n168, 311\u2013313\ncomplexity\ndesign strategy and, 31\nmanaging with models,\n99\u2013112\nmodular decomposition\ndiagrams, 272\ncomponent and connector\nstructures\nbig ball of mud pattern,\n96\ndefined, 8\nIndex \u2022 323", "domains": ["Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 328", "position": 328, "chunk_type": "semantic", "token_estimate": 436}
{"text": "enforcing element rela-: tions, 109\nexercise, 9\ngenerating models from\ncode, 111\nmulti-tier pattern, 92\npipe-and-filter pattern,\n84\nports and adapters pat-\ntern, 82\npublish-subscribe pat-\ntern, 88\nruntime, 8\u20139\nservice-oriented pattern,\n86\nshared-data pattern, 90\nComponent diagram, 139\nComponent Responsibility\nCards (CRC cards), 75, \n232\u2013235\ncomponents, see also compo-\nnent and connector struc-\ntures\nComponent Responsibili-\nty Cards (CRC cards),\n75, 232\u2013235\ndiagrams, 139\nevent specification, 89\nvs. module structures, 9\nmulti-tier pattern, 92\nrefinement views, 131\nresponsibility, 75\nshared-data pattern, 90\nconcept gaps, 237\nconcept individuation, 102\nconcept map, 231, 236\u2013238\nconcepts\nactivities, 225\narchitecture flipbook,\n229, 238\nComponent Responsibili-\nty Cards (CRC cards),\n232\u2013235\nconcept gaps, 237\nconcept individuation,\n102\nconcept map, 231, 236\u2013\n238\nconceptual constraints,\n104\nmeta-model, 101\u2013107\nmodular decomposition\ndiagrams, 272\nnames, 105, 237, 272\nomniscient concepts, 237\nsketch and compare activ-\nity, 311\u2013313\nconceptual constraints, 104\nconcern activity, question-\ncomment-, 168, 175, 184, \n298\u2013300\nconditions, risk, 33\u201336, 173\nconsequences, risk, 33\u201336, \n173\nconsistency\ncode reviews, 291\nsoftware architect\u2019s role,\n185\nvisualizations, 139\nconstraints\nactivities, 59, 191\narchitectural guide rails,\n180\narchitecture haiku, 263\nbusiness, 50, 66\nconceptual constraints,\n104\ndefined, 49\nlimiting options with, 49\u2013\n50\nProject Lionheart, 50, 77\nselecting architecture\nand, 66\nself-imposed, 49\u201350, 66\nsoftware architect\u2019s role,\n4\nstakeholders and, 67\nstatements, 50\ntechnical, 50, 66\nA Construct for Describing\nSoftware Development\nRisks, 33\nconstruction methods\nactivities, 225\nselecting architecture, 65\nConstructive Systems Engi-\nneering Model (COSYSMO),\n32\nconsumers in publish-sub-\nscribe pattern, 88\nContainer diagram, 139\ncontainers\ndiagrams, 139\nenforcing element rela-\ntions, 110\ncontext\narchitecture decision\nrecords, 260\narchitecture design stu-\ndios, 116\nin business goal state-\nments, 44, 218\ncontext mapping, 238\ncontextual drift, 172, 174\ndiagrams, 139, 265\nquality attribute scenar-\nios, 52\u201353\nsoftware architect\u2019s role,\n5\nin traditional software\narchitecture descrip-\ntion (SAD), 148\ncontext diagrams, 139, 265\ncontext mapping, 238\ncontextual drift, 172, 174\ncontract, design by, 109\nconvergence and design explo-\nration, 63\u201365, 118\nConway, Melvin, 58\nConway\u2019s Game of Life, 106\nConway\u2019s Law, 58\ncosts\narchitecture evaluation,\n171\ndesign sweet spot, 29\ninception deck, 270\nmodels, 101\nprototypes, 276\nCOSYSMO (Constructive Sys-\ntems Engineering Model),\n32\ncoupling and layers pattern,\n81\nCQRS systems, 248\nCRC cards (Component Re-\nsponsibility Cards), 75, \n232\u2013235\ncreate-share-critique cycle,\n117, 256\ncreating\narchitecture design stu-\ndios, 115, 117\ncreate-share-critique cy-\ncle, 117, 256\ncriteria, in design rubrics,\n162\u2013164\ncritiques\narchitecture design stu-\ndios, 115, 117\ncreate-share-critique cy-\ncle, 117, 256\ndiagram exercise, 140\ngroup poster activity, 250\nround-robin design activ-\nity, 252\u2013254\ntangibles, 259\nwhiteboard jams, 256\nIndex \u2022 324", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 329", "position": 329, "chunk_type": "semantic", "token_estimate": 423}
{"text": "Culture Clash 2: Managing the: Global High Performance\nTeam, 61\nCunningham, Ward, 232\ncuriosity cycle, 102\nCustomer Experience Architec-\nture, 40\ncustomer-centric design, 40\nD\ndata accessor component, 90\ndata store in shared-data\npattern, 90\nde Gooijer, Thijmen, xvii, 61, \n198\ndecision making, see also de-\nsign rationale; trade-offs\narchitecture flipbook,\n228\u2013231\narchitecture haiku, 263\ncode reviews, 290\ndecision matrix, 71\u201373, \n292\u2013294\nfacilitating team develop-\nment, 178\u2013179\nmoving design decisions\nout of architecture, 76\nrecords, 146, 155, 260\u2013\n262, 274\nsystem metaphors, 281\ndecision matrix, 71\u201373, 292\u2013\n294\ndecomposition diagram,\nmodular, 272\ndeep evaluation, 171\ndelegating and team develop-\nment, 181\u2013185\nDelegation Poker, 184\ndelivery methods\nprototypes, 276\nselecting architecture\nand, 65\ndependency inversion, 76\ndeployment methods\nselecting architecture\nand, 65\u201366\nviews, 133\ndepth-first approach, 241\ndescriptions, software archi-\ntecture, see architecture\ndescriptions\ndescriptive prose, 140\ndesign, see also architecture\ndesign studios; design\nmindsets; design strategy;\ndesign thinking; visualizing\ndesign\nbenefits, 12\nfor change, 75\u201376\ncontext of system, 5, 139\nby contract, 109\ncustomer-centric design,\n40\ndecision matrix, 71\u201373, \n292\u2013294\ndelaying, 75\ndivergence and conver-\ngence exploration, 63\u2013\n65, 118\nHART principles, 15\u201318\nimportance of, xv\nmoving decisions out of\narchitecture, 76\npassive, 36\nredesign, 16\u201317, 65, 225\nrework and, 29\u201331\nrisk and active vs. pas-\nsive, 36\nsatisficing design, 27\u201329, \n285\nselecting architecture,\n63\u201377\nSOLID principles, 76\ndesign artifact activities,\nsee make design mindset\ndesign authority and team\ndevelopment, 179, 181\u2013185\ndesign constraints, see con-\nstraints\ndesign hills, 217\ndesign mindsets, see also eval-\nuate design mindset; ex-\nplore design mindset; make\ndesign mindset; understand\ndesign mindset\nabout, xvi\ndefined, 18\nexercises, 20\nicons, xvi\nthink, do, check loop, 21\u2013\n24, 35\nusing, 18\u201324\ndesign patterns vs. architec-\nture patterns, 80\nDesign Patterns: Elements of\nReusable Object-Oriented\nSoftware, 80\ndesign plan, creating, 36\ndesign policies, 180\ndesign rationale\nin architecture descrip-\ntions, 149, 155\narchitecture haiku, 263\ndecision matrix, 292\u2013294\ndefined, 155\npaths not taken, 274\ndesign rubrics, see rubrics\ndesign strategy, 27\u201338\ndesign plan, 36\ndesign sweet spot, 29\u201331\nhow much to design up\nfront, 29\u201332\npassive design, 36\nrisk and, 28, 32\u201337\nsatisficing design, 27\u201329\nsimplifying problems, 28\ntreating solutions as ex-\nperiments, 28\ndesign studios, see architec-\nture design studios\ndesign sweet spot, 29\u201331\ndesign thinking, 15\u201324\nabout, xv\ndesign mindsets, 18\u201324\nprinciples, 15\u201318\nDesign Thinking: Understand\n- Improve - Apply (Under-\nstanding Innovation), 15\nDesigning for the Digital Age:\nHow to Create Human-Cen-\ntered Products and Services,\n202\ndetails and models, 100\ndevelopment, team, see team\ndevelopment\ndiagrams, see also visualizing\ndesign\nannotating, 130, 133, \n136\narchitecture descriptions,\n151\narchitecture flipbook,\n228\u2013231\narchitecture haiku, 263\nbox-and-line diagrams,\n130, 139, 161, 237\nC4 model, 139\nconcept map, 237\ncontext diagrams, 135, \n265\ndescriptive prose, 140\ndrawing tips, 136\u2013140\nelement-responsibility\nviews, 130\nexercises, 140\ngroup poster activity, 250\nIndex \u2022 325", "domains": ["Design Patterns", "Design Principles", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 330", "position": 330, "chunk_type": "semantic", "token_estimate": 464}
{"text": "importance of lines, 161: legends, 137\u2013139, 151\nmodular decomposition\ndiagrams, 272\nnotation, 136, 138\u2013139, \n151, 265, 278, 280\npatterns in, 138\u2013139\nsequence diagrams, 278, \n280\nwhiteboard jams, 255\u2013\n257\ndivergence and design explo-\nration, 63\u201365, 118\ndivide and conquer activity,\n239\u2013243\ndo loop, see think, do, check\nloop\ndo-make-check cycle, 285\ndocumentation, see also archi-\ntecture descriptions\narchitecture decision\nrecords, 146, 155, 260\u2013\n262, 274\narchitecture haiku, 264\nASR Workbook, 60\u201362, \n148\nbuilding model into code,\n107\ncode comments, 111\ndesign plan, 37\nevent specification, 89\nfunctional requirements,\n58\ngreatest hits reading list,\n267\nmoth ball document, 186\npaths not taken, 155, \n228, 231, 274\nProject Lionheart, 186\nsanity check, 304\nA documentation framework\nfor architecture decisions,\n262\ndomain\nactivities, 225\narchitecture flipbook, 229\nComponent Responsibili-\nty Cards (CRC cards),\n232\u2013235\nconcept map, 236\u2013238\nevent storming, 244\u2013248\ngroup poster activity, 250\nmodels and, 105, 108\nnames and, 105\nselecting architecture\nand, 65\nDomain-Driven Design: Tack-\nling Complexity in the Heart\nof Software, 238\ndot voting\ndesign studios, 120\nempathy maps, 197\ngroup poster activity, 250\nmini-Quality Attribute\nWorkshop (mini-QAW),\n211\nquality attributes web,\n208\ndrawings and sketches, see\nalso visualizing design\narchitecture evaluation,\n160, 168\narchitecture evaluation\nworkshops, 168\narchitecture flipbook,\n228\u2013231\nComponent Responsibili-\nty Cards (CRC cards),\n234\ngroup poster activity,\n249\u2013251\npersonify the architec-\nture, 226\npractice, 120\nquestion-comment-con-\ncern activity, 299\nrisk storming, 301\nround-robin design activ-\nity, 252\u2013254\nsketch and compare activ-\nity, 168, 311\u2013313\ntips for, 136\u2013140\nwhiteboard jams, 255\u2013\n257\nE\neducation, see also team de-\nvelopment\narchitecture briefings,\n286\narchitecture design stu-\ndios, 124\narchitecture flipbook,\n228\u2013231\nevent storming, 244\ninformation sessions, 181\njust-in-time education,\n124\nquestion-comment-con-\ncern activity, 298\nscaffolding, 180\nelaboration phase, 37\nelement-responsibility cata-\nlog, 74, 130\nelement-responsibility views,\n130\nelements\nin architecture descrip-\ntions, 149\nassigning functional re-\nsponsibilities, 73\u201375\ncenter of competence\npattern, 94\nComponent Responsibili-\nty Cards (CRC cards),\n232\u2013235\ncreating structures, 8\ndefined, 8\nelement-responsibility\ncatalog, 74, 130\nelement-responsibility\nviews, 130\nenforcing relations, 109\nexercises, 9\nlayers pattern, 81\nmodels and, 105, 109\nmulti-tier pattern, 92\nnaming, 105\nopen source contribution\npattern, 95\norganizing code to make\npatterns obvious, 109\npattern visualizations,\n139\npipe-and-filter pattern,\n84\nports and adapters pat-\ntern, 82\npublish-subscribe pat-\ntern, 88\nselecting architecture\nand, 64, 73\u201375\nservice-oriented pattern,\n86\nshared-data pattern, 90\nas term, 9\nempathy\nactive listening, 61\nmap, 150, 195\u2013198\nwith stakeholders, 16, \n39\u201346, 191, 195\u2013198\nempathy map, 150, 195\u2013198\nenforcing relations, 109\nenvironment context in quali-\nty attribute scenarios, 53\nerosion in architectural is-\nsues rainbow, 172\nerosion, architectural, see ar-\nchitectural drift\nIndex \u2022 326", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 331", "position": 331, "chunk_type": "semantic", "token_estimate": 428}
{"text": "evaluate design mindset: activities and exercises,\n285\u2013313\ndefined, 20\ndo-make-check cycle, 285\nexercise, 20\nicons, xvi\nusing, 18\u201324\nusing risk to choose, 34\nevaluating architecture,\nsee architecture evaluation\nevaluation pyramid, 171\u2013172\nevent bus, 88\nevent sourcing, 248\nevent specification, 89\nevent storming, 244\u2013248\nexceptions and code com-\nments, 111\nexercises, see also activities\nabout, xvii\nactive listening, 61\narchitecture design stu-\ndios, 120\narchitecture evaluation,\n166\nbusiness goals, 46\ndelegating authority, 184\ndiagrams, 140\nelements, relations, and\nstructures, 9\nin explore design mind-\nset, 20\nmeta-model, 106\nmodels, 106\npaths not taken, 156\nquality attribute scenar-\nios, 55\nstakeholders, 43, 46\nteam development, 184\nexperiments, treating solu-\ntions as, 28\nexperts\narchitecture evaluation\nworkshops, 167\ncenter of competence\npattern, 93\nevent storming, 244\u2013248\nopen source contribution\npattern, 95\nexploration plan, 241\nexplore design mindset\nactivities and exercises,\n225\u2013257\nbreadth-first vs. depth-\nfirst approach, 241\ndefined, 19\ndivergence and conver-\ngence, 118\nexercise, 20\nicons, xvi\npatterns and quality at-\ntributes, 69\u201371\nusing, 18\u201324\nusing risk to choose, 34\nExtreme Programming Ex-\nplained: Embrace Change,\n281\nF\nFairbanks, George, xiii, xvii, \n35, 107, 150, 231, 263\nfeatures\nmini-Quality Attribute\nWorkshop (mini-QAW),\n212\u2013213\nsoftware architect\u2019s role,\n4\nfeedback, see also architec-\nture evaluation; code re-\nviews; peer reviews; think,\ndo, check loop\narchitecture briefings,\n286\u2013288\narchitecture design stu-\ndios, 115, 117\ndivide and conquer activi-\nty, 239\nteam development, 181\nfighting the framework, 88\nfilter pattern, see pipe-and-\nfilter pattern\nflipbook, architecture, 106, \n228\u2013231, 238\nfocal point for remote architec-\nture design studios, 125\nfollow-up\narchitecture design stu-\ndios, 115, 118\narchitecture evaluation\nworkshops, 166, 170\ncode reviews, 290\nmini-Quality Attribute\nWorkshop (mini-QAW),\n214\nsketch and compare activ-\nity, 312\nFoote, Brian, 96\nfork and pull workflow and\nenforcing element relations,\n110\nformal architecture descrip-\ntion method, 145\u2013148\nformal models, 146\nFowler, Martin, 13\nframeworks\narchitectural mismatch,\n88\ndomain model, 108\nfighting, 88\nselecting architecture\nand, 65\nfunctional requirements,\nsee architecturally signifi-\ncant requirements (ASRs);\ninfluential functional re-\nquirements\nG\ngRPC in service-oriented pat-\ntern, 86\nGame of Life, Conway\u2019s, 106\nGang of Four, 80\ngaps\nin architectural issues\nrainbow, 172\nconcept gaps, 237\nmodel-code gap, 107\nquestion-comment-con-\ncern activity, 298\nsanity check, 304\nglossary, term, 148\nThe Goal Question Metric\n(GQM) Approach, 199\nGoal-Question-Metric (GQM)\nWorkshop, 59, 199\u2013201, \n296\ngoals, see also business goals\narchitecture design stu-\ndios, 115\u2013117, 123\nGoal-Question-Metric\n(GQM) Workshop, 59, \n199\u2013201, 296\nGood Naming Is a Process, Not\na Single Step, 105\nGoodwin, Kim, 202\nGQM (Goal-Question-Metric)\nWorkshop, 59, 199\u2013201, \n296\nGQM tree, 200\nGraylog, 297\ngreatest hits reading list, 267\ngroup dynamics/management\narchitecture design stu-\ndios, 118, 121\u2013126\ndivide and conquer activi-\nty, 241\nIndex \u2022 327", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 332", "position": 332, "chunk_type": "semantic", "token_estimate": 441}
{"text": "group poster activity, 119,: 249\u2013252\ngroupthink, 121\nguide rails, architectural, 180\nH\nhaiku, architecture, 146, \n184, 263, 274\nHalloway, Stuart, 286, 288\nHART principles, 15\u201318\nHexagonal Architecture, 82\nHilliard, Rich, 262\nHohpe, Gregor, 101\nHow to Win Friends and Influ-\nence People, 61\nhuman rule, 16\nhuman-centered design\nabout, xv\narchitecture descriptions,\n152\narchitecture design stu-\ndios, 120\nbenefits, 13, 15\nbusiness goals, 44\ncollaboration, 13, 16\nhuman rule, 16\npersonify the architec-\nture, 120, 184, 226\nsoftware architect\u2019s role,\n185\nsoftware architecture de-\nsign as, 4\ntangibility rule and, 18\nHystrix Dashboard, 297\nI\ninception deck, 59, 184, 269\u2013\n271\ninfluential functional require-\nments, see also architec-\nturally significant require-\nments (ASRs)\nactivities, 59, 191, 193\narchitecture flipbook, 230\narchitecture haiku, 263\nassigning to elements,\n73\u201375\ncalculator app example,\n57\nclasses of, 56\nComponent Responsibili-\nty Cards (CRC cards),\n232\u2013235\nconcept map, 237\ndefined, 49, 56\nmini-Quality Attribute\nWorkshop (mini-QAW),\n212\nvs. quality attributes, 52\nselecting architecture\nand, 73\u201375\ninformation sessions and\nteam development, 181\ninner layers, 82\ninsights in architecture evalu-\nations, 160, 164, 169\ninstructional scaffolding, 180\ninstrumentation and observ-\ning behavior, 295\u2013297\nintent\narchitecture descriptions,\n155\nmodels, 100\nnames and, 105\ninterface segregation, 76\ninterviewing stakeholders,\n59, 202\u2013204, 220\nIntroducing Event Storming:\nAn Act of Deliberate Collec-\ntive Learning, 244\ninversion of control, 291\nISO/IEC/IEEE 42010 stan-\ndard\narchitecture decision\nrecords, 262\narchitecture descriptions,\n153\nSAD templates, 147\niterating\narchitecture design stu-\ndios, 115, 117\u2013119\nlength, 21\nspeed, 28\nthink, do, check loop, 21\u2013\n24, 35\nivory tower software archi-\ntects, 16, 40\nJ\njs-sequence-diagrams, 279\nJust Enough Software Architec-\nture: A Risk-Driven Ap-\nproach, 35, 107\njust-in-time education, 124\nJVM, 297\nK\nKrutchen, Phillipe, 154\nKua, Patrick, xvii, 183, 286\nKubernetes, 132\nL\nA Laboratory for Teaching Ob-\nject-Oriented Thinking, 232\nlast responsible moment, 75\nlayers\ninner layers, 82\nlayers pattern, 80\u201381, \n104\nports and adapters pat-\ntern, 82\nlayers pattern, 80\u201381, 104\nleadership, see team develop-\nment\nLean Software Development:\nAn Agile Toolkit for Software\nDevelopment Managers, 75\nlearning, see education; team\ndevelopment\nlegends\ndiagrams, 137\u2013139, 151\nevent storming, 247\ngroup poster activity, 250\nLeifer, Larry, 15\nLess is more with minimalist\narchitecture, 17\nlife line in sequence diagrams,\n278\nlines, see box-and-line dia-\ngrams\nLiskov substitution, 76\nlist assumptions activity, 59, \n205\u2013206\nlistening\nactive, 61\ninterviewing stakehold-\ners, 202\u2013204\nresponse measure straw\nman, 220\nteam development, 183\nlogging platforms, 297\nLogStash, 297\nM\nmad lib, Point-of-View (POV),\n44, 215\u2013218\nmake design mindset\nactivities to make design\ntangible, 259\u2013283\narchitecture design stu-\ndios, 114\nbenefits, 259\ndefined, 19\nexercise, 20\nicons, xvi\nIndex \u2022 328", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 333", "position": 333, "chunk_type": "semantic", "token_estimate": 431}
{"text": "using, 18\u201324: using risk to choose, 34\nMaking Metaphors That Mat-\nter, 281\nMalan, Ruth, 17\nManagement 3.0, 184\nManagement 3.0: Leading Ag-\nile Developers, Developing\nAgile Leaders, 181\nManaging for Happiness:\nGames, Tools, and Practices\nto Motivate Any Team, 184\nmapping structures, see allo-\ncation structures\nmapping views, 133\nMarathon, 132\nMars Rover, 53\nMaster of the SAD, 148\nmatching sanity check, 306\nmay contribute to relation, 95\nMeinel, Christoph, 15\nmessage system\nin sequence diagrams,\n279\nin service-oriented pat-\ntern, 86\nmeta-model, 101\u2013107, 111, \n136\nmetaphors, system, 146, \n184, 281\u2013283\nmetrics\nGoal-Question-Metric\n(GQM) Workshop, 59, \n199\u2013201, 296\nobserving behavior activi-\nty, 295\nmicroservice architectures\nenforcing relations and,\n110\nobserving behavior activi-\nty, 296\nsequence diagrams, 279\nmilestones, 37\nmindsets, see design mind-\nsets\nmini-Quality Attribute Work-\nshop (mini-QAW), 59, 210\u2013\n214, 220\nminimalism\nminimalist architecture,\n17\nrefinement views, 132\nminimalist architecture, 17\nmismatch, architectural, 88\nmodel-code gap, 107\nmodels, 99\u2013112, see also visu-\nalizing design\nadvantages, 100\narchitecture flipbook,\n228\u2013231\nbuilding into code, 107\u2013\n111\ncuriosity cycle, 102\nformal models, 146\ngenerating from code,\n111\nmake design mindset, 19\nmeta-model, 101\u2013107, \n111, 136\nProject Lionheart, 111\nsoftware architect\u2019s role,\n185\nusing, 99\u2013112\nmodular decomposition dia-\ngrams, 272\nmodule structures\nbig ball of mud pattern,\n96\nvs. components, 9\ndefined, 8\nenforcing element rela-\ntions, 109\nexercise, 9\nlayers pattern, 81\norganizing code to make\npatterns obvious, 109\nports and adapters pat-\ntern, 82\nmonitoring element relations,\n109\nmost responsible moment, 75\nmoth ball document, 186\nMugan\u2019s Curiosity Cycle, 102\nmulti-tier pattern, 92\nMural, 196, 300\nMythical Man Month, 58\nN\nnames\nin business goal state-\nments, 44\ncode reviews, 291\nconcepts, 105, 237, 272\nelements, 105\nimportance of good, 105\nmerging meta-models,\n104\nmodels, 100, 104\u2013105\nmodular decomposition\ndiagrams, 272\npatterns, 139\nrelations, 237\nstages of naming, 105\nstakeholder maps, 222\nNASA Mars Rover, 53\nNetflix, 297\nNewsies, 282\nNo Silver Bullet, 187\nnotations\narchitecture descriptions,\n151\ncontext diagrams, 265\ndiagrams, 136, 138\u2013139, \n151, 265, 278, 280\nround-robin design activ-\nity, 254\nsequence diagrams, 278, \n280\nviewpoints, 153\nNotes on the Synthesis of\nForm, 28, 225\nnotional architecture\ndesign plan, 37\ninception deck, 270\ninfluential functional re-\nquirements, 56\nO\nThe Object Primer: Agile Mod-\nel-Driven Development with\nUML 2.0, 232\nObject-Oriented Software\nConstruction, 109\nobserving behavior activity,\n295\u2013297\nomniscient concepts, 237\nopen source contribution\npattern, 95\nopen/closed principle, 76\noral history, 145\noutcome in business goal\nstatements, 44, 218\nownership\narchitecture briefings,\n286\nopen source contribution\npattern, 95\npromoting architectural\nthinking, 178\nquestion-comment-con-\ncern activity, 298\nround-robin design activ-\nity, 253\nOzkaya, Ipek, xvii, 161\nIndex \u2022 329", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 334", "position": 334, "chunk_type": "semantic", "token_estimate": 431}
{"text": "P: pair design/programming,\n112, 180\nparking lots, 124\npartitioning\nlayers pattern, 80\u201381\nsystem, 4, 12, 185\npassive design, 36\npaths not taken, 155, 228, \n231, 274\nA Pattern Language: Towns,\nBuildings, Construction, 17\nPattern Languages of Program\nDesign 4, 96\npatterns, architecture, 79\u201397\nadvantages, 79\narchitectural mismatch,\n88\narchitecture haiku, 263\nbig ball of mud pattern,\n96\nbuilding model into code,\n108\ncenter of competence\npattern, 93\ncompared to system\nmetaphors, 282\ndefined, 79\nvs. design patterns, 80\ndiagrams, 138\u2013139\ndiscovering new, 96\nlayers pattern, 80\u201381\nmeta-model and, 104\nmodels, 104, 108, 111\nmulti-tier pattern, 92\nnames, 139\nobserving behavior activi-\nty, 296\nopen source contribution\npattern, 95\norganizing code, 108\npipe-and-filter pattern,\n84\nports and adapters pat-\ntern, 82\npromoting quality at-\ntributes, 79\npublish-subscribe pat-\ntern, 69\u201371, 86, 88\nquality attribute scenar-\nios, 80\nquality attributes, 69\u2013\n71, 80\nselecting, 69\u201371\nservice-oriented pattern,\n86, 297\nshared-data pattern, 90\npatterns, design, 80\npeer reviews, see also code\nreviews\narchitecture decision\nrecords, 260\nscaffolding, 180\nperformance, see quality at-\ntributes\npersonify the architecture,\n120, 184, 226\npipe-and-filter pattern, 84\npitching in architecture de-\nsign studios, 117\nplanning and design sweet\nspot, 29\u201331\nplatform-as-a-service, 110\nPoint-of-View (POV) mad lib,\n44, 215\u2013218\nPoker, Delegation, 184\npolicies, design, 180\nPoppendieck, Mary, 75\nPoppendieck, Tom, 75\nportfolios, 11\nports and adapters pattern,\n82\nposter activity, group, 119, \n249\u2013252\nPOV (Point-of-View) mad lib,\n44, 215\u2013218\npractice\ndrawing and sketching,\n120\nsafe practice and team\ndevelopment, 179\u2013181\npresentations, 149, 214\nproblems\nactivities for understand-\ning, 191\u2013223\nin architectural issues\nrainbow, 172\ndefining as role of soft-\nware architects, 4\ndiscovering new patterns\nand, 97\nevolution of problem\nsolving, 99\nroutine, 28\nselecting architecture\nand, 65\nsimplifying as design\nstrategy, 28\nthinking about solution\nat same time, 28, 225\nproducers in publish-sub-\nscribe pattern, 88\nprogrammers, see also team\ndevelopment\ntransitioning to software\narchitect, 4, 11\u201312, \n175, 177\u2013187\nusing this book, xv\nProject Lionheart\nabout, xvii\narchitecturally significant\nrequirements (ASRs),\n50, 54\u201355, 62, 77\narchitecture decision\nrecords, 262\narchitecture descriptions,\n153, 155\u2013156\narchitecture design stu-\ndio, 126\narchitecture evaluation,\n162\u2013164, 175\narchitecture haiku, 264\nbusiness goals, 44, 46, \n218\ncartoon, 135\nconcept map, 238\nconclusion, 186\nconstraints, 50, 77\ncontext diagrams, 266\ndecision matrix, 72\u201373, \n294\ndesign hills, 217\ndesign rubric, 162\u2013164\ndesign strategy, 38\ndocumentation, 186\nmodels, 111\npaths not taken, 155\npatterns, 97, 111\nPoint-of-View (POV) mad\nlib, 216\nquality attribute scenar-\nios, 54\u201355, 175, 309\u2013\n310\nscenario walkthrough,\n309\u2013310\nselecting architecture,\n72\u201373, 77\nsetup, 14\nstakeholders, 40\u201343, 46\nstakeholders map, 41\u201343\nsystem metaphors, 282\nviewpoints, 153, 187\nviews and visualization,\n130\u2013135, 141, 175\nproperties\ndecision matrix, 71\u201373\nmodels, 100\nsystem metaphors, 281, \n283\nIndex \u2022 330", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 335", "position": 335, "chunk_type": "semantic", "token_estimate": 442}
{"text": "prototypes, 41, 276, see al-: so models\npublish-subscribe pattern,\n69\u201371, 88, 296\npublishers\npublish-subscribe pat-\ntern, 88\nservice-oriented architec-\nture pattern, 86\nQ\nquality attribute scenarios,\nsee also raw scenarios\nactivities, 59\narchitecture evaluation,\n163, 175\narchitecture flipbook, 229\nComponent Responsibili-\nty Cards (CRC cards),\n233\nconcept map, 237\ndecision matrix, 72\u201373, \n292\nempathy maps, 196\nexercise, 55\nGoal-Question-Metric\n(GQM) Workshop, 199\u2013\n201\ninterviewing stakehold-\ners, 202\nmini-Quality Attribute\nWorkshop (mini-QAW),\n210\u2013214\npatterns, 80\nProject Lionheart, 54\u201355, \n175, 309\u2013310\nquality attribute web,\n207\u2013209\nresponse measures, 53, \n55, 204, 214, 219\nscenario walkthrough,\n168, 184, 307\u2013310\ntemplates, 211\nusing, 52\u201356\nviews, 132\nquality attribute web, 198, \n207\u2013209, 211, 213\nQuality Attribute Workshops\n(QAWs), 214, see also mini-\nQuality Attribute Workshop\n(mini-QAW)\nQuality Attribute Workshops\n(QAWs), Third Edition, 214\nquality attributes, see al-\nso quality attribute scenar-\nios\nactivities, 59, 191, 193\narchitectural mismatch\nand, 88\narchitecture descriptions,\n144\narchitecture design stu-\ndios, 115\narchitecture evaluation,\n162, 166\narchitecture haiku, 263\narchitecture, selecting,\n68\u201373\nconceptual constraints,\n104\ndefined, 10, 49, 51\ndefining, 51\u201356\nempathy maps, 196\nexercises, 55\nframeworks and technolo-\ngy and, 65\nvs. functional require-\nments, 52\nmini-Quality Attribute\nWorkshop (mini-QAW),\n59, 210\u2013214, 220\nmodels, 100, 104, 107, \n109\nmodular decomposition\ndiagrams, 272\norganizing code to make\npatterns obvious, 109\npartitioning the system,\n5\npatterns, 69\u201371, 80\npreserving ambiguity, 17\npromotion with architec-\nture, 7, 10, 13, 68\u201373, \n79, 107\nquality attribute web,\n198, 207\u2013209, 211, \n213\nQuality Attribute Work-\nshops (QAWs), 214\nsketch and compare activ-\nity, 311\u2013313\nsoftware architect\u2019s role,\n4, 10, 186\nstructures and, 10, 51\ntaxonomy, 208, 213\ntrade-offs, 6, 186\nviewpoints, 154\nviews, 132\nquality requirements,\nsee quality attributes\nquestion-comment-concern\nactivity, 168, 175, 184, \n298\u2013300\nquestions\narchitecture briefings,\n287\narchitecture design stu-\ndios, 114, 117\narchitecture evaluation,\n166, 170, 175\ncuriosity cycle, 103\ndivide and conquer activi-\nty, 240\nevent storming, 244\u2013248\nGoal-Question-Metric\n(GQM) Workshop, 59, \n199\u2013201, 296\ninception deck, 269\ninterviewing stakehold-\ners, 202\u2013204\nmini-Quality Attribute\nWorkshop (mini-QAW),\n212\nquestion-comment-con-\ncern activity, 168, 175, \n184, 298\u2013300\nscenario walkthrough,\n308\nin traditional software\narchitecture descrip-\ntion (SAD), 148\nquick checks in architecture\nevaluation, 171\nR\nrainbow, architectural issues,\n172\u2013175\nRasmusson, Jonathan, 269, \n271\nratings, design rubrics, 162, \n164\nrationale, see design rationale\nrationality, bounded, 27\nraw scenarios\ndefined, 54\nmini-Quality Attribute\nWorkshop (mini-QAW),\n210\u2013214\nquality attribute web,\n207\u2013209\nresponse measure straw\nman, 219\nreader in scenario walk-\nthrough, 308\nreading in shared-data pat-\ntern, 90\nreading list, greatest hits, 267\nrecorder in scenario walk-\nthrough, 307\nred/black deployment, 66\nIndex \u2022 331", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 336", "position": 336, "chunk_type": "semantic", "token_estimate": 417}
{"text": "redesign, 16\u201317, 65, 225: refinement views, 131\nrelations\ncenter of competence\npattern, 94\nComponent Responsibili-\nty Cards (CRC cards),\n233\nconcept map, 236\u2013238\ncreating structures, 8\ndefined, 8\nenforcing with models,\n109\nexercise, 9\nlayers pattern, 81\nmulti-tier pattern, 92\nnames, 237\nopen source contribution\npattern, 95\npipe-and-filter pattern,\n84\nports and adapters pat-\ntern, 82\npublish-subscribe pat-\ntern, 88\nselecting architecture\nand, 64\nservice-oriented pattern,\n86\nshared-data pattern, 90\nrelationships, stakeholders\nmap, 41\u201343, 221\u2013223\nreliability, see quality at-\ntributes\nrepositories\nenforcing element rela-\ntions, 110\nopen source contribution\npattern, 95\nrequirements, see architec-\nturally significant require-\nments (ASRs); influential\nfunctional requirements\nresources\nfor this book, xvii\non communication, 61\nresponse, 53\nresponse measure straw man,\n55, 204, 214, 219\nresponse measures, 53, 55, \n204, 214, 219\nresponse messages in se-\nquence diagrams, 279\nresponsibilities\narchitect\u2019s role in assign-\ning, 4, 185\nin architecture descrip-\ntions, 149\nassigning to elements,\n73\u201375\ncenter of competence\npattern, 94\nComponent Responsibili-\nty Cards (CRC cards),\n75, 232\u2013235\nelement names, 105\nelement-responsibility\ncatalog, 74, 130\nelement-responsibility\nviews, 130\nlast responsible moment,\n75\nmost responsible mo-\nment, 75\nopen source contribution\npattern, 95\nsanity check, 304\nselecting architecture\nand, 64\nsingle, 76\nwhiteboard jams, 257\nResponsibility Area in center\nof competence pattern, 94\nResponsible for in center of\ncompetence pattern, 94\nREST in service-oriented pat-\ntern, 86\nreviewers in scenario walk-\nthrough, 308\nreviews, see code reviews;\ncritiques; peer reviews\nrework and design sweet spot,\n29\u201331\nrisk\narchitectural issues rain-\nbow, 172\narchitecture evaluation,\n170, 172\ndefined, 33\ndesign plan, 37\ndesign strategy, 28, 32\u2013\n37\ndesign sweet spot, 29\ndivide and conquer activi-\nty, 240\nevent storming, 244\u2013248\ninception deck, 270\npassive design, 36\nProject Lionheart, 38\nquestion-comment-con-\ncern activity, 298\nrisk statements, 33\nrisk storming, 168, 184, \n301\u2013303\nin traditional software\narchitecture descrip-\ntion (SAD), 148\nrisk statements, 33\nrisk storming, 168, 184, 301\u2013\n303\nrobot example of quality at-\ntribute scenarios, 53\nrolling upgrades, selecting\narchitecture and, 66\nRombach, H. Dieter, 199\nrot, architectural, see architec-\ntural drift\nround-robin design activity,\n119, 125, 252\u2013254\nRozanski, Nick, 154\nrubrics\narchitecture evaluation,\n160, 162\u2013164, 167\ndecision matrix, 293\nrules\nHART principles, 15\u201318\nmeta-model, 101\u2013107\nruntime\ncomponent and connec-\ntor structures, 8\u20139\ncontracts, 109\nmulti-tier pattern, 92\nobserving behavior, 295\u2013\n297\nsequence diagrams, 278\nservice-oriented patterns\nand, 86\nS\nSAD (software architecture\ndescription), see architec-\nture descriptions; tradition-\nal software architecture de-\nscription (SAD)\nsanity check, 252, 298, 304\u2013\n306, 312\nsatisficing design, 27\u201329, 285\nSATURN software architec-\nture conference, xiii\nscaffolding, 180\nscalability, see quality at-\ntributes\nscenario walkthroughs, 168, \n184, 307\u2013310\nscenarios, see quality at-\ntribute scenarios; raw sce-\nnarios\nIndex \u2022 332", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 337", "position": 337, "chunk_type": "semantic", "token_estimate": 440}
{"text": "The Sciences of the Artificial,: 27\nscope and inception deck,\n270\nsequence diagrams, 278, 280\nservice registry, 86\nservice-oriented architecture\npattern, 69\u201371, 86, 297\nservices in service-oriented\npattern, 86\nshared-data pattern, 90\nsharing\narchitecture design stu-\ndios, 115, 117\ncreate-share-critique cy-\ncle, 117, 256\nround-robin design activ-\nity, 252\u2013254\nshow-and-tell meeting, 241\nsign-off evaluation, 160\nsilver toolbox, xvi, 187\nSimian Army, 297\nSimon, Herbert, 27\nsimplicity\nsimplifying problems in\ndesign strategy, 28\nvisualizations, 139\nsink elements in pipe-and-fil-\nter pattern, 84\nsize and design strategy, 30\nsketch and compare activity,\n168, 311\u2013313\nsketching, see drawings and\nsketches\nskills\nfacilitating team develop-\nment, 179, 183\nscenario walkthrough,\n309\nsoft, 183\nsliders, trade-off, 194\nslideware architecture descrip-\ntion, 149\nSOA, see service-oriented ar-\nchitecture pattern\nSOAP, 86\nsoft skills, 183\nsoftware architects, see archi-\ntects\nsoftware architecture, see ar-\nchitecture\nsoftware architecture descrip-\ntion (SAD), see architecture\ndescriptions; traditional\nsoftware architecture de-\nscription (SAD)\nsoftware architecture design,\nsee design\nSoftware Architecture for De-\nvelopers, 109, 301\nSoftware Architecture in Prac-\ntice, 8, 51, 170\nSoftware Engineering Insti-\ntute, 147, 154, 211\nSOLID principles, 76\nsolutions\nactivities for exploring,\n225\u2013257\ndiscovering new patterns\nand, 97\nevolution of problem\nsolving, 99\ninception deck, 270\nthinking about problems\nat same time, 28, 225\ntreating as experiments,\n28\nsource elements in pipe-and-\nfilter pattern, 84\nsource in quality attribute\nscenarios, 52\nSplunk, 297\nstakeholder groups, 39\nstakeholders, see also design\nmindsets; design strategy\nactive listening, 61\nactivities, 59, 191\u2013194\narchitecture briefings,\n286\u2013288\narchitecture descriptions,\n144, 147, 149\u2013155\narchitecture design stu-\ndios, 115, 121\narchitecture evaluation\nworkshops, 167\narchitecture haiku, 263\nbusiness goals, 43\u201346, 59\nconcept map, 236\nconstraints and, 67\ncontext diagrams, 265\ncuriosity cycle, 103\ncustomer-centric design,\n40\ndecision matrix, 72, 292\ndefined, 39\ndelegating authority, 184\ndesign hills, 217\ndivide and conquer activi-\nty, 240\nempathizing with, 16, 39\u2013\n46, 191, 195\u2013198\nempathy maps, 195\u2013198\nexercises, 43, 46\nGoal-Question-Metric\n(GQM) Workshop, 199\u2013\n201\ngreatest hits reading list,\n267\ngroup poster activity,\n249\u2013251\ngroups, 39\nidentifying ASRs, 59\ninception deck, 269\u2013271\ninterviewing, 59, 202\u2013\n204, 220\nmap, 40\u201343, 221\u2013223\nmapping views, 134\nmini-Quality Attribute\nWorkshop (mini-QAW),\n210\u2013214, 220\nmodels, 103\nnaming, 222\nPoint-of-View (POV) mad\nlib, 215\u2013218\nProject Lionheart, 38, 40\u2013\n43, 46\nprototypes, 276\nquality attribute web,\n207\u2013209\nresponse measure straw\nman, 55, 219\nround-robin design activ-\nity, 253\nscenario walkthrough,\n308\ntangibles and, 259\ntechnical debt, 6\ntrade-offs, 6\u20137, 192\u2013194\ntraditional software archi-\ntecture description\n(SAD), 147\nviews, 129, 148, 152\u2013155\nwhiteboard jams, 255\u2013\n257\nstatic analysis tools, 109\u2013110\nstimulus in quality attribute\nscenarios, 52\nstopping conditions, 37\nstories and story telling\narchitecture descriptions,\n145, 150\narchitecture flipbook, 229\ndiagrams, 140\norganizing code as story,\n150\nIndex \u2022 333", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Design Principles"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 338", "position": 338, "chunk_type": "semantic", "token_estimate": 446}
{"text": "personify the architec-: ture, 226\nscenario walkthrough,\n307\u2013310\nsystem metaphors, 281\u2013\n283\nuser odyssey, 215\nuser story mapping, 248\nstrategy, see design strategy\nstraw man, response mea-\nsure, 55, 204, 214, 219\nstructures, see also allocation\nstructures; component and\nconnector structures; mod-\nule structures; patterns,\narchitecture\ncreating, 8\ndefined, 8\nenforcing element rela-\ntions, 109\nexercise, 9\ngroup poster activity, 250\nmixing, 9\nmodels, 100\norganizing code, 108\nquality attributes and,\n10, 51\nselecting architecture,\n63\u201377\nsequence diagrams, 278\nsystem metaphors, 281\nsystem shape, 9\nsubject in business goal\nstatements, 44, 218\nsubscribers\npublish-subscribe pat-\ntern, 88\nservice-oriented architec-\nture pattern, 86\nSucceeding with Agile: Soft-\nware Development Using\nScrum, 171\nsweet spot, design, 29\u201331\nsynchronous request mes-\nsages in sequence dia-\ngrams, 279\nsystem\ncontext, 5, 139\nmodular decomposition\ndiagrams, 272\npartitioning, 4, 12, 185\nrisk storming, 301\u2013303\nsequence diagrams, 278\nshape and structures, 9\nsystem metaphors, 146, \n184, 281\u2013283\nSystem Context diagram, 139\nsystem metaphors, 146, 184, \n281\u2013283\nT\ntables, 134\ntangibility rule\nactivities to make design\ntangible, 259\u2013283\narchitecture descriptions,\n144\ndefined, 16\nimportance of, 17\nmake design mindset, 19\nstakeholders and, 259\ntangible artifacts for archi-\ntecture evaluation, 160\ntargeted evaluation, 171\ntaxonomy, quality attribute,\n208, 213\nteam development, 177\u2013187\narchitecture design stu-\ndios, 115, 118, 120\u2013\n122\nauthority, 179, 181\u2013185\ncode reviews, 289\u2013291\ndelegating, 181\u2013185\ndivide and conquer activi-\nty, 239\u2013243\nexercise, 184\nportfolios, 11\npromoting architectural\nthinking, 177\nremote teams, 124\nsafe practice, 179\u2013181\nsanity check, 304\u2013306\nscenario walkthrough,\n309\nsoftware architect\u2019s role,\nxvi, 3, 7, 185\u2013186\ntransition to software ar-\nchitect, 4, 11\u201312, 175, \n177\u2013187\nteam organization\narchitecture descriptions,\n144\ncenter of competence\npattern, 94\nConway\u2019s Law, 58\nmapping views, 134\nmodular decomposition\ndiagrams, 272\nopen source contribution\npattern, 95\nstakeholder map, 221\u2013\n223\ntraditional software archi-\ntecture description\n(SAD), 148\ntechnical constraints, 50, 66\ntechnical debt, 6, 186\ntechnology, selecting architec-\nture and, 65\ntell-show-tell approach, 123\ntemplates\narchitecture decision\nrecords, 260\u2013261\narchitecture descriptions,\n152\narchitecture haiku, 264\nPoint-of-View (POV) mad\nlib, 215\u2013218\nquality attribute scenar-\nios, 211\nscaffolding, 180\ntraditional software archi-\ntecture description\n(SAD), 147\ntest pyramid, 171\ntesting, see also architecture\nevaluation\nobserving behavior activi-\nty, 295\nresponse measures, 55\ntangibles, 259\ntest pyramid, 171\ntestability in code re-\nviews, 291\nthink, do, check loop, 21\u201324, \n35, 77\nthrashing, 31\ntime\narchitecture design stu-\ndios, 113, 115, 117, \n122, 124\u2013125\nbrainstorming, 213\ndesign strategy, 29\u201332, \n36\ndesign sweet spot, 29\u201331\ndivide and conquer activi-\nty, 239\nmodels, 101\nprototypes, 276\nrisk and design strategy,\n36\nscenario walkthrough,\n309\nsequence diagrams, 278\nIndex \u2022 334", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 339", "position": 339, "chunk_type": "semantic", "token_estimate": 425}
{"text": "time line for design plan,: 37\ntime line in inception\ndeck, 270\ntrade-offs\nactivities, 73, 192\u2013194\narchitecture haiku, 263\nArchitecture Trade-off\nAnalysis Method\n(ATAM), 170\ndecision matrix, 71\u201373, \n292\ndefined, 63\ninception deck, 270\nquality attributes, 6, 186\nsliders, 194\nstakeholders, 6\u20137, 192\u2013\n194\ntraditional software architec-\nture description (SAD),\n147, 161, see also architec-\nture descriptions\ntribal architecture description\nmethod, 145\nTurner, Richard, 32\nTyree, Jeff, 262\nU\nUML (Unified Modeling Lan-\nguage), 136, 138\u2013139, 151\nunderstand design mindset\nactivities, 191\u2013223\ndefined, 18\nexercise, 20\nusing, 18\u201324\nusing risk to choose, 34\nUnified Modeling Language\n(UML), 136, 138\u2013139, 151\nunknowns in architectural\nissues rainbow, 172\nupdates and upgrades\nmerging meta-models,\n104\nselecting architecture\nand, 66\nupstream repository workflow\nand enforcing element rela-\ntions, 110\nuser experience, 41, 248\nuser odyssey, 215\nuser stories\narchitecture flipbook, 229\nuser story mapping, 248\nuser story mapping, 248\nUsing Risk to Balance Agile\nand Plan-Driven Methods,\n32\nutility trees, 162\nV\nVan Heesch, Uwe, 262\nVelichansky, Michail, 281\nversion control\narchitecture decision\nrecords, 261\ncode reviews, 290\nenforcing element rela-\ntions, 110\nviewpoints, 153\u2013155, 187\nviews\narchitecture descriptions,\n149, 152\u2013155\narchitecture evaluation,\n175\ncartoons, 134\ncombining, 133\ncustom, 136\ndefined, 129\ndeployment views, 133\nelement-responsibility\nviews, 130\nmapping views, 133\nProject Lionheart, 130\u2013\n135, 141, 175\nquality attribute views,\n132\nquestion-comment-con-\ncern activity, 298\nrefinement views, 131\nrisk storming, 301\nin traditional software\narchitecture descrip-\ntion (SAD), 148\nusing different views in\nvisualizations, 129\u2013136\nviewpoints, 153\u2013155, 187\nwork assignment views,\n133\nViews and Beyond, 147\nvisualizing design, 129\u2013141,\nsee also drawings and\nsketches; models; views\nannotations, 130, 133, \n135\nArchitecture Description\nLanguages (ADLs), 141\ncartoons, 134\ndecision matrix, 71\u201373, \n292\u2013294\ndescriptive prose, 140\ndrawing tips, 136\u2013140\nevent storming, 244\nhighlighting patterns in,\n138\nquality attribute web,\n207\u2013209\nquestion-comment-con-\ncern activity, 298\u2013300\nsketch and compare activ-\nity, 168, 311\u2013313\ntables, 134\nusing different views,\n129\u2013136\nvocabulary\narchitecture descriptions,\n144, 151\narchitecture haiku, 264\nbuilding model into code,\n108\nconcept map, 236\nmeta-model, 101\nmodels and, 100\u2013101\npatterns and, 139\nsoftware architecture de-\nsign benefits, 13\nviewpoints, 153\nvolatility and design strategy,\n31\nW\nwalkthroughs, scenario, 168, \n184, 307\u2013310\nwasteful architecture descrip-\ntion method, 145, 149\nweb, quality attribute, 198, \n207\u2013209, 211, 213\nwhiteboard jams, 120, 255\u2013\n257\nWho Needs an Architect?, 13\nWoods, E\u00f3in, 154\nwork assignment views, 133\nworkshops\narchitecture evaluation\nworkshops, 166\u2013170\nGoal-Question-Metric\n(GQM) Workshop, 59, \n199\u2013201, 296\nmini-Quality Attribute\nWorkshop (mini-QAW),\n59, 210\u2013214, 220\nwriting in shared-data pat-\ntern, 90\nY\nYoder, Joseph, 96\nZ\nZweifel, Thomas D., 61\nIndex \u2022 335", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 340", "position": 340, "chunk_type": "semantic", "token_estimate": 421}
{"text": "Explore Testing: Explore the uncharted waters of exploratory testing and delve deeper into web testing. Explore It! Uncover surprises, risks, and potentially serious bugs\nwith exploratory testing. Rather than designing all tests\nin advance, explorers design and execute small, rapid\nexperiments, using what they learned from the last\nlittle experiment to inform the next. Learn essential\nskills of a master explorer, including how to analyze\nsoftware to discover key points of vulnerability, how\nto design experiments on the fly, how to hone your\nobservation skills, and how to focus your efforts. Elisabeth Hendrickson\n(186 pages) ISBN: 9781937785024. $29\nhttps://pragprog.com/book/ehxta\nThe Way of the Web Tester\nThis book is for everyone who needs to test the web. As a tester, you\u2019ll automate your tests. As a developer,\nyou\u2019ll build more robust solutions. And as a team,\nyou\u2019ll gain a vocabulary and a means to coordinate\nhow to write and organize automated tests for the web. Follow the testing pyramid and level up your skills in\nuser interface testing, integration testing, and unit\ntesting. Your new skills will free you up to do other,\nmore important things while letting the computer do\nthe one thing it\u2019s really good at: quickly running\nthousands of repetitive tasks. Jonathan Rasmusson\n(256 pages) ISBN: 9781680501834. $29\nhttps://pragprog.com/book/jrtest", "domains": ["Code Organization"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 343", "position": 343, "chunk_type": "semantic", "token_estimate": 211}
{"text": "The Modern Web: Get up to speed on the latest HTML, CSS, and JavaScript techniques, and secure your Node\napplications. HTML5 and CSS3 (2nd edition)\nHTML5 and CSS3 are more than just buzzwords \u2013\nthey\u2019re the foundation for today\u2019s web applications. This book gets you up to speed on the HTML5 elements\nand CSS3 features you can use right now in your cur-\nrent projects, with backwards compatible solutions\nthat ensure that you don\u2019t leave users of older browsers\nbehind. This new edition covers even more new fea-\ntures, including CSS animations, IndexedDB, and\nclient-side validations. Brian P. Hogan\n(314 pages) ISBN: 9781937785598. $38\nhttps://pragprog.com/book/bhh52e\nSecure Your Node.js Web Application\nCyber-criminals have your web applications in their\ncrosshairs. They search for and exploit common secu-\nrity mistakes in your web application to steal user data. Learn how you can secure your Node.js applications,\ndatabase and web server to avoid these security holes. Discover the primary attack vectors against web appli-\ncations, and implement security best practices and\neffective countermeasures. Coding securely will make\nyou a stronger web developer and analyst, and you\u2019ll\nprotect your users. Karl D\u00fc\u00fcna\n(230 pages) ISBN: 9781680500851. $36\nhttps://pragprog.com/book/kdnodesec", "domains": ["Software Quality Attributes"], "source": "Design It!_ From Programmer to Software Architect.pdf", "section": "Page 344", "position": 344, "chunk_type": "semantic", "token_estimate": 193}
