{"text": "Titles in the: Auerbach Series on Applied Software Engineering\nPhillip A. Laplante, Pennsylvania State University, Series Editor\nSoftware Engineering Design: Theory and Practice\nCarlos E. Otero  \n978-1-4398-5168-5\nEthics in IT Outsourcing\nTandy Gold \n978-1-4398-5062-6\nThe ScrumMaster Study Guide \nJames Schiel\n978-1-4398-5991-9\nAntipatterns: Managing Software Organizations and People,  \nSecond Edition\nColin J. Neill, Philip A. Laplante, and Joanna F\n. DeFranco\n978-1-4398-6186-8\nEnterprise-Scale Agile Software Development\nJames Schiel\n978-1-4398-0321-9\nRequirements Engineering for Software and Systems\nPhillip A. Laplante\n978-1-4200-6467-4 \nBuilding Software: A Practioner\u2019s Guide\nNikhilesh Krishnamurthy and Amitabh Saran\n978-0-8493-7303-9\nGlobal Software Development Handbook\nRaghvinder Sangwan, Matthew Bass, Neel Mullick, Daniel J. Paulish, \nand Juergen Kazmeier\n978-0-8493-9384-6\nSoftware Engineering Quality Practices\nRonald Kirk Kandt\n978-0-8493-4633-0\nwww.allitebooks.com", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 4", "position": 4, "chunk_type": "semantic", "token_estimate": 115}
{"text": "vii: Contents\nPreface........................................................................................................................... xvii\nAcknowledgments..........................................................................................................xix\nAbout the Author. ...........................................................................................................xxi\nChapter 1\t Introduction to Software Engineering Design. ...........................................1\nChapter Objectives................................................................................................... 1\nConceptual Overview.............................................................................................. 1\nEngineering Design. ................................................................................................. 2\nEngineering Problem Solving. ................................................................................ 3\nInitial State. ........................................................................................................... 4\nOperational State................................................................................................. 4\nThinking about the Problem......................................................................... 5\nProblem Solution............................................................................................ 6\nGoal State.............................................................................................................. 6\nSoftware Engineering Design................................................................................. 9\nWhy Study Software Engineering Design?......................................................... 10\nReasons for Studying Software Design in Product Development.............. 10\nReasons for Studying Software Design in Project Management................ 11\nSoftware Design Challenges. ................................................................................. 11\nDesign Challenge 1: Requirements Volatility................................................ 12\nDesign Challenge 2: Process............................................................................ 12\nDesign Challenge 3: Technology..................................................................... 12\nDesign Challenge 4: Ethical and Professional Practices.............................. 13\nDesign Challenge 5: Managing Design Influences....................................... 13\nStakeholders. .................................................................................................. 14\nDevelopment Organization\u2019s Structure..................................................... 14\nContext of Software Design.................................................................................. 15\nSoftware Design Process. ....................................................................................... 17\nSoftware Architecture....................................................................................... 18\nDetailed Design. ................................................................................................. 19\nInterface Design............................................................................................ 19\nComponent Design. ......................................................................................20\nConstruction Design.........................................................................................20\nHuman\u2013Computer Interface Design. ............................................................. 21\nSoftware Design Documentation.................................................................... 21\nSoftware Design Management......................................................................... 21\nwww.allitebooks.com", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 9", "position": 9, "chunk_type": "semantic", "token_estimate": 160}
{"text": "viii\u2002 \u2022\u2002 Contents: Roles of the Software Designer............................................................................. 22\nSystems Engineer............................................................................................... 23\nSoftware Architect............................................................................................. 23\nComponent Designer........................................................................................ 23\nSoftware Design Fundamentals. ........................................................................... 24\nGeneral Software Design Principles............................................................... 24\nModularization............................................................................................. 25\nAbstraction.................................................................................................... 25\nEncapsulation................................................................................................ 26\nCoupling. ........................................................................................................ 27\nCohesion. ........................................................................................................ 28\nSeparation of Interface and Implementation............................................ 29\nCompleteness and Sufficiency. .................................................................... 30\nPractical Software Design Considerations. .................................................... 30\nDesign for Minimizing Complexity. .......................................................... 31\nDesign for Change........................................................................................ 31\nSoftware Design Strategies............................................................................... 31\nStructured Design. ........................................................................................ 31\nObject-Oriented Design............................................................................... 32\nChapter Summary.................................................................................................. 32\nReview Questions................................................................................................... 33\nReferences................................................................................................................34\nChapter 2\t Software Design with Unified\u00a0Modeling Language.................................35\nChapter Objectives................................................................................................. 35\nConceptual Overview............................................................................................ 35\nWhat Is UML?. ........................................................................................................ 36\nWhy Study UML?................................................................................................... 37\nThe UML\u2019s Fundamentals..................................................................................... 37\nStructural Modeling. ..............................................................................................40\nComponent Diagrams...........................................................................................40\nLogical versus Physical Components. .............................................................42\nClass Diagrams....................................................................................................... 43\nClasses................................................................................................................. 43\nName Compartment....................................................................................44\nAttribute Compartment. ..............................................................................44\nOperation Compartment. ............................................................................ 45\nRelationships......................................................................................................46\nDependency................................................................................................... 47\nAssociation. .................................................................................................... 47\nAggregation...................................................................................................48\nComposition..................................................................................................48\nwww.allitebooks.com", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 10", "position": 10, "chunk_type": "semantic", "token_estimate": 145}
{"text": "Contents\u2002 \u2022\u2002 ix: Generalization............................................................................................... 49\nRealization..................................................................................................... 50\nDeployment Diagrams. .......................................................................................... 53\nBehavioral Modeling. ............................................................................................. 55\nUse Case Diagrams................................................................................................ 55\nInteraction Diagrams. ............................................................................................ 57\nCommunication Diagrams.............................................................................. 58\nSequence Diagrams........................................................................................... 59\nConcurrency in Interaction Diagrams........................................................... 59\nChapter Summary.................................................................................................. 63\nReview Questions................................................................................................... 63\nChapter Exercises...................................................................................................64\nReferences................................................................................................................ 65\nChapter 3\t Principles of Software Architecture. ..........................................................67\nChapter Objectives................................................................................................. 67\nConceptual Overview............................................................................................ 67\nWhat Is Software Architecture?...........................................................................68\nWhy Study Software Architecture?..................................................................... 70\nKey Tasks in Architectural Design...................................................................... 70\nIdentifying Stakeholders\u2019 Concerns. ............................................................... 71\nIdentifying Appropriate Architectural Views............................................... 71\nIdentifying Architectural Styles and Patterns............................................... 71\nIdentifying System Interfaces.......................................................................... 72\nIdentifying Impact of Architectural Decisions in Organization................ 72\nImpact on Customer Base. ........................................................................... 73\nImpact on Budget and Schedule................................................................. 73\nImpact from Resource Availability.............................................................74\nIdentifying the System\u2019s Major Components and Interfaces.......................74\nEvaluating and Validating the Architecture. ..................................................74\nIntroducing Policies for Design Synchronicity............................................. 75\nProblem Solving in Software Architecture......................................................... 76\nInputs. .................................................................................................................. 77\nConstraints......................................................................................................... 77\nOutputs............................................................................................................... 77\nSoftware Architecture Process............................................................................. 78\nUnderstand and Evaluate Requirements. ............................................................ 79\nElicitation. ........................................................................................................... 79\nRequirement Sources. ................................................................................... 79\nElicitation Techniques.................................................................................. 81\nAnalysis............................................................................................................... 82", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 11", "position": 11, "chunk_type": "semantic", "token_estimate": 170}
{"text": "x\u2002 \u2022\u2002 Contents: Specification and Validation............................................................................84\nSpecific. ........................................................................................................... 85\nCorrect. ........................................................................................................... 86\nComplete........................................................................................................ 86\nConsistent...................................................................................................... 87\nAttainable. ...................................................................................................... 87\nVerifiable........................................................................................................ 88\nDesigning the Architecture. .................................................................................. 88\nThe 4 + 1 View Model....................................................................................... 89\nUser View....................................................................................................... 89\nProcess View. .................................................................................................90\nPhysical View. ................................................................................................90\nDevelopment View. ....................................................................................... 91\nLogical View.................................................................................................. 91\nComponents and Connectors.......................................................................... 92\nDesigning Logical Architectural Elements Using Data Flows. ................... 92\nDesigning Logical Architectural Elements Using Styles and Patterns...... 93\nDesigning the Process Architecture............................................................... 93\nProcesses........................................................................................................ 93\nThreads........................................................................................................... 94\nEvaluating the Architecture. ............................................................................... 103\nChapter Summary................................................................................................ 104\nReview Questions................................................................................................. 105\nChapter Exercises................................................................................................. 106\nReferences.............................................................................................................. 106\nChapter 4\t Patterns and Styles in Software Architecture......................................... 107\nChapter Objectives............................................................................................... 107\nConceptual Overview.......................................................................................... 107\nArchitectural Styles and Patterns...................................................................... 108\nHistory of Architectural Styles and Patterns. .............................................. 108\nArchitectural Pattern Classification............................................................. 109\nData-Centered Systems. ........................................................................................111\nBlackboard Pattern...........................................................................................111\nData Flow Systems. ................................................................................................116\nPipe and Filter Pattern.....................................................................................116\nDistributed Systems.............................................................................................120\nClient\u2013Server Pattern......................................................................................120\nBroker Pattern.................................................................................................. 122\nInteractive Systems. .............................................................................................. 127\nModel\u2013View\u2013Controller Pattern. .................................................................. 127", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 156}
{"text": "Contents\u2002 \u2022\u2002 xi: Hierarchical Systems. ........................................................................................... 131\nMain Program and Subroutine. ..................................................................... 131\nLayered Pattern................................................................................................ 133\nChapter Summary................................................................................................ 136\nReview Questions................................................................................................. 136\nChapter Exercises................................................................................................. 137\nReferences.............................................................................................................. 137\nChapter 5\t Principles of Detailed Design. .................................................................. 139\nChapter Objectives............................................................................................... 139\nConceptual Overview.......................................................................................... 139\nWhat Is Detailed Design?. ................................................................................... 140\nKey Tasks in Detailed Design............................................................................. 142\nDetailed Design Process...................................................................................... 142\nUnderstanding the Architecture and Requirements. ...................................... 143\nCreating Detailed Designs.................................................................................. 144\nInterface Design............................................................................................... 144\nExternal Interface Design.......................................................................... 144\nInternal Interface Design. .......................................................................... 145\nGraphical User Interface Design.............................................................. 145\nDesigning Internal Structure of Components. ............................................ 145\nClasses.......................................................................................................... 146\nInterfaces, Types, Subtypes, Dynamic Binding, and Polymorphism.... 147\nObjects.......................................................................................................... 148\nDesign Principles for Internal Component Design.................................... 149\nOpen\u2013Closed Principle.............................................................................. 149\nLiskov Substitution Principle.................................................................... 156\nInterface Segregation Principle................................................................. 157\nProgramming Styles in Detailed Design. ..................................................... 159\nFunction Names. ......................................................................................... 160\nVariable Names........................................................................................... 162\nModeling Internal Behavior of Components. .............................................. 164\nDesign Components Using Design Patterns............................................... 166\nArchitectural versus Design Patterns...................................................... 167\nClassification of Design Patterns.............................................................. 167\nDocumenting Design Patterns. ................................................................. 168\nDocument the Software Design......................................................................... 169\nInterface Control Document. ......................................................................... 171\nSoftware Version Document.......................................................................... 172\nMonitor and Control Implementation.............................................................. 173\nChapter Summary................................................................................................ 173\nReview Questions..................................................................................................174", "domains": ["Architectural Patterns and Styles", "Design Principles", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 13", "position": 13, "chunk_type": "semantic", "token_estimate": 188}
{"text": "xii\u2002 \u2022\u2002 Contents: Chapter Exercises................................................................................................. 175\nReferences.............................................................................................................. 175\nChapter 6\t Creational Design Patterns in Detailed Design...................................... 177\nChapter Objectives............................................................................................... 177\nConceptual Overview.......................................................................................... 177\nCreational Design Patterns................................................................................. 178\nAbstract Factory................................................................................................... 178\nProblem............................................................................................................. 179\nStructure........................................................................................................... 179\nImplementation. ................................................................................................181\nBenefits.............................................................................................................. 188\nFactory Method.................................................................................................... 188\nProblem............................................................................................................. 189\nStructure........................................................................................................... 189\nImplementation. ............................................................................................... 191\nBenefits.............................................................................................................. 192\nBuilder. ................................................................................................................... 193\nProblem............................................................................................................. 195\nStructure........................................................................................................... 195\nImplementation. ............................................................................................... 197\nBenefits.............................................................................................................. 197\nPrototype............................................................................................................... 201\nProblem............................................................................................................. 201\nStructure...........................................................................................................204\nImplementation. ...............................................................................................205\nBenefits..............................................................................................................207\nSingleton................................................................................................................207\nProblem.............................................................................................................208\nStructure...........................................................................................................208\nImplementation. ...............................................................................................209\nBenefits...............................................................................................................211\nChapter Summary.................................................................................................211\nReview Questions..................................................................................................211\nChapter Exercises................................................................................................. 212\nReference. ................................................................................................................214\nChapter 7\t Structural and Behavioral\u00a0Patterns in Detailed Design. ........................ 215\nChapter Objectives............................................................................................... 215\nConceptual Overview.......................................................................................... 215\nStructural Design Patterns. ..................................................................................216", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 14", "position": 14, "chunk_type": "semantic", "token_estimate": 106}
{"text": "Contents\u2002 \u2022\u2002 xiii: Adapter...................................................................................................................216\nProblem............................................................................................................. 217\nStructure........................................................................................................... 219\nImplementation. ............................................................................................... 219\nBenefits.............................................................................................................. 221\nComposite. .............................................................................................................223\nProblem.............................................................................................................224\nStructure...........................................................................................................225\nImplementation. ...............................................................................................227\nBenefits.............................................................................................................. 231\nFacade. .................................................................................................................... 232\nProblem.............................................................................................................234\nStructure........................................................................................................... 235\nImplementation. ............................................................................................... 237\nBenefits..............................................................................................................238\nBehavioral Design Patterns. ................................................................................238\nIterator. ...................................................................................................................238\nProblem............................................................................................................. 239\nStructure........................................................................................................... 241\nImplementation. ...............................................................................................245\nBenefits.............................................................................................................. 251\nObserver. ................................................................................................................ 252\nProblem............................................................................................................. 252\nStructure........................................................................................................... 252\nImplementation. ...............................................................................................254\nBenefits..............................................................................................................254\nChapter Summary................................................................................................256\nReview Questions.................................................................................................256\nChapter Exercises................................................................................................. 257\nReference. ...............................................................................................................258\nChapter 8\t Principles of Construction Design. .......................................................... 259\nChapter Objectives............................................................................................... 259\nConceptual Overview.......................................................................................... 259\nWhat Is Construction Design?........................................................................... 259\nWhy Study Construction Design?.....................................................................260\nBehavioral Construction Design. ....................................................................... 261\nFlow-Based Designs. ........................................................................................ 261\nState-Based Designs. ........................................................................................262\nTable-Based Designs. .......................................................................................264\nLimited-Entry Decision Table...................................................................266\nExtended-Entry Decision Table................................................................268", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 15", "position": 15, "chunk_type": "semantic", "token_estimate": 108}
{"text": "xiv\u2002 \u2022\u2002 Contents: Mixed-Entry Decision Table..................................................................... 270\nTable-Based Construction......................................................................... 270\nProgramming Design Language................................................................... 271\nSoftware Construction Using Styles.................................................................. 274\nFormatting Conventions................................................................................ 275\nIndentation.................................................................................................. 276\nBrace Placement.......................................................................................... 278\nNaming Conventions...................................................................................... 279\nDocumentation Conventions. ........................................................................282\nDocumenting Files.....................................................................................282\nDocumenting Functions............................................................................282\nMinimizing Complexity in Construction Design...........................................283\nQuality Evaluation of Construction Design. ....................................................284\nPeer Reviews.....................................................................................................285\nUnit Testing......................................................................................................286\nCyclomatic Complexity..................................................................................286\nChapter Summary................................................................................................290\nReview Questions.................................................................................................290\nChapter Exercises................................................................................................. 291\nReferences..............................................................................................................292\nChapter 9\t Human\u2013Computer Interface Design....................................................... 293\nJacob Somervell\nChapter Objectives............................................................................................... 293\nConceptual Overview.......................................................................................... 293\nWhat Is Human\u2013Computer Interface Design?................................................294\nWhy Study Human\u2013Computer Interface Design?..........................................294\nGeneral HCI Design Principles..........................................................................297\nHuman\u2013Computer Interface Design Methods................................................299\nGetting Started. ................................................................................................299\nFidelity in Prototypes. .....................................................................................300\nMetaphors......................................................................................................... 301\nGestalt Principles.............................................................................................303\nReusing Earlier Designs. .................................................................................305\nEvaluation of HCI Quality..................................................................................305\nUsability Testing..............................................................................................305\nAnalytic Testing. ..............................................................................................306\nEmpirical Testing. ............................................................................................307\nChapter Summary................................................................................................309\nReview Questions.................................................................................................309\nChapter Exercises.................................................................................................309\nReferences...............................................................................................................310", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 16", "position": 16, "chunk_type": "semantic", "token_estimate": 128}
{"text": "xvii: This book is the result of an effort that I began in 2010 at the University of Virginia\u2019s \nCollege at Wise to create a course in software engineering design consistent with the 2004 \nIEEE/ACM curriculum guidelines for undergraduate programs in software engineering \n(SE). In a broad context, the recommended topics for undergraduate SE programs include \ndesign concepts, design strategies, architectural design, detailed design, human\u2013computer \ninterface design, and design evaluation. As a former industry practitioner, I learned first-\nhand the difference between hearing or \u201clearning\u201d about these topics and developing the \nnecessary skills to apply them in a way that adds value to some development team, pro-\ngram, project, or business. With that in mind, I set out to compile material that I could \nuse (from previous industry experience) to help students become proficient in design-\ning software-intensive systems. Throughout the process, many of the original examples \nconsidered dry or hard to follow by students were replaced with new problem domains \n(e.g.,\u00a0 gaming\u00ad\n systems) that helped students assimilate the concepts better. Because of \nthe \u201chands-on\u201d approach required to master these concepts, the teaching style evolved \nto emphasize both theory and practice. The theory portion was used to present accept-\nable general design principles or a body of design principles to explain successful software \n\u00ad\nsystems\u2019 designs. The practice portion provided the avenue for transforming design theory \ninto skills that can be employed directly to real-life industrial settings. The knowledge \nand experience gained from these efforts have been captured in this textbook, which can \nbe useful for both industry practitioners and students in software engineering, computer \n\u00ad\nscience, and information technology programs.", "domains": ["Design Principles", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 19", "position": 19, "chunk_type": "semantic", "token_estimate": 271}
{"text": "xviii\u2002 \u2022\u2002 Preface: As part of the introductory material, the software engineering process is covered briefly \nto provide the context in which software design takes place and a formal top-down design \nprocess is presented. The top-down approach consists of several design phases and activi-\nties that occur at varied levels of detail/abstraction, including the software architecture, \ndetailed design, and construction design. As part of the top-down approach, detailed \ncoverage of applied architectural, creational, structural, and behavioral design patterns is \nprovided and a collection of standards and guidelines for structuring high-quality code \nis presented. The book also provides techniques for evaluating software design quality at \ndifferent stages and much needed coverage of management and engineering leadership \nfor software designers. This provides software engineers with the necessary management, \n\u00ad\nethical, and leadership knowledge required to build products for the public domain. The \nbook also provides coverage of the software design document and other forms of documen-\ntation important during the design of software systems. Collectively, the book comprehen-\nsively introduces students and practitioners to software engineering design and provides \nthe knowledge required to emerge and succeed as tomorrow\u2019s professional design leaders.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 20", "position": 20, "chunk_type": "semantic", "token_estimate": 189}
{"text": "xxi: Carlos E. Otero, PhD, is assistant professor in the College of Technology and Innovation \nat the University of South Florida Polytechnic (USFP). Prior to joining USFP, Dr. Otero \nworked as assistant professor of software engineering in the Department of Mathematics \nand Computer Science at the University of Virginia\u2019s College at Wise, where he created \nthe software engineering design course for Virginia\u2019s first and (at the time of writing) only \nABET-accredited BS in software engineering. Prior to his academic career, Dr. Otero spent 11 years in the private industry, where \nhe worked as design and development engineer in a wide variety of military computer \n\u00ad\nsystems, including satellite communications systems, command and control systems, \nwireless security systems, and unmanned aerial vehicle systems. Currently, he continues \nto consult with industry in the areas of requirements engineering, software systems design \nand development, quality assurance, and mobile systems engineering. Dr. Otero received his BS in computer science, MS in software engineering, MS in \u00ad\nsystems \nengineering, and PhD in computer engineering from Florida Institute of Technology in \nMelbourne. He has published over 25 technical publications in \u00ad\nscientific peer-reviewed \njournals and conferences proceedings. He is a senior member of the IEEE, a\u00a0science \u00ad\nadvisor \nfor the National Aeronautics and Space Administration (NASA) DEVELOP program, an \nactive professional member of the Association for Computing Machinery (ACM), and a \nmember of several journal editorial boards in technology and engineering. About the Author", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 23", "position": 23, "chunk_type": "semantic", "token_estimate": 238}
{"text": "Design is an integral part of every engineering discipline. Airplanes, bridges, buildings,: electronic devices, cars, and many other products of similar complexity are all designed. In civil engineering, designs are used to specify detailed plans for developing physical and \nnaturally built environments, such as bridges, roads, canals, dams, and buildings. In elec-\ntrical engineering, designs are used to capture, evaluate, and specify the detailed qualita-\ntive and quantitative description of solutions for telecommunication systems, electrical \nsystems, and electronic devices. In mechanical engineering, designs are used for analyzing, \nevaluating, and specifying technical features required to construct machines and tools, \nsuch as industrial equipment, heating and cooling systems, aircrafts, robots, and medical \ndevices. In all other engineering disciplines, design provides a systematic approach for \ncreating products that meet their intended functions and users\u2019 expectations. Formally, \nDym\u00a0and Little (2008, p. 6) define engineering design as\nA systematic, intelligent process in which designers generate, evaluate and specify designs for \ndevices, systems or processes whose form(s) and function(s) achieve clients\u2019 objectives and \nusers\u2019 needs while satisfying a specified set of constraints. Design is a lengthy and complex process requiring significant investments in time and \neffort. So why conduct design in engineering disciplines? There are many possible answers \nto this question, stemming from simple common sense to more complicated ones involv-\ning professional, ethical, social, and legal implications. From the commonsense perspec-\ntive, products of such complexity are hard to create, are costly to change, and, when built \ncarelessly or incorrectly, can significantly impact human life. When working toward the \ncreation of complex products, teams must organize in a disciplined manner, and a sys-\ntematic approach needs to be employed to carefully ensure that products are built to meet \ntheir specifications. Consider the construction of a bridge that spans over a body of water \nand is required to support a particular weight, to maintain access to watercrafts navigating \nunderneath, to withstand expected wind speeds, and to provide other features such as side-\nwalks\u2014all while being bound by a schedule and budget. The successful construction of such \na bridge is a nontrivial task and requires years of experience, formal education, and large \nteams collaborating together to achieve the construction goals. If constructed incorrectly\u00ad\n, \nreconstructing the bridge can skyrocket from its original construction cost; worse yet, \nif defects are undetected, the bridge could collapse, resulting in the catastrophic loss of \nhuman life. Similar to the construction of the bridge, teams engineering other products,", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 26", "position": 26, "chunk_type": "semantic", "token_estimate": 407}
{"text": "Throughout the design process, designers are constantly engaging in problem-solving activ-: ities that are fundamental to all modern engineering projects. In a broad sense, engineers \ncan be characterized as specialized problem solvers. Their work requires them to identify, \nevaluate, and propose solutions to complex problems (in particular domains) under tight \nproject constraints. In some situations, engineers tackle problems that have never been \nsolved before, creating challenges to meet not only functional aspects of products but also \ntheir established schedule and budget. Before engaging in more concrete design topics, a \nformal discussion on problem solving is necessary to identify fundamental concepts that \nare well understood by successful designers; these serve as basis for establishing a holistic \nproblem solving framework that can be employed any time during design. To become a good designer, engineers must be good problem solvers. This may require \nyears of experience solving problems in a particular domain. In many cases, experience \nallows engineers to reuse already proven solutions across separate but similar problems. In other cases, where unsolved problems are encountered, designers are required to \n\u201cthink\u00a0out of the box\u201d and carefully craft a systematic approach for solving the problem in \nan acceptable manner, which may require problem classification, identification of the solu-\ntion approach and type of adequate solution, and identifying the overall strategy for reach-\ning its solution. In a general sense, problem solving during design occurs in three different \nstates (Plotnik and Kouyoumdjian 2010):\n\u2022\t Initial state\n\u2022\t Operation state\n\u2022\t Goal state\nThrough these states, designers employ several techniques and strategies to create a \nlandscape suitable for problem solving. The initial state is where problems are formulated \nand interpreted. In some cases, achieving full understanding of the problem is a problem \nitself. Once problems are well understood, designers move to the operational state, where \nthinking about the problem occurs and viable solutions come to light. Once an appropri-\nate solution is identified, evaluated, and validated, designers move to the goal state, where \na final solution to the problem is found, marking the end of the problem-solving process.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 27", "position": 27, "chunk_type": "semantic", "token_estimate": 343}
{"text": "4\u2002 \u2022\u2002 Software Engineering Design\ufeff: Initial State\nDesign problems are not all the same; they vary in size, complexity, and, based on these \ncharacteristics, the amount of time and effort required for their solution. In some cases, it \nquickly becomes evident that certain problems are harder to solve than others. When this \ndetermination is made, the strategy for the solution approach is adjusted to account for \nthe additional complexity. Being able to differentiate between types of problem is crucial \nin helping designers account for the amount of effort, time, and risk associated with the \nsolution approach. Therefore, an important problem-solving skill involves identifying and \nclassifying the type of problem encountered, which includes well-defined, ill-defined, and \nwicked problems, as presented in Table\u00a01.1 (Giachetti 2010). Well-defined problems have clear defined goals and their constraints are well under-\nstood. This makes scoping the problem, proposing a solution approach, and arriving at \nthe solution easier than with other types of problems, such as ill-defined and wicked \nproblems. Ill-defined problems are problems where the mere interpretation of the prob-\nlem is a problem itself; they are ambiguous with undefined goals and require more time \nand effort to clarify and interpret the problem to arrive at a solution. In some cases, with \nadditional effort, ill-defined problems can be transformed into well-defined problems. Finally, wicked problems are problems where no single problem formulation exists. There \nmay be many acceptable formulations of the problem and no definite solutions, and solu-\ntions are not deemed correct or incorrect but good or bad (Giachetti 2010). In\u00a0many cases, \nwicked problems can lead to contradictive goals that need additional resolution before the \nproblem solving can occur. When contradictive goals are present, providing a solution \nto one part of the problem results in the inability of solving other parts of the problem. In these types of problem, optimal solutions are hard to find, requiring additional strug-\ngle and collaborative brainstorming. Also, evaluation of alternative designs may require \nadvanced techniques to determine the best course of action, which tends to require more \ntime. In many cases, the solution to wicked problems is not known until after the problem \nis solved. Operational State\nThe operational state of problem solving is where thinking about the problem solution \ntakes place. It requires employing multiple techniques for problem solving such as using \nmetaphors, decomposing problems into smaller, less complex problems (i.e., divide and \nconquer), reusing solutions (e.g., patterns), and so forth.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 28", "position": 28, "chunk_type": "semantic", "token_estimate": 405}
{"text": "4\u2002 \u2022\u2002 Software Engineering Design\ufeff: Operational State\nThe operational state of problem solving is where thinking about the problem solution \ntakes place. It requires employing multiple techniques for problem solving such as using \nmetaphors, decomposing problems into smaller, less complex problems (i.e., divide and \nconquer), reusing solutions (e.g., patterns), and so forth. In all of the techniques, designers \nTABLE\u00a01.1\nProblem Classification\nProblem\nDescription\nWell-defined\nProblem with clear goals and known constraints\nIll-defined\nProblem with undefined or ambiguous goals and unknown constraints\nWicked\nProblem with no definite solution; not understood until after the formulation of its solution", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 28", "position": 28, "chunk_type": "semantic", "token_estimate": 97}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 5: are expected to exhibit a \u201cthink outside the box\u201d mentality to be able to solve complex \nproblems. This requires shifting the mental model from a conventional approach to uncon-\nventional methodology where solutions to complex problems may arise from thinking in \nways that deviate from conventional wisdom. For example, consider the popular nine-dot \npuzzle illustrated in Figure\u00a01.1 (Kershaw and Ohlsson 2004). The requirements for solving the nine-dot puzzle problem are as follows:\n\t\n1. Draw four straight lines to connect all dots. 2. The pencil cannot be lifted from the paper once the line-drawing process begins. 3. No lines can be retraced. Before moving on, think about this problem and attempt to provide a solution. At first, \nthis may seem difficult because of the tendency of fixing the mental process to operate on \nthe assumption that lines should begin and end on a dot. This functional fixedness limits \nthe ability to find solutions based on objects having a different function from their usual \nones (Plotnik and Kouyoumdjian 2010). In the case of the nine-dot puzzle, for some, func-\ntional fixedness makes it awkward or even impossible to propose solutions that involve lines \ngoing past the dots, which is what is required to solve this problem. To increase the chance \nof overcoming functional fixedness, problems need to be attempted several times and con-\nsidered from many different viewpoints and unusual angles (Plotnik and Kouyoumdjian). Overcoming functional fixedness is critical for designers attempting to provide solutions \nat the operational state of problem solving. Thinking about the Problem\nDifferent types of thinking take place when finding solutions to problems. For example, \nwhen learning about a problem for the first time, problem solvers may begin by asking \nquestions, which allows them to think about many different alternative solutions; as the \nproblem-solving process moves forward, problem solvers can begin narrowing down the \npossibilities and think about the single best solution to the problem. These types of think-\ning are known as convergent thinking and divergent thinking (Table 1.2). Both convergent and divergent thinking have significant roles in solving engineering \nproblems. In many cases, problem solvers begin using divergent thinking with different \nlevels of abstraction, and each level provides finer-grained solutions to the problem until \nconvergent thinking can be employed to solve it. FIGURE 1.1\nThe nine-dot puzzle.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 29", "position": 29, "chunk_type": "semantic", "token_estimate": 389}
{"text": "6\u2002 \u2022\u2002 Software Engineering Design\ufeff: Problem Solution\nIn many cases, determining the type of solution required for a given problem can reduce \nwasted time and effort spent in attempting to find a single, optimal solution. In such cases, \ndesigners can elect to seek approximate solutions\u2014as opposed to optimal solutions\u2014that \nare appropriate and acceptable for meeting project constraints. Determining the type of \nsolution for a given problem can reduce time and budget required for building the system. Two types of solutions are algorithms and heuristics, as presented in Table\u00a01.3. Algorithms are step-by-step procedures for finding the correct solution to given prob-\nlems. Algorithms do not normally involve subjective decisions or rely on intuition or \n\u00ad\ncreativity to find solutions (Brassard and Bratley 1995). For some types of problems, using \nalgorithms to find solutions can be unrealistic, especially in time-driven, practical engi-\nneering problems. In these cases, heuristics provide a realistic approach for finding good \napproximations of the solution. In some cases, heuristics can lead to optimal solutions; in \nothers, they can lead to solutions that are far from optimal or no solution at all (Brassard \nand Bratley 1995). Algorithms and heuristics are both used heavily in the design of engi-\nneering systems and determining their appropriateness for solving particular problems is \nessential to meeting other project demands. Goal State\nThe goal state represents the final state of problem solving. It is where adequate solutions \nto given problems are determined. For many engineering problems, reaching the goal state \nis a nontrivial task that requires careful attention to all important aspects of the problem. The concepts of initial, operational, and goal state can be fused together to create a holistic \nproblem-solving framework adequate to solving engineering problems at all stages of the \ndevelopment effort. The approach consists of the following tasks:\n\u2022\t Interpret problem\n\u2022\t Evaluate constraints\n\u2022\t Collaborative brainstorming\nTABLE\u00a01.2\nTypes of Thinking\nType\nDescription\nConvergent thinking\nType of thinking that seeks to find one single solution to a problem\nDivergent thinking\nType of thinking that seeks to find multiple solutions to a problem\nTABLE\u00a01.3\nTypes of Problem Solution\nProblem\nDescription\nAlgorithm\nFixed set of rules that lead to the solution of a problem\nHeuristic\nRules of thumb (or procedure) that may or may not lead to the solution of a problem\nwww.allitebooks.com", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 30", "position": 30, "chunk_type": "semantic", "token_estimate": 384}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 7: \u2022\t Synthesize possibilities\n\u2022\t Evaluate solution\n\u2022\t Implement solution\nThe first task of the problem-solving approach involves interpreting the problem. This \nis where problem information is received and processed; problem classification is identi-\nfied (e.g., well-defined, ill-defined) and activities are performed to formulate the problem. Interpreting the problem is a task performed during the initial state of problem solving. During the initial state, identification of stakeholders\u2014persons, groups, or organizations \nthat have direct or indirect stake in the problem and its solution\u2014is essential. Once the \nproblem is formulated, the evaluate constraints task is used to identify external problem con-\nstraints, which are negotiated, integrated, and used to set the bounds on the solution land-\nscape. Once the problem and constraints are well understood, collaborative \u00ad\nbrainstorming \ncan begin among problem solvers and stakeholders. During collaborative brainstorming, \nproblem solvers use mostly divergent thinking to come up with alternative solutions that \nmay bring to light new knowledge, which can trigger a transition back to the problem inter-\npretation task. Once a set of acceptable solutions is identified, problem solvers synthesize \npossibilities to form the acceptable proposed solution to the problem. During this task, prob-\nlem solvers shift from divergent thinking to convergent thinking to propose the best-known \nsolution to the problem. The solution is shared and evaluated by everyone involved in the \nproblem-solving process. Flaws in the solution may trigger a transition back to the collab-\norative brainstorming task; otherwise, implementation begins. Collaborative brainstorming, \nsynthesize possibilities, and evaluate solutions are all tasks performed as part of the opera-\ntional state of problem solving. During implementation, the proposed solution is executed \nuntil the problem is solved, which is a task performed during the goal state of problem solv-\ning. Together, these tasks are combined with other problem variables to provide a holistic \napproach to problem solving (Harrell, Ghosh, and Bowden 2004), as presented in Figure\u00a01.2. As seen in the figure, inputs are items that require processing during problem solving. Inputs come from many different sources and are interpreted and formulated for particu-\nlar problems. They drive all activities by specifying the overarching need that promotes \nthe execution of the problem-solving tasks. Constraints are external properties that come \ninherent with any problem and limit the solution approach. Outputs are the expected \noutcome in problem solving.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 31", "position": 31, "chunk_type": "semantic", "token_estimate": 388}
{"text": "8\u2002 \u2022\u2002 Software Engineering Design\ufeff: time required to solve the problem. Controls, on the other hand, are internal constraints set by \nthe development organization that limit the possible solutions so that they align well with the \norganizational goals and current practices. These controls can dictate when and where prob-\nlem solving takes place, selection of strategies, permitted tools, personnel allowed to engage in \nproblem solving, and measures for quality control. Finally, resources are the means by which \nactivities are performed, which include people, software, and hardware, and their availability, \nwhich all impact problem solving. Together, all of these variables mix together to define the \nproblem-solving landscape, which must be considered when tackling engineering problems. Skill Development 1.1: Using the Holistic Approach in Problem Solving\nUse and document all the steps of the holistic problem-solving approach presented in \nFigure\u00a01.2 to solve the following problem. If possible, do this exercise as a team. The \nproblem specification is as follows: there are six equal matches; connect each match to \nform four equilateral triangles. When done, explain how functional fixedness played a \nrole in preventing you from arriving at the solution to this problem. TABLE\u00a01.4\nProblem-Solving Process Variables\nPhase\nDescription\nActivities\nOne or more tasks identified and required to solve the problem\nResources\nMeans by which activities are performed\nControls\nInternal properties of the organization that place bounds on the solution, or the solution process, \nfor the problem\nEvaluate\nConstraints \nSynthesize\nPossibilities\nInterpret\nProblem\nEvaluate \nInputs \nConstraints \nOutputs \nCollaborative\nBrainstorming\nImplement \nGeneric Design Problem \nResources \nActivities \nControls \nFIGURE 1.2\nHolistic approach to problem solving.", "domains": ["Software Quality Attributes", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 32", "position": 32, "chunk_type": "semantic", "token_estimate": 262}
{"text": "In the previous sections, design was introduced as a systematic and intelligent process for: generating, evaluating, and specifying designs for devices, systems, or processes. To support \nthis process, the problem-solving skill was identified as an essential ingredient for design-\ning complex products. These discussions provided a general perspective on the impor-\ntance of these concepts in the engineering profession. As in other engineering disciplines, \ndesign and problem-solving are crucial to the development of professional, large-scale, \nsoftware systems. Software systems are highly complex, difficult to create, costly to change, \nand\u2014depending on the software product\u2014critical to human safety. Similarly to other \nengineering disciplines, designs in software engineering are used to identify, evaluate, and \nspecify the structural and behavioral characteristics of software systems that adhere to \nsome specification. Software designs provide blueprints that capture how software systems \nmeet their required functions and how they are shaped to meet their intended quality. Formally, software engineering design is defined as\n(1) The process of identifying, evaluating, validating, and specifying the architectural, detailed, \nand construction models required to build software that meets its intended functional and non-\nfunctional requirements; and (2) the result of such process. The term software design is used interchangeably in practice as a means to describe both \nthe process and product of software design. From a process perspective, software design is \nused to identify the phase, activities, tasks, and interrelationship between them required \nto model software\u2019s structure and behavior before construction begins. From a product \ndevelopment perspective, software design is used to identify the design artifacts that result \nfrom the identified phase, activities, and tasks; therefore, these products by themselves, or \ncollectively, are referred to as software design. Design products vary according to several \nfactors, including design perspective, language, purpose, and their capabilities for evalu-\nation and analysis. For example, designs can be in architectural form, using architectural \nnotations targeted for specific stakeholders. These types of design can be presented using \nblock diagrams, Unified Modeling Language (UML) diagrams, or other descriptive form \nof black-box design documentation. In other cases, design can be in detailed form, where \na more white-box representation of the system is used to model structural and behavioral \naspects. These can include software models that contain class diagrams, object diagrams, \nsequence diagrams, or activity diagrams. Other design products include models that rep-\nresent interfaces, data, or user interface designs.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 33", "position": 33, "chunk_type": "semantic", "token_estimate": 389}
{"text": "In the previous sections, design was introduced as a systematic and intelligent process for: These can include software models that contain class diagrams, object diagrams, \nsequence diagrams, or activity diagrams. Other design products include models that rep-\nresent interfaces, data, or user interface designs. Due to the many ways software design is \nused in practice, a common pitfall in software engineering projects is to associate design \nwith a particular type of design artifact, therefore neglecting other forms of design or the \nactivities required to create complete and correct software designs. Collectively, both pro-\ncess and products, including all variety of design products, are considered software design \nand are essential in most professional software projects.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 33", "position": 33, "chunk_type": "semantic", "token_estimate": 114}
{"text": "10\u2002 \u2022\u2002 Software Engineering Design\ufeff: WHY STUDY SOFTWARE ENGINEERING DESIGN? On February 25, 1991, a software error on the Patriot missile defense system operating \nduring operation Desert Storm caused it to fail to track and intercept an incoming Scud, \nwhich resulted in the death of 28 Americans (GAO, 1992). In 1996, a software error caused \nthe Ariane 501 satellite launch to fail catastrophically, resulting in a direct cost of approx-\nimately $370 million (Dowson 1997). The software error that caused Ariane 501 to fail \ncould be attributed to its software design. Similarly, the literature is swamped with many \nexamples of disastrous results of software-based products. The reason for many of these \ndisasters is that developing high-quality software on time and within budget is a daunting \ntask. From the outset, the landscape for software development projects is plagued with a \nvariety of challenges that increase complexity in software projects. Software design plays \nan integral part in managing the complexity and the challenges encountered in any soft-\nware development effort. During the software design phase, the system is decomposed to allow optimum develop-\nment of the software; requirements are mapped to conceptual models of the operational \nsoftware; roles are assigned to software teams on the same or remote sites; well-known \ninterfaces for software components are created; quality attributes are addressed and \nincorporated into the design of the system; the user interface is created; the software\u2019s \ncapability is analyzed; function and variable names are identified; design documentation \ngoals are established; and the foundation for the rest of the software engineering life cycle \nis established. Given its impact on the creation and management of software products, \n\u00ad\nmastering software design becomes essential to successfully engineer software products. The reasons for studying software engineering design can be described using a product \ndevelopment perspective and a project management perspective. Reasons for Studying Software Design in Product Development\nFrom the product development view, studying software design is important because \ndesigns form the foundation for all other software construction activities. Software designs \nallow software engineers to create models that represent the structure and behavior of \nthe software system. Through these models, the main components and their interconnec-\ntion for the solution are identified. Characteristics of quality code, such as modularization, \ncohesiveness, and coupling, are all born in the design phase. For complex tasks, abstrac-\ntions and encapsulation are used in software design as means to provide a systematic \napproach for problem solving.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 34", "position": 34, "chunk_type": "semantic", "token_estimate": 404}
{"text": "10\u2002 \u2022\u2002 Software Engineering Design\ufeff: Characteristics of quality code, such as modularization, \ncohesiveness, and coupling, are all born in the design phase. For complex tasks, abstrac-\ntions and encapsulation are used in software design as means to provide a systematic \napproach for problem solving. In addition, software designs are reusable; therefore, they \ncan be applied to different projects to provide ready-made solutions to common problems. Software design also provides the means to evaluate and incorporate the quality attributes \nnecessary for software systems. Therefore, issues such as performance, usability, portabil-\nity, and security can all be addressed early on in the development project. These benefits \nare carried over to all other subsequent phases of the software development life cycle and \nhave direct impact on the implementation, testing, and maintenance phase.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 34", "position": 34, "chunk_type": "semantic", "token_estimate": 129}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 11: Reasons for Studying Software Design in Project Management\nManaging software projects characterized by changing requirements, tight schedules, cost \nconstraints, and high expectations for software quality is tough. Among these, require-\nment changes are common drivers for all other project characteristics. This means that, \nas requirements change, projects should expect some impact in their cost, schedule, and \nquality. In some cases, requirement changes can easily translate to extended schedules \nand increased cost; in others, where schedules are not extended, requirement changes \ntranslate to decreased software quality. Good software design can minimize (or counter) \nthe effects of requirements volatility in managing software projects. From the manage-\nment\u2019s point of view, software design is important because it helps accommodate changes \nto the requirements or system updates, therefore minimizing impact on schedule, cost, \nand quality. In\u00a0addition, good software design increases efficiency in human resource \nallocation tasks. By decomposing the software into independent units, resources can be \nassigned to software components so that they can be built in parallel in the same or dif-\nferent construction sites, therefore having significant impact on software schedules and \ncost. By compartmentalizing the design, the effects of unwanted employment attrition \n(i.e.,\u00a0employees leaving the company) can also be minimized, since new employees need \nonly to take on the individual design component assigned to that employee. Good soft-\nware designs provide an efficient mapping of customer requirements to software solu-\ntions, therefore facilitating requirements tracing throughout the design. Having a strong \ngrasp on software design helps management abstract project tasks and acquire better \nappreciation of the work to be done. Overall, having a strong grasp in software design \nhelps management improve the project planning, organization, staffing, and tracking and \nprovide overall guidance for the project.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 35", "position": 35, "chunk_type": "semantic", "token_estimate": 293}
{"text": "Today, the software design phase has evolved from an ad hoc and sometimes overlooked: phase to an essential phase of the development life cycle. Furthermore, the increasing com-\nplexity of today\u2019s systems has created a set of particular challenges that makes it hard for soft-\nware engineers to meet the continuous customer demand for higher software quality. These \nchallenges have prompted software engineers to pay closer attention to the design process \nto better understand, apply, and promulgate well known design principles, processes, and \nprofessional practices to overcome these challenges. Some of the major challenges include \nrequirements volatility, design process, quality issues (e.g., performance, usability, secu-\nrity), distributed software development, efficient allocation of human resources to devel-\nopment tasks, limited budgets, unreasonable expectations and schedules, fast-changing \ntechnology, and accurate transformation from software requirement to a software product. A brief discussion of these challenges is presented next.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 35", "position": 35, "chunk_type": "semantic", "token_estimate": 145}
{"text": "12\u2002 \u2022\u2002 Software Engineering Design\ufeff: Design Challenge 1: Requirements Volatility\nA major reason for the complexity of software projects is the constant change of require-\nments. When designed properly, software can be modified or extended easily; however, when \ndesigned poorly, modifying software can become overwhelming and lead to all sorts of com-\nplex problems. Unlike the development of computer hardware, bridges, houses, or mechanical \nparts, software\u2019s very own nature allows itself to change to provide different or new function-\nality to systems. This same trait that makes software so desirable is what makes it also so com-\nplex. Although much effort is put into the requirements phase to ensure that requirements are \ncomplete and consistent, that is rarely the case; leaving the software design phase as the most \ninfluential one when it comes to minimizing the effects of new or changing requirements. Requirements volatility is challenging because they impact future or current development \nefforts. This forces designers to create designs that provide solutions to problems at a given \nstate while also anticipating changes and accommodating them with minimal effort. This \nrequires designers to have a strong understanding of the principles of software design and \ndevelop skills to manage complexity and change in software development. Design Challenge 2: Process\nSoftware engineering is a process-oriented field. Software processes allow engineers to \norganize the steps required to develop software solutions with schedule and cost constraints. Therefore, at the core of every software development company, there should be a sound, \nwell-understood, and consistent process for software development. Processes can also be devel-\noped and customized for particular phases of the software engineering life cycle. In the design \nphase, software processes involve a broad set of activities and tasks that bridge the gap between \nrequirements and construction while adhering to a set of project-specific (or company-specific) \nconstraints. These activities include common ones, such as architectural and detailed design, \nas well as other supporting activities. These supporting activities include establishing a design \nreview process, defining design quality evaluation criteria, evaluating design reuse, estab-\nlishing design change management and version control procedures, adopting design tools, \nand allocating resources. In many cases, a company\u2019s design process is not well established, \nis poorly understood, or is approached with minimalistic expectations that ignore aspects \nthat are essential to executing a successful design phase.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 36", "position": 36, "chunk_type": "semantic", "token_estimate": 383}
{"text": "12\u2002 \u2022\u2002 Software Engineering Design\ufeff: These supporting activities include establishing a design \nreview process, defining design quality evaluation criteria, evaluating design reuse, estab-\nlishing design change management and version control procedures, adopting design tools, \nand allocating resources. In many cases, a company\u2019s design process is not well established, \nis poorly understood, or is approached with minimalistic expectations that ignore aspects \nthat are essential to executing a successful design phase. Focusing design efforts on creating \n\u00ad\nindependent software products, such as a simple class diagram or user interface, while ignoring \nother design activities may create complexities later on during system\u2019s test and maintenance. The design process is challenging because essential design process activities are often over-\nlooked, done in an ad hoc manner, or simply not done at all. In many cases, a well-established \nand well carried out design process serves an indication of future project\u2019s success. Design Challenge 3: Technology\nSoftware is meant to be everywhere. From health-care systems and education to defense \nand everyday ubiquitous devices, software is required to operate on a massive and always", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 36", "position": 36, "chunk_type": "semantic", "token_estimate": 177}
{"text": "14\u2002 \u2022\u2002 Software Engineering Design\ufeff: and its external influences, such that external factors affect the development of the system \nand the system affects its external factors (Bass, Clements, and Kazman 2003). Managing \nthese influences is essential for maximizing the quality of systems and their related influ-\nence on future business opportunities. Of specific importance are design influences that \ncome from the system stakeholders and its developing organization. Stakeholders\nDesigning software is a nondeterministic activity. If given the same task to different \ndesigners, different solutions will be proposed, each of them being perfectly acceptable \n(McConnell 2004). Now add to the mix the multitude of influences that come from dif-\nferent stakeholders, and you can easily get a variety of design alternatives for meeting a \nvariety of stakeholders\u2019 concerns, all conflicting with each other. This creates a challenge \nwhen trading off design alternatives that meet all stakeholders concerns. Making such \ndesign trade-offs is difficult, especially on large-scale design efforts. Consider a project \nwith multiple customers, each with conflicting goals affecting design decisions. In such \nprojects, creating a design that sacrifices some desired customer capability but provides \nother desired properties, such as quick time-to-market, reliability, or lower cost, can lead \nto the development of a high-quality system that maintains acceptable levels of satisfaction \namong stakeholders. This is an example of how stakeholders affect design decision, and the \ndesign, in turn, influences the stakeholder goals (Bass et al. 2003). Managing \u00ad\nstakeholders\u2019 \ninfluences is challenging because it requires designers to exert a high-level of communica-\ntion, negotiation, and technical skills to ensure that design decisions are made to accom-\nmodate all concerns without negatively affecting the project. Development Organization\u2019s Structure\nThe development organization\u2019s structure influences the development of software prod-\nucts, in particular, the design of those products. As example, consider the case of distrib-\nuted software engineering. In today\u2019s global market, more and more cases of distributed \nsoftware development are taking place. A wide variety of reasons exist for developing soft-\nware at different sites. Consider companies that have sites in multiple states, where various \nlevels of domain expertise are found at different sites. Or consider the case of software \nengineers resigning, creating a gap in the development team that is hard to fill with local \nresources. Finally, consider companies that simply want to reduce cost by hiring software \nengineers from different countries. These and many other reasons exist for having devel-\nopment across site boundaries.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 38", "position": 38, "chunk_type": "semantic", "token_estimate": 403}
{"text": "14\u2002 \u2022\u2002 Software Engineering Design\ufeff: Finally, consider companies that simply want to reduce cost by hiring software \nengineers from different countries. These and many other reasons exist for having devel-\nopment across site boundaries. In each of these cases, the structure of the development\u2019s \norganization makes it complicated to, for example, coordinate design efforts, evaluate and \ndiscuss design alternatives, conduct peer reviews, and manage version control. In these \ncases, designers need to consider not only technical aspects of the design but also the dis-\ntribution of employees, organizational goals, resource availability, and so forth. Designs \nthat support integration of distributed expertise across sites can introduce capabilities for \nbuilding new software products that could not be engineered otherwise. This in turn can", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 38", "position": 38, "chunk_type": "semantic", "token_estimate": 121}
{"text": "In today\u2019s modern software systems, software design plays a key role in the development of: software products; however, it is only one phase of the complete software engineering life \ncycle. To understand how design fits within the whole software engineering process, it is \nnecessary to provide the appropriate context so that clear distinctions can be made between \nthe different life cycle phases and an appreciation of the importance of software design \nactivities and tasks can be acquired. For this reason, an overview of software engineering \nand its life cycle is required. Software engineering is defined by the IEEE (1990, p. 67) as\n(1) The application of a systematic, disciplined, quantifiable approach to the development, \noperation, and maintenance of software; that is, the application of engineering to software. (2) The study of approaches as in (1). The fundamental software engineering life cycle phases include requirements, design, \nconstruction, test, and maintenance, as presented in Table\u00a01.5. The requirements phase is where stakeholders are identified and customer needs, wants, \nand the (often overlooked) nonfunctional requirements are determined (Laplante 2009). During this phase, requirements are analyzed in their raw form to address issues such as \nrequirements that don\u2019t make sense, contradict each other, or are incomplete, vague, or \njust wrong (Laplante 2009); requirements are classified and prioritized; and the specifica-\ntion of the software system, which typically results in the production of a document, or \nits electronic equivalent is reviewed and validated (Abran, Moore, Bourque, and Dupuis \nTABLE\u00a01.5\nFundamental Software Engineering Phases\nPhase\nDescription\nRequirements\nInitial stage in the software development life cycle where requirements are elicited, analyzed, \nspecified, and validated\nDesign\nThe requirement\u2019s specification is used to create the software design, which includes its \narchitecture and detailed design\nConstruction\nRelies on the requirements\u2019 specification, the software architecture, and detailed design to \nimplement the solution using a programming language; a great deal of design can also \noccur at this phase\nTest\nEnsures that the software behaves correctly and that it meets the specified requirements\nMaintenance\nModifies software after delivery to correct faults, improve performance, or adapt it for a \ndifferent environment", "domains": ["Software Quality Attributes", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 39", "position": 39, "chunk_type": "semantic", "token_estimate": 348}
{"text": "16\u2002 \u2022\u2002 Software Engineering Design\ufeff: 2005). Once the requirements for the system are specified, designing the system takes \nplace, which is the main topic of this book. The construction phase begins once the design phase has been executed and all require-\nments can be traced to a section of the software design models. The construction phase is \nwhere designs are implemented using the programming language of choice. In this phase, \ncode is generated according to a style guide. In addition, the code is unit tested, debugged, \nand peer-reviewed; programming errors are detected, tracked, and resolved; code is man-\naged by using change management and version control software; and, finally, code is pre-\npared for delivery using a predefined set of conventions for formatting. The construction \nphase is tightly related to the design phase and in some cases (typically on smaller projects) \nthe line dividing both phases can be hard to identify. There are several reasons for this, \nthe main one being that detailed designs can be directly translated to code; therefore, soft-\nware engineers tend to design and code at the same time. In other cases, where design and \nconstruction are clearly delineated by the process, it is common for some construction \ntasks, such as identifying appropriate class, function, and variable names, to be performed \nduring detailed design. Finally, because many discoveries made well into the construction \nphase give rise to functionality that requires design work, engineers must iterate back and \nforth between construction and design activities. Once all the design artifacts are imple-\nmented with programming and all assigned requirements can be validated through execu-\ntion of code during unit testing, the construction phase is complete. The testing phase is typically the final step before the software goes out the door. The\u00a0main \npurpose of the testing phase is to verify and validate the software to ensure that it meets \nthe predefined functions and level of quality defined in the software requirement\u2019s phase. Formally, the IEEE (1990, p. 76) defines testing as\n(1) The process of operating a system or component under specified conditions, observing or \nrecording the results, and making an evaluation of some aspect of the system or component. (2) The process of analyzing a software item to detect the differences between existing and \nrequired conditions (that is, bugs) and to evaluate the features of the software item. The software testing phase serves as a gateway between product development and product \nrelease.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 40", "position": 40, "chunk_type": "semantic", "token_estimate": 405}
{"text": "16\u2002 \u2022\u2002 Software Engineering Design\ufeff: (2) The process of analyzing a software item to detect the differences between existing and \nrequired conditions (that is, bugs) and to evaluate the features of the software item. The software testing phase serves as a gateway between product development and product \nrelease. Therefore, verification and validation efforts need to be made to ensure that the soft-\nware meets the specification and the integrity of the software can be assured under normal \nand harsh conditions. It is important to note that no desired quality attribute can be verified \nduring testing if it hasn\u2019t been designed into the product first. Therefore, even though test-\ning is typically credited for ensuring product quality, design is fundamental in supporting a \nsuccessful testing phase. Once software is delivered, the maintenance phase begins to imple-\nment corrections, adaptations, or improvements to the software. Corrections are typically \nmade on a smaller scale to rectify faulty behavior or output of the software. These typically \ndo not require design work. However, for adaptations or improvements, design work may \nbe required to accommodate the changes. Together, all phases of the software engineering \nlife cycle work together to define the functions that the software must provide, to transform \nthese functions into technical solutions, to implement those solutions, and to validate their \nimplementation and ensure the quality of the system throughout future versions. www.allitebooks.com", "domains": ["Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 40", "position": 40, "chunk_type": "semantic", "token_estimate": 228}
{"text": "In the previous section, the design phase was briefly mentioned as a means for determin-: ing its place within the software engineering process. However, as it will be seen, the design \nphase incorporates many activities and tasks conducted by different teams and typically \nmanaged by personnel other than designers. This requires a formal process to ensure that the \ndesign phase is conducted properly and that it addresses all the concerns identified for the \nsoftware system being built. Many processes exist to carry out phases, activities, and tasks \nthroughout the software engineering life cycle, including the unified process (UP), Scrum, \nand the dynamic systems development method (DSDM) (Pressman 2010). What follows is \na discussion on the software design process in terms of the fundamental activities and tasks \nrequired to build software products. These activities and tasks are essential and typically built \ninto other formal processes such as the ones already mentioned. The hope is that by plac-\ning more emphasis on the fundamental activities and tasks and less on particular process \napproaches readers can obtain a more concise and understandable coverage of the topic. In today\u2019s professional software engineering landscape, software engineers are being \nasked to build larger and more complex software systems in the same or different sites. Therefore, both design processes and artifacts are increasing in complexity. This means that \nit is not enough to know how to model structural and behavioral aspects of the system in \nthe design phase, but it is also essential that software designers know about the particular \nprocess (e.g.,\u00a0UP, Scrum) required to manage, create, and control software design activities. Sommerville (2010) defines a software process as a set of activities that lead to the production \nof a software product. Similarly, a software design process is a set of activities and controls \nthat specify how resources work together for the production of software design artifacts. The software engineering body of knowledge identifies two major activities for software \ndesign: software architecture and detailed design (Abran et al. 2005). These are the essential \nactivities for managing the complexity involved in developing large-scale software systems. However, numerous other important activities are required for supporting the creation of \narchitectural and detailed designs. Therefore, when planning and identifying an appropri-\nate software design process, the effort required for these activities needs to be considered.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 41", "position": 41, "chunk_type": "semantic", "token_estimate": 385}
{"text": "18\u2002 \u2022\u2002 Software Engineering Design\ufeff: phase and span through the design phase; in others, it begins after the requirements are \nspecified and validated. In a similar fashion, the detailed design activity can start at the \nproject\u2019s design phase and span through the software construction phase. These scenarios \nare highly project dependent; therefore, following to a strict waterfall-like process for soft-\nware development is impractical for all but the simplest software applications. Software Architecture\nThe software architecture activity corresponds to a macrodesign approach for creating \n\u00ad\nmodels that depict the quality and function of the software system. It provides black-box \nmodels used to evaluate the system\u2019s projected capabilities as well as its expected quality, \nall from multiple perspectives. Therefore, architectural designs allow different \u00ad\nstakeholders, \nwith different backgrounds and expertise, to evaluate the design and ensure that the software \nSoftware Design \nManagement \nDocumentation \nDetailed Design:\nInterface Design\nComponent Design\nConstruction Design:\nFlow-Based Design\nTable-Based Design\nSoftware\nRequirements\nSoftware\nConstruction\nSoftware Architecture:\nArchitectural Views\nArchitectural Patterns\n\u2026\n\u2026", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 42", "position": 42, "chunk_type": "semantic", "token_estimate": 166}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 19: architecture is addressing their concerns. For example, from the systems engineering per-\nspective, architectural designs can provide information about the physical deployment of \nthe system, including subsystems located at different locations, the artifacts executing in \nthe subsystems, and how the system as a whole communicates. From the configuration \nmanagement perspective, architectural designs can provide information about the hier-\narchy of files in the file system and how these files are interconnected to build and deploy \nthe software system. From the software engineering perspective, different architectural \ndesigns can help decompose the software and define the major structural components of \nthe system, identify interfaces between the components, map the requirements to them, \nevaluate concurrency issues, and provide overall insight into the design solution. A major \nbenefit of architectural designs is their capacity to evaluate high-level concerns from stake-\nholders that deal mostly with nonfunctional requirements (e.g., performance, usability, \nsecurity). For these purposes, architectural designs serve as important communication, \nreasoning, and analysis tools that support the development and growth of the systems \n(Bass et al. 2003). Software architecture lays the foundation for all subsequent work in the \nsoftware engineering life cycle. Detailed Design\nThe detailed design step begins after the software architecture is specified, reviewed, and \ndeemed sufficiently complete for detailed design to begin. The detailed design activity \nbuilds on the software architecture to provide white-box design elements of the \u00ad\nstructure \nand behavior of the software system and in many cases is the last major effort before \n\u00ad\nsoftware construction begins. Detailed design is the activity that deals with refining the \nsoftware architecture to reach a point where the software design, including architecture \nand detailed design, is deemed sufficiently complete for construction to begin. Whereas the \nsoftware architecture places a major emphasis on quality (nonfunctional requirements), \nthe detailed design activity places a major focus on addressing functional requirements of \nthe system. In object-oriented systems, the detailed design activity is where components \nare refined into one or more classes, interfaces are realized, relationships between classes \nare specified, class functions and variable names are created, design patterns are identified \nand applied, and, if applicable, design tools are configured for code generation. Two major \ntasks of the detailed design activity are interface design and component design. Interface Design\nInterface design refers to the design activity that deals with specification of interfaces \nbetween components in the design (Sommerville 2010).", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 43", "position": 43, "chunk_type": "semantic", "token_estimate": 400}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 19: Two major \ntasks of the detailed design activity are interface design and component design. Interface Design\nInterface design refers to the design activity that deals with specification of interfaces \nbetween components in the design (Sommerville 2010). Interface design can be focused \non specifying the interfaces used internally within software components or externally \nacross software components. In both cases, interfaces provide a standardized way for spec-\nifying how services are accessed and provided by software components. Interface design \nallows subsystems to be designed independently and in parallel; therefore, it is typically \none of the first tasks performed as part of the detailed design. Other forms of interface", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 43", "position": 43, "chunk_type": "semantic", "token_estimate": 113}
{"text": "20\u2002 \u2022\u2002 Software Engineering Design\ufeff: design specify communication between systems, for example, custom binary or Extensible \nMarkup Language (XML) messaging specifications used for communication between two \nor more subsystems through the network. Component Design\nDuring architecture, the software system is decomposed into logical components that \nabstract required system functions. During detailed design, these logical components are \nrefined and their interactions are modeled to verify the validity of their structural compo-\nsition. The execution of the detailed design activity requires a shift from the macrodesign \napproach to the microdesign approach to further decompose and refine system components \ninto one or more fine-grained elements, functions, and data variables required for support-\ning the internal structure and behavior of components that meet assigned roles during the \nsoftware architecture activity. Component design refers to modeling the internal\u00a0structure\u00ad\n \nand behavior of components\u2014which includes the internal structure of both logical and \nphysical components\u2014identified during the software architecture phase. During this \nactivity\u00ad\n, fine-grained components are derived from the architecture, and their internal \nstructure and behavior are designed. Components are not limited to object-oriented \n\u00ad\nsystems; therefore, component designs can be realized in many ways. In\u00a0object-oriented \nsystems, the internal structure of components is typically modeled using UML through \none or more diagrams, including class and sequence diagrams. When modeling the inter-\nnal structure of components, several design principles, heuristics, and patterns are used to \ncreate and evaluate component designs. Construction Design\nThe idea of the detailed design activity is to get as close to the solution as possible without \nbeginning the construction phase. In many cases, in object-oriented systems, this amounts \nto identifying classes, their attributes and functions, and interrelationships with other \nclasses. These tasks are done while abstracting and deferring details of implementation to \nthe construction phase. In some cases, however, implementing complex software functions \nidentified during the detailed design activity requires additional design work to ensure they \nwork properly and maintain the quality standards sought during the software architecture \nactivities. In these cases, construction design is necessary. Construction design is not a new \nconcept. Many other authors have proposed it as an important design activity. For example, \nMcConnell (2004) specifies five levels of software design; one of them, being at the lowest \nlevel, deals with internal routine design.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 44", "position": 44, "chunk_type": "semantic", "token_estimate": 375}
{"text": "20\u2002 \u2022\u2002 Software Engineering Design\ufeff: Many other authors have proposed it as an important design activity. For example, \nMcConnell (2004) specifies five levels of software design; one of them, being at the lowest \nlevel, deals with internal routine design. Similarly, Fox (2006) identifies a form of low-level \ndesign that fills the gap between detailed design and programming and deals with issues \nsuch as operation specification, including operation name, parameter types, and return \ntypes among others. Other authors, such as Meyers (2005), have highlighted the impor-\ntance of designing code at low levels, during construction. Construction design is the last \ndesign activity\u2014typically conducted during the construction phase\u2014required to support \nthe \u00ad\nsystem\u2019s quality attributes, such as performance, maintainability, and testability.", "domains": ["Software Quality Attributes", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 44", "position": 44, "chunk_type": "semantic", "token_estimate": 119}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 21: Human\u2013Computer Interface Design\nThe human\u2013computer Interface (HCI) design activity is where general principles are applied \nto optimize the interface between humans and computers. Visual designs have a major role \non the success or failure of software systems. Systems that meet functional requirements \nbut that are not usable cannot succeed. The HCI design activity can be executed in paral-\nlel to the software architecture or detailed design activities. In some cases, HCI design is \nconsidered an architectural task, while in others it is considered a detailed design task. Regardless of where HCI design fits within design processes adopted by specific organiza-\ntions, it is a major design activitiy that requires careful attention. The major concerns of \nthe HCI designs may include the evaluation and use of modes, navigation, visual designs, \nresponse time and feedback, and design modalities, such as forms and menu-driven. HCI \ndesigns directly influence the quality of any system and are essential to understanding and \naddressing the factors that affect the overall usability of the system. Many design principles \nand evaluation techniques exist to succesfully design user interfaces. Software Design Documentation\nSimilar to the specification activity of the requirements phase, software design documen-\ntation, also known as software design description (SDD), plays a big role in professional, \nlarge-scale, or software-intensive systems. Its importance is specified by the IEEE (1998, \np.\u00a0iii) as follows:\nSDDs play a pivotal role in the development and maintenance of software systems. During \nits lifetime, a given design description is used by project managers, quality assurance staff, \n\u00ad\nconfiguration managers, software designers, programmers, testers, and maintainers. Each \nof these users has unique needs, both in terms of required design information and optimal \norganization of that information. Hence, a design description must contain all the design \n\u00ad\ninformation needed by those users. SDD should include the necessary information that properly captures the design of \nthe system. As part of this activity, other issues such as tools for generating design docu-\nments, validation, and configuration management must be addressed. The software design \n\u00ad\ndocumentation activity typically begins at the design phase and continues throughout the \n\u00ad\nlifetime of the software system. Software Design Management\nManagement plays a big role in software engineering projects.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 45", "position": 45, "chunk_type": "semantic", "token_estimate": 373}
{"text": "From the discussions provided so far, it should be evident that designers are not all equal.: In many design efforts, designers have different roles, with different titles and responsibili-\nties that focus on specific design problems of the software system. There are many factors \nin place that determine the designer\u2019s role, including an engineer\u2019s work preference, expe-\nrience, and capabilities. When studying software design, it is important to understand \nhow these roles differ, the type of work performed, and capabilities required to perform \nthe activities required of each role. In some cases, software designers are heavily involved \nin the requirements and construction phases; therefore, they must have expertise not \nonly in design but also in requirements engineering and software construction. In other \ncases, a clear organizational delineation exists, allowing designers to focus on their area \nof \u00ad\nexpertise. A\u00a0list of typical designer roles is presented in Table\u00a01.6 (Giachetti 2010). TABLE\u00a01.6\nTypical Roles in Software Design\nDesigner\nDescription\nEnterprise architect\nDesigns the enterprise\u2019s strategy, processes, information, and organizational \nstructure\nSoftware architect\nDesigns software systems using a black-box modeling approach; concern is placed \non the external properties of software components that determine the system\u2019s \nquality and support the further design of functional requirements\nComponent designer\nFocuses on designing the internal structure of software components identified \nduring the software architecture phase; has strong programming skills\nUser Interface designer\nDesigns the software\u2019s user interface; skilled in determining ways that increase \nusability of the system\nSystem engineer\nDesigns systems using a holistic approach, which include designing how software \nand hardware collaborate to achieve the system\u2019s goals", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 46", "position": 46, "chunk_type": "semantic", "token_estimate": 264}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 23: Systems Engineer\nThe systems engineer designs the overall development process of systems as a whole, \nincluding processes for development of both the software and hardware that are part of the \nsystem. As a specialization of system engineering, software systems engineers design soft-\nware at the system level; in many cases, the work performed by software systems engineers \nis similar to that of a software architect. Systems engineers work closely with customers to \nprovide a holistic view of systems, their interfaces, and the distribution of requirements \nto subsystems. Software systems engineers are typically experts in the problem domain, \nand, depending on the type of system (e.g., embedded, web), they also develop expertise \non other nonsoftware-related parts, such as hardware, communications, and avionics. This \nis essential at all phases of the software development process, since they must be able to \ncommunicate with other engineering disciplines, such as electrical, mechanical, and civil. In this role, designers have typically accumulated experience in other design roles, such as \nsoftware architecture, component design, and in some cases construction. In addition to \ntechnical skills, systems engineers are required to have strong leadership skills to ensure \nthe successful system development. Software Architect\nThe software architect is in charge of designing the software architecture. Software architects \ncan be found under a wide variety of titles, such as software lead, senior software engineer, \nor principal software engineer. Regardless of the title, software architects have extensive \nexperience architecting systems that meet their intended requirements. Experience is typi-\ncally acquired while moving up through the ranks, from software programmer all the way \nup to software architect. Software architects have strong leadership skills and are required \nto be skilled in initiation, communication, and negotiation. They also need to have a keen \nunderstanding of the developing organization to determine ways software systems can \ninfluence the organizational business goals and increase new business ventures leveraged \nfrom existing architectures. Other skills beneficial to software architects include project \nmanagement skills. Component Designer\nComponent designers are highly noticeable during detailed and construction designs, \nsince they are typically the ones constructing the software. Therefore, they have strong \nprogramming skills and a strong foundation in design principles. For object-oriented com-\nponent designers, strong object-oriented skills including knowledge of design patterns are \nessential.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 47", "position": 47, "chunk_type": "semantic", "token_estimate": 379}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 23: Therefore, they have strong \nprogramming skills and a strong foundation in design principles. For object-oriented com-\nponent designers, strong object-oriented skills including knowledge of design patterns are \nessential. Component designers create both static and dynamic models of the software \nsystem at levels appropriate to drive \u00ad\nconstruction; these include (when applicable) UML \nclass diagrams and sequence diagrams. They have deep knowledge and understanding of \nthe software requirements assigned to them; they are knowledgeable about other tools that \nsupport the design and development effort, such as modeling tools, integrated development", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 47", "position": 47, "chunk_type": "semantic", "token_estimate": 96}
{"text": "24\u2002 \u2022\u2002 Software Engineering Design\ufeff: environments, forward and reverse \u00ad\nengineering, and configuration management. When \ndesigning at the component level, component designers have a full understanding of style \nguides for the project, since they dictate \u00ad\nnaming, spacing, and commenting conventions \nand other aspects that shape the structure of code. Component designers devise construc-\ntion designs as needed and are proficient at creating effective unit tests that verify the \nquality of their product developed. Finally, component designers need to be comfort-\nable scheduling and conducting peer reviews and accepting feedback and evaluating it \n\u00ad\nobjectively to improve their designs.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 48", "position": 48, "chunk_type": "semantic", "token_estimate": 99}
{"text": "Within the design process, many principles, considerations, and strategies help designers: execute the software design process in an effective and consistent manner. For the most \npart, these help designers manage and simplify problems, consider the impacts of their \nproposed solutions, and establish a foundation for decision making during design. In this \ncontext, design principles refer to knowledge matter that has been found effective through-\nout the years in multiple projects on different domains. Design principles are applicable on \nmost design projects; therefore, their use is expected to help achieve high-quality designs. On the other hand, design considerations are recommendations that help designers in the \ndesign process; they may or may not be followed. Finally, design strategies consist of tacti-\ncal approaches in which design principles and considerations can be employed to drive the \ndesign process. These concepts are further discussed in the next sections. General Software Design Principles\nThroughout the history of software engineering, many design principles have emerged \nto become fundamental drivers for decision making during the software design process. These design principles are used as a basis for reasoning and serve as justification for almost \nall design decisions. They also provide designers with a foundation from which other more \nsophisticated design methods can be applied (Pressman 2010). These principles are not \nspecific to any particular design strategy (e.g., object oriented) or process, so they are fun-\ndamental to all software design efforts and can be applied during architectural, detailed, \nand construction designs. The principles include (Abran et al. 2005):\n\u2022\t Modularization\n\u2022\t Abstraction\n\u2022\t Encapsulation\n\u2022\t Coupling and cohesion\n\u2022\t Separation of interface and implementation\n\u2022\t Sufficiency and completeness", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 48", "position": 48, "chunk_type": "semantic", "token_estimate": 271}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 25: Modularization\nModularization is one of the most important (and perhaps oversimplified) design prin-\nciples in software design. Modularity allows software systems to be manageable at all levels \nof the development life cycle. That is, the work products of the requirements, design, con-\nstruction, and testing efforts can all be modularized to efficiently carry out the operations. In\u00a0the design phase, modularization is the principle that drives the continuous decompo-\nsition of the software system until fine-grained components are created. Modularization \nplays a key role during all design activities, including software architecture and detailed \nand construction design; when applied effectively, it provides a roadmap for software \ndevelopment starting from coarse-grained components that are further modularized into \nfine-grained components directly related to code. If applied properly, modularization can \nlead to designs that are easier to understand, resulting in systems that are easier to develop \nand \u00ad\nmaintain. Efficient modularization can be achieved by following and applying the \nprinciples of abstraction and encapsulation. With proper modularization, software systems \ncan be decomposed into modules that allow the system\u2019s complexity to be manageable and \nallow the system to be efficiently built, maintained, and reused. Abstraction\nWhile the principle of modularization specifies what needs to be done, the principle of \nabstraction provides the guidance as to how it should be done. Modularizing systems in \nan ad hoc manner leads to designs that are incoherent, hard to understand, and hard to \nmaintain. To modularize intelligently, a thorough understanding of abstraction is required \n(Liskov and Guttag 2010). Abstraction is the principle that deals with creating conceptual \nentities required to facilitate problem solving by focusing on essential characteristics of \nentities\u2014in their active context\u2014while deferring unnecessary details. When abstraction \nis applied, the level of detail required to think about a problem is adjusted to productively \nmodularize a system; this allows for the creation of coherent entities that can be used to \nrepresent their possible variations in the problem\u2019s context and domain. The principle of \nabstraction can be applied iteratively at multiple levels during the design phase. At the soft-\nware architecture level, abstraction helps during the identification of software components \nand their interfaces. At the detailed design phase, abstraction helps identify the entities, \nfunctions, and interfaces required to realize the component\u2019s provided services. At the \nconstruction level, abstraction helps in the further design of functions identified during \ndetailed design.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 49", "position": 49, "chunk_type": "semantic", "token_estimate": 396}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 25: At the detailed design phase, abstraction helps identify the entities, \nfunctions, and interfaces required to realize the component\u2019s provided services. At the \nconstruction level, abstraction helps in the further design of functions identified during \ndetailed design. In all of these, abstraction is used to facilitate problem-solving by defer-\nring details to later stages. The principle of abstraction can be classified as (Pressman 2010):\n\u2022\t Procedural abstraction\n\u2022\t Data abstraction\nProcedural abstraction is a specific type of abstraction that simplifies behavioral \n\u00ad\noperations containing a sequence of steps or other procedural abstractions. For example,", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 49", "position": 49, "chunk_type": "semantic", "token_estimate": 100}
{"text": "26\u2002 \u2022\u2002 Software Engineering Design\ufeff: consider a client\u2013server application in which the client sends data to the server through \nthe Internet. In this case, the Send procedural abstraction can be used to denote a series \nof operations, for example, retrieving the server\u2019s information (e.g., Internet Protocol [IP] \naddress, port number), opening a connection, sending the message, and closing the con-\nnection. On the other hand, data abstraction is used to simplify the structural composition \nof data objects. Using the previous example, the Message data abstraction can be used to \nrepresent various messages with different attributes, such as the message\u2019s ID, content, and \nformat. The definition of all of these properties can be deferred to later stages. Abstraction \nis fundamental for managing complexity in all activities of the software design phase. Skill Development 1.2: The Abstraction Principle\nThe world is full of abstractions; without abstractions, communicating with our peers \nwould be much more difficult. As an exercise, look for the nearest rectangular object \nthat contains a knob and (maybe) a keyhole; if the object is blocking an entrance, \nchange the state of the object so that it no longer blocks the entrance. Summarize this \nscenario by coming up with two abstractions: one data and the other procedural to \nincrease communication with peers. When done, create a list of four other abstractions \nthat surround you, and provide an abstraction as well as the detailed object description \nthat would be required if the abstraction is not used. Ensure that there are two data \nabstractions and two procedural abstractions. Encapsulation\nIn previous sections, modularization is presented as principle for decomposing mono-\nlithic systems into manageable units. While abstraction provides the principle for guid-\ning the decomposition of the systems based on behavior and data, encapsulation provides \nthe principle for enhancing the efficiency of the collaboration among modularized units. Encapsulation is the principle that deals with providing access to the services of concep-\ntual entities (e.g., modules, components) by exposing only the information that is essential \nto carry out such services while hiding details of how the services are carried out. While \nabstraction is employed to find conceptual entities, encapsulation enforces that abstracted \nentities communicate between each other using a \u201cneed to know only\u201d basis. When evalu-\nated this way, the abstraction design principle helps create the modules and the encapsula-\ntion design principle enforces efficient communication between them. These principles are \nall essential in achieving efficient modularization.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 50", "position": 50, "chunk_type": "semantic", "token_estimate": 403}
{"text": "26\u2002 \u2022\u2002 Software Engineering Design\ufeff: When evalu-\nated this way, the abstraction design principle helps create the modules and the encapsula-\ntion design principle enforces efficient communication between them. These principles are \nall essential in achieving efficient modularization. The relationship among modulariza-\ntion, abstraction, and encapsulation is presented in Figure\u00a01.4. As seen, after the principle \nof abstraction is applied, the encapsulation principle is used to hide irrelevant details from \nthe abstraction. In Figure\u00a01.4, the shaded region corresponds to information that is irrel-\nevant to other modules, while the white region corresponds to access points that modules \ncan use to interoperate. www.allitebooks.com", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 50", "position": 50, "chunk_type": "semantic", "token_estimate": 103}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 27: Coupling\nSimilar to abstraction and encapsulation, coupling and cohesion are design principles that lead \nto efficient module creation by emphasizing on the degree of dependency and belonging of \nmodules, respectively. Formally, the IEEE (1990, p. 22) defines coupling as\nThe manner and degree of interdependence between software modules. Like all other design principles discussed so far, coupling can be applied during software \narchitecture, detailed design, and construction design to measure the degree of depen-\ndency of design units, such as an architectural subsystem, a class in a detailed design\u2019s \nclass diagram, or a function in code. In other words, the coupling principle can be used \nto determine how much an architectural subsystem depends on other architectural sub\u00ad\nsystems, how much a class depends on other classes, and how much a function depends on \nother functions. When measuring coupling, the number of dependencies between design \nunits does not tell the whole story, since the nature of the dependencies plays an impor-\ntant role in decision making. For example, design units can depend on well-defined and \nstable interfaces, common data structures, and internal structure of other design units. It\u00a0is not hard to support the idea that dependencies on well-defined and stable interfaces \nare less troublesome than dependencies on the internal structure of other design units. Three common types of coupling are\n\u2022\t Content coupling\n\u2022\t Common coupling\n\u2022\t Data coupling\nContent coupling represents the most severe type of coupling, since it refers to modules that \nmodify and rely on the internal details of other modules. Common coupling refers to depen-\ndencies based on a common access area, such as a global variable (IEEE 1990). When this \noccurs, changes to the global data area causes changes in all dependent modules. This type \nof coupling results in lesser severity than content coupling; however, it shares many of the \nundesired effects as content coupling. Finally, data coupling refers to the type of dependency \nAbstraction\nModularization \nEncapsulation\nMonolithic\nSystem\nModularized\nSystem \nFIGURE 1.4\nThe modularization, abstraction, and encapsulation principles.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 51", "position": 51, "chunk_type": "semantic", "token_estimate": 341}
{"text": "28\u2002 \u2022\u2002 Software Engineering Design\ufeff: in which design units communicate with each other only through a set of data parameters. Unlike content coupling, data coupling does not depend on the internals of other design \nunits, and unlike common coupling it provides more control over the form of dependency. When dependency between modules relies on data parameters that are globally inaccessible, \ndesign units are shielded from undesired changes to the data by other design units. In all \ncases, a high degree of coupling gives rise to negative side effects. For example, as coupling \nincreases, reusability and manageability of the design units decrease since errors or changes \nto the independent unit propagate to all dependent units. In\u00a0other cases, when coupling \nincreases, so does the complexity of managing and maintaining design units. Other types \nof coupling include control coupling, hybrid coupling\u00ad\n, and pathological\u00ad\n coupling (IEEE 1990). Cohesion\nWhile coupling gives insight to a design unit\u2019s degree of dependency, cohesion provides \ninsight into its strengths. The IEEE (1990, p. 17) defines cohesion as\nThe manner and degree to which the tasks performed by a single software module are related \nto one another. Cohesion measures how well design units are put together for achieving a particular \npurpose and can be classified based on the measurement approach as\n\u2022\t Functional cohesion\n\u2022\t Procedural (or sequential) cohesion\n\u2022\t Temporal cohesion\n\u2022\t Communication cohesion\nFunctional cohesion measures a design unit\u2019s strength by the degree to which its tasks, \noperations, or subunits all contribute to perform a single function. When the function \nto be performed has a single logical meaning, functional cohesion can be seen as a form \nof logical cohesion. A highly functionally cohesive module is one whose internal details \nwork toward achieving the same function. Functional cohesion is the most typical type \nof cohesion. Procedural cohesion measures the strength of a design unit by the degree to \nwhich its tasks work procedurally (in steps) to achieve the unit\u2019s purpose. Therefore, func-\ntional and procedural cohesion are not mutually exclusive; that is, modules can exhibit \nboth high functional and procedural cohesion. Temporal cohesion measures strength by \nthe degree to which all tasks in a design unit are performed at specific times. Consider \na design unit responsible for carrying out the initialization of a system. This unit may \nbe responsible for performing a power-on self-test that may include memory tests, file \nsystem\u00ad\n checks, and communication checks.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 52", "position": 52, "chunk_type": "semantic", "token_estimate": 399}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 29: Cohesion provides an important principle that measures how much design units that are \ngrouped together actually belong together based on different criteria. Cohesion can also \nbe seen at different levels of the design process. During the software architecture activity, \nlogical and communication cohesive modules are typical, whereas, during the detailed \nand construction design activities, functional, procedural, and temporal cohesiveness are \nmore expected. In all cases, highly cohesive modules increase reusability. An example of \nthe cohesion and coupling principles is presented in Figure\u00a01.5. As seen in the top part \nof the figure, Module 1 performs three unrelated different tasks (i.e., Task 1, Task\u00a02, and \nTask 3), each requiring three independent subtasks. For example, Task 1 requires three \ndifferent subtasks, denoted by the labels Task 1.1, Task 1.2, and Task 1.3. As seen, Module\u00a01 \nhas dependencies to nine different unrelated tasks, which can translate to a high degree \nof coupling and low degree of cohesion. The bottom part of Figure\u00a01.5 shows how the \nsystem is decomposed into three more cohesive units, each with lower coupling than \nthe original approach. In this case, the system is transformed to a modular system with \nhigher \u00ad\ncohesiveness and lower coupling. With this transformation, Module 1 now has five \ndependencies and stronger functional cohesion. Modules 2 and 3 have lower coupling than \nModule 1 (both in its original and improve form) and are highly cohesive. Separation of Interface and Implementation\nThe principle of separation of interface and implementation deals with creating modules \nin such way that a stable interface is identified and separated from its implementation. This design principle should not be confused with encapsulation. During encapsulation, \nModule 1 \nTask 1.1 \nTask 1.2 \nTask 1.3 \nTask 2.1 \nTask 2.2 \nTask 2.3 \nTask 3.1 \nTask 3.2 \nTask 3.3 \nModule 2 \nModule 3  \nModule 1 \nTask 1.1 \nTask 1.2\nTask 1.3 \nTask 2.1 \nTask 2.2 \nTask 2.3\nTask 3.1 \nTask 3.2 \nTask 3.3 \nFIGURE 1.5\nExample of principles of coupling and cohesion.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 53", "position": 53, "chunk_type": "semantic", "token_estimate": 335}
{"text": "30\u2002 \u2022\u2002 Software Engineering Design\ufeff: interfaces are created to provide public access to services provided by the design unit while \nhiding unnecessary details, which include implementation. While encapsulation dictates \nhiding the details of implementation, the principle of separation dictates their separation, so \nthat different implementation of the same interface can be swapped to provide modified or \nnew behavior. Figure\u00a01.6 presents these concepts. As seen, the bottom design units have separated interfaces; therefore, varied implemen-\ntations can be employed without changes to a unit\u2019s interface and, subsequently, to depen-\ndent units. There are many benefits from this principle, including increased extensibility, \nreusability, and maintainability. Since implementation is compartmentalized, new capa-\nbilities can be added simply by including a new variation of the implementation without \nchanges to old implementations. Also, in this way specific implementations can be reused. Completeness and Sufficiency\nThe principles of completeness and sufficiency deal with efficient module creation. Completeness is a characteristic that measures how well design units provide the required \nservices to achieve their intent. For example, during the detailed design activity, a commu-\nnication class can be considered complete for a particular application if it provides services \nfor establishing and terminating connections, sending and receiving messages. Missing \nany of these services would render the class incomplete. On the other hand, sufficiency \nmeasures how well design units are at providing only the services that are sufficient for \nachieving their intent. Consider the same communication class, which can include services \nfor logging statistics, visualization of network activity, or any other capability applicable \nto the communication task. Although these capabilities enhance the class\u2019 service list, the \nclass is considered sufficient by providing the required services of opening/terminating \nconnections, sending, and receiving messages. That is, these sets of services are sufficient \nto achieve the unit\u2019s required functions, nothing more and nothing less. Practical Software Design Considerations\nDesign principles are well-known throughout the software engineering community and \nare applied in one way or another in most projects. However, other considerations need to \nSegregation of Interface\nand Implementation\nEncapsulation\nFIGURE 1.6\nPrinciple of segregation of interface and implementation.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 54", "position": 54, "chunk_type": "semantic", "token_estimate": 347}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 31: be made to provide the appropriate context in which these principles can be successfully \napplied for developing high-quality software systems. These considerations are discussed \nin the next sections. Design for Minimizing Complexity\nDesign is about minimizing complexity. Every decision that is made during the design phase \nmust take into account reducing complexity (McConnell 2004). In fact, the majority of design \nprinciples (e.g., modularization, abstraction, encapsulation) are meant to reduce complexity \nin one way or another. By doing this, details of the problem solution can be pushed further \ndown the process, where they can be appropriately handled. As another example, consider \nHCI design: it is all about reducing complexity for the user. Finally, code design is about \nreducing complexity for other developers maintaining the software. As rule of thumb, when \nfaced with competing design options, always choose the one that minimizes complexity. Design for Change\nAs stated before, software will change; therefore, design with extension in mind. There are \nnumerous reasons for this; for example, customers who like the software may want to extend \nits functionalities. On the other hand, customers who are discontent with the \u00ad\nsoftware may \nwant to replace or remove functionality. In other cases, hardware changes may trigger a \nsoftware change; advances in communications may cause software to change; or, simply, \nnewer, better software technology becomes available triggering a change of \u00ad\nsoftware that \nintroduces no new functionality but a more maintainable development technology that \nis supported by current practices. In any case, software will change; therefore, its very \nown nature requires software designers to plan for the future. A variety of \u00ad\ntechniques is \n\u00ad\navailable during the detailed design phase to achieve this. Software Design Strategies\nThroughout the years, a wide variety of strategies for designing software has been \u00ad\nproposed. Some of these include structured design, object-oriented design, aspect-oriented design, \ndata component-based design, and data structure-based design. Two popular strategies are \ndiscussed in the following sections. Structured Design\nIn a broad context, structured design refers to any disciplined functional design approach \nwhere software systems are decomposed into independent, single-purpose modules, using \nan iterative top-down approach. The main focus of structured design is on the functions \nthat systems need to provide, the decomposition of these functions, and the creation of \nmodules that incorporate these functions. Structured design approaches are typically \nemployed after structured analysis, where the main purpose is to derive a structure chart", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 55", "position": 55, "chunk_type": "semantic", "token_estimate": 406}
{"text": "32\u2002 \u2022\u2002 Software Engineering Design\ufeff: (i.e., software architecture) from data flow diagrams. Structured design introduced many \nbenefits; for instance, by decomposing the system into independent, single-purpose \nmodules\u00ad\n, programs were simpler to understand, manage, code, debug, and reuse (Stevens \n1981). However, structured design does not address the issues of data abstraction and infor-\nmation hiding and \u201cis largely inappropriate for use with object-based and object-oriented \nprogramming languages\u201d (Booch 1994, p. 22). Object-Oriented Design\nUnlike structured design, which focuses on functional decomposition of systems, \nobject-oriented design focuses on object decomposition. Formally, the IEEE (1990, p. 51) \ndefines object-oriented design as\nA design strategy in which a system or component is expressed in terms of objects and \n\u00ad\nconnections between those objects. Objects provide numerous capabilities that make them desirable for efficiently designing \nsoftware systems. For example, objects are capable of maintaining state information and \nprovide services that can be used independently or relative to the object\u2019s state. Therefore, \nthey are naturally good building blocks for creating good abstractions. Object-oriented \ndesigns also provide capabilities for inheritance and polymorphism, which provide vari-\nous advantages when designing complex and large-scale software systems. Inheritance \nallows designers to create families of objects capable of reusing each other\u2019s interfaces or \ninterfaces with implementations. While inheritance allows objects to inherit interfaces \nand implementations, polymorphism allows objects to change the behavior of inherited \ninterfaces\u00ad\n. Numerous design methods based on objects have been proposed. Today, the UP \nprovides a popular framework for object-oriented software engineering using UML.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 56", "position": 56, "chunk_type": "semantic", "token_estimate": 248}
{"text": "Designs in software engineering are used to identify, evaluate, and specify the structural: and behavioral characteristics of software systems that adhere to some specification. Software designs provide blueprints that capture how software systems meet their required \nfunctions and how they are shaped to meet their intended quality. Formally, software engi-\nneering design is defined as the process of identifying, evaluating, validating, and specify-\ning the architectural, detailed, and construction models required to build software that \nmeets its intended functional and nonfunctional requirements and the result of such a pro-\ncess. The\u00a0term software design is used interchangeably in practice as means to describe \nboth the process and product of software design. Throughout the design process, designers \nare constantly engaging in problem-solving activities that are fundamental to all modern \nengineering projects; therefore, they can be characterized as specialized problem solvers.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 56", "position": 56, "chunk_type": "semantic", "token_estimate": 139}
{"text": "1.\tWhat is software engineering design, and why is it important?: 2. What are the three states of problem solving? Describe each and explain how they \napply to design problems? 3. What are two types of thinking employed during problem solving? Provide an \n\u00ad\nexample of how they are applied to design problems. 4. What is the difference between well-defined, ill-defined, and wicked problems and \nhow these problems can affect software design? 5. What is the difference between an algorithm and a heuristic? Give examples of how \nboth approaches can be applied during the design phase? 6. What is the holistic approach to problem solving? Explain. 7. How does design fits within the software engineering life cycle? Explain. 8. What are the major activities of the software design phase, and how do they differ \nfrom one another? 9. List and explain the challenges faced in software design. 10. Why is important to emphasize on documentation and management activities \n\u00ad\nduring design? 11. Compare and contrast the following: interface design, user interface design, and \n\u00ad\nconstruction design. 12. What are the different roles of software designers? How do they differ? 13. Explain the difference between procedural and data abstraction. 14. What is content coupling, and how does it differ from other forms of coupling? 15. Explain in detail the concept of cohesion. 16. What do completeness and sufficiency mean? 17. What is the difference among the principles of modularization, abstraction, encapsu-\nlation, and separation of interface and implementation? Provide an example of each. 18. Compare and contrast the structured design strategy with the object-oriented design \nstrategy.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 57", "position": 57, "chunk_type": "semantic", "token_estimate": 265}
{"text": "Abran, Alain, James W. Moore, Pierre Bourque, and Robert Dupuis. Guide to the Software Engineering Body of: Knowledge\u20142004 Version\u2014SWEBOK. Los Alamitos, CA: IEEE Computer Society Press, 2005. Bass, Len, Paul Clements, and Rick Kazman. Software Architecture in Practice, 2d ed. Boston: Addison-Wesley, \n2003. Booch, Grady. Object-Oriented Analysis and Design with Applications, 2d ed. Santa Clara, CA: Addison-Wesley, \n1994. Brassard, Gilles, and Paul Bratley. Fundamentals of Algorithmics. Upper Saddle River, NJ: Prentice Hall, 1995. Dowson, Mark. \u201cThe Ariane 5 Software Failure. \u201d ACM SIGSOFT Software Engineering Notes, March 1997. Dym, Clive L., and Patrick Little. Engineering Design: A Project-Based Introduction. Hoboken, NJ: Wiley, 2008. Fox, Christopher. Introduction to Software Engineering Design: Processes, Principles, and Patterns with UML2. Boston: Addison Wesley, 2006. Giachetti, Ronald E. Design of Enterprise Systems: Theory, Architecture, and Methods. Boca Raton, FL; CRC\u00a0Press, \n2010. Griffin, Ricky W. Management, 10th ed. Mayfield Hts, Ohio: South-Western College Pub, 2010. Harrell, C., Biman K. Ghosh, and Royce O. Bowden. Simulation Using Promodel. New York: McGraw-Hill, 2004. IEEE. \u201cIEEE Recommended Practice for Software Design Descriptions.\u201d 1998. http://ieeexplore.ieee.org/xpl/\nfreeabs_all.jsp?arnumber=741934. IEEE. \u201cIEEE Standard Glossary of Software Engineering Terminology.\u201d IEEE, 1990. http://ieeexplore.ieee.org/\nxpl/freeabs_all.jsp?arnumber=159342. IEEE/ACM. Software Engineering 2004. August 23, 2004. Available at: http://sites.computer.org/ccse/\nSE2004Volume.pdf (accessed September 22, 2010). Kershaw, T. C., and S. Ohlsson. \u201cMultiple Causes of Difficulty in Insight: The Case of the Nine-Dot Problem.\u201d \nJournal of Experimental Psychology: Learning, Memory, and Cognition 30:3\u201315, 2004. Laplante, Phillip A. Requirements Engineering for Software and Systems. Boca Raton, FL: Auerbach Publications, \n2009. Liskov, Barbara, and John Guttag. Program Development in Java: Abstraction, Specification, and Object-Oriented \nDesign. Boston: Addison-Wesley, 2000. McConnell, Steve. Code Complete, 2d ed. Redmond, WA: Microsoft Press, 2004. Meyers, Scott. Effective C++: 55 Ways to Improve Your Programs and Designs, 3d ed. Boston: Addison-Wesley, \n2005. U.S. General Accounting Office. (GAO). Patriot Missile Defense: Software Problem Led to System Failure at \nDhahran, Saudi Arabia. Washington, DC: U.S. Government Accountability Office, 1992. Plotnik, Rod, and Haig Kouyoumdjian. Introduction to Psychology, 9th ed. Wadsworth Publishing, 2010. Pressman, Roger S. Software Engineering: A Practitioner\u2019s Approach, 7th ed. Belmont, CA: McGraw-Hill, 2010. Sommerville, Ian. Software Engineering, 9th ed. Boston: Addison Wesley, 2010. Stevens, Wayne P. Using Structured Design: How to Make Programs Simple, Changeable, Flexible and Reusable. Hoboken, NJ: John Wiley & Sons, 1981.", "domains": ["Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 58", "position": 58, "chunk_type": "semantic", "token_estimate": 376}
{"text": "\u2022\t Understand the role and importance of Unified Modeling Language: (UML) in software design\n\u2022\t Become familiar with UML\u2019s common structural and behavioral \ndiagrams\n\u2022\t Understand the relationship between structural UML models and code\n\u2022\t Understand how to model concurrency with UML", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 59", "position": 59, "chunk_type": "semantic", "token_estimate": 42}
{"text": "36\u2002 \u2022\u2002 Software Engineering Design\ufeff: WHAT IS UML? The Unified Modeling Language is a visual language with an extensive set of features \nappropriate for designing software systems across a broad set of application domains. It is \nthe result of years of collaborative work spent in devising a unified approach for modeling \nsoftware systems. The first efforts focused on unifying three popular modeling methods: \nthe Booch method (devised by Grady Booch); the object-oriented software engineering \n(OOSE) method (devised by Ivar Jacobson); and the object modeling technique (OMT) \nmethod (devised by James Rumbaugh). The goals of this unification project were specified \nby Booch, Rumbaugh, and Jacobson (2005, p. xvii) as follows:\n\t\n1. To model systems, from concept to executable artifact, using object-oriented \ntechniques\n\t\n2. To address the issues of scale inherent in complex, mission-critical systems\n\t\n3. To create a modeling language usable by both humans and machines\nThe development of early UML versions generated interest among the software engi-\nneering community, resulting in the creation of UML consortium supported by numerous \ninfluential organizations, such as Microsoft, IBM, Oracle, and Rational. This collaboration \nresulted in UML 1.0, which after revisions was adopted by the Object Management Group \n(OMG) in 1997 as UML 1.1 (Booch et al. 2005). Since then, UML has evolved through \nmany versions that improve capabilities for efficient analysis, design, and implementation \nof software systems of varying complexity. In 2005, a major revision of UML 1 was pro-\nposed and adopted by the OMG as UML 2.0. At the time of writing, UML 2.3 provides \nthe latest specification (UML 2.3 Superstructure 2010). Formally, UML can be defined as a \nvisual language for specifying, analyzing, and documenting design elements essential for \nmodeling and building software system. To provide an organized methodology for creat-\ning models that address different stakeholders\u2019 concerns, UML defines different modeling \ndiagrams and provides a classification scheme that delineates clearly between the static \nand dynamic nature of software systems, as seen in Table\u00a02.1. Every diagram in UML belongs to one of the classes presented in Table\u00a02.1. Throughout \nthe rest of the chapter, UML diagrams fundamental for modeling systems from both struc-\ntural and behavioral perspectives are presented, and their capabilities for addressing issues \nof different concerns from different levels of abstractions are examined.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 60", "position": 60, "chunk_type": "semantic", "token_estimate": 376}
{"text": "36\u2002 \u2022\u2002 Software Engineering Design\ufeff: Every diagram in UML belongs to one of the classes presented in Table\u00a02.1. Throughout \nthe rest of the chapter, UML diagrams fundamental for modeling systems from both struc-\ntural and behavioral perspectives are presented, and their capabilities for addressing issues \nof different concerns from different levels of abstractions are examined. TABLE\u00a02.1\nClassification of UML Diagrams\nClassification\nDescription\nStructural\nConcerned with capturing and specifying static elements and their interrelationships \nrequired for supporting the solution to a given problem, within a given context\nBehavioral\nConcerned with capturing and specifying the dynamic behavior and the inherent complexities \npresent in the behavioral aspects of software systems\nwww.allitebooks.com", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 60", "position": 60, "chunk_type": "semantic", "token_estimate": 110}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 37: WHY STUDY UML? UML 2.3 provides 14 different types of diagrams that can be used for modeling structural \nand behavioral aspects of software systems. Since software systems vary across a large set \nof application domains, not all 14 diagrams are required or used in any given project. For \nexample, real-time systems may employ the use of UML timing, state, and communica-\ntion diagrams to model behavior and real-time constraints related to real-time systems. Distributed systems may employ sequence diagrams for modeling time-ordered sequence \nof operations among components and deployment diagrams for modeling distributed \naspects of the systems. Finally, object-oriented systems\u2014which can also be distributed or \nreal-time systems\u2014may rely heavily on class and object diagrams to model class hierar-\nchies and particular instances of their interaction. Even though not all diagrams are used \nin system modeling efforts, it is important to identify a common set of diagrams that pro-\nvide appropriate avenues for model\u00ad\ning essential activities during the software development \nprocess. Therefore, the study of UML becomes important so that the modeling capabilities \nof particular diagrams are well understood and applied in practical efforts. The two main \nreasons for studying UML include\n\u2022\t The UML enhances system analysis and specification. \u2022\t The UML enhances communication. Modeling software is essential to developing high-quality, large-scale, and software-\u00ad\nintensive systems. The UML is important because it provides well-known and widely \naccepted means for modeling complex systems. Through UML, a common approach can \nbe used for analyzing, evaluating, and specifying systems at all levels of abstraction during \nrequirements, design, and construction. After systems are specified at one level of abstraction \nusing UML, the models are transferred downstream for subsequent, finer-grained analy\u00ad\nsis, evaluation, and specification. This process continues until the software is constructed \nand ready for testing and verification. Throughout this process, UML is the main tool \nfor transferring knowledge and enhancing communication among stakeholders, including \ncustomers, designers (i.e., architects, component, and construction), \u00ad\nprogrammers, and \nmanagers. By providing the means for visualizing complex system concepts, it becomes \neasier to reason about the problem at hand, therefore increasing communication during \nthe problem-solving process. The UML\u2019s visualization capabilities enhance communica-\ntion greatly throughout, especially when creating documentation deliverables, such as the \nsoftware design document, which lives long after the development effort is complete.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 61", "position": 61, "chunk_type": "semantic", "token_estimate": 386}
{"text": "38\u2002 \u2022\u2002 Software Engineering Design\ufeff: UML, its application can become confusing at times, resulting in model inconsistencies \nthat can hinder communication during the development effort. The built-in flexibility in \nUML is essential for modeling systems with disparate capabilities; therefore, understand-\ning its fundamental building blocks is necessary for employing the built-in flexibility to \nmodel a wide variety of software systems. The UML building blocks are grouped as follows:\n\u2022\t Classifiers\n\u2022\t Relationships\n\u2022\t Enhancing features\nClassifiers are structural things that represent conceptual or physical elements of a model \n(Booch et al. 2005). They are typically the main elements of UML models, and each type of \nUML diagram has a specific type of classifiers so that not all classifiers are relevant to all \nUML diagrams. A list of common UML classifiers is presented in Table\u00a02.2. Classifiers provide designers the capability of defining the structure for achieving some \ndesired system feature. This capability allows designers to visualize the structural design \nof systems, provide analysis, and make design improvements, all at design time. Structural \ndesigns are good for evaluating logical relationships in software design; however, they are \nlimited when it comes to evaluating the system\u2019s behavioral aspects\u2014that is, modeling \nand evaluating the manifestation and behavioral aspects of classifiers once the system is \nexecuted. For this purpose, UML provides techniques for representing almost all classi-\nfiers as manifested entities. For example, structural classes can be modeled as behavioral \n(executing) objects; the behavior of active classes can be modeled using active objects; \ncomponents can be modeled as component instances; use cases can be modeled as use \ncase executions; and nodes can be modeled as node instances (Booch et al. 2005).", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 62", "position": 62, "chunk_type": "semantic", "token_estimate": 276}
{"text": "38\u2002 \u2022\u2002 Software Engineering Design\ufeff: For example, structural classes can be modeled as behavioral \n(executing) objects; the behavior of active classes can be modeled using active objects; \ncomponents can be modeled as component instances; use cases can be modeled as use \ncase executions; and nodes can be modeled as node instances (Booch et al. 2005). The \nTABLE\u00a02.2\nUML 2.3 Common Classifiers\nClassifier\nDescription\nUse case\nClassifier used to model a single required system behavior; represented with icons of \nelliptical shape\nComponent\nRepresents a modular and replaceable part of the system; modeled using a box with the \nkeyword <<component>> and optional component icon on the top right corner\nClass\nClassifier used to model a type in terms of operations, attributes, relationships, and other \nsemantics; modeled with a rectangular box\nActive class\nClassifier used to model a class that owns an independent flow of execution and can initiate \ncontrol activity; modeled as a class with double lines on each side\nInterface\nClassifier that models the set of operations that specify the services provided by a class or \ncomponent; represented as stereotyped classes or using the ball-and-socket notation\nNode\nClassifier used to model a physical element (e.g., computer), its processing capabilities, and \nother semantics; modeled using a cube\nArtifact\nClassifier that models a physical deployable information element (e.g., .exe, .dll, script, etc. ); \nmodeled using a rectangle with the keyword <<artifact>>", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 62", "position": 62, "chunk_type": "semantic", "token_estimate": 229}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 39: usefulness of modeling classifiers (and their behavioral counterparts) is maximized when \ndefining and visualizing the interconnections that exist among them. A list of UML com-\nmon relationship types is presented in Table\u00a02.3. The UML is required to provide enough flexibility to allow designers to enhance and \nevolve the fundamental building blocks so that they become appropriate for modeling par-\nticular systems. Therefore, it provides the means for enhancing and extending classifiers, \nbehavioral manifestations, and relationships through common extension mechanisms. These extension mechanisms allow designers to redefine UML elements so that they can \nrepresent domain-specific concepts. Also, extension mechanisms allow detailed design \ninformation to be captured and specified in the models. The common mechanisms for \nenhancing UML are presented in Table\u00a02.4. Together, classifiers, relationships, and enhancement mechanisms provide powerful \n\u00ad\nconstructs for evaluating both structural and behavioral design elements that interact and \ncollaborate with each other, provide the means for evaluating design alternatives, and \n\u00ad\nprovide the sufficient information to build the software system.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 63", "position": 63, "chunk_type": "semantic", "token_estimate": 173}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 39: The common mechanisms for \nenhancing UML are presented in Table\u00a02.4. Together, classifiers, relationships, and enhancement mechanisms provide powerful \n\u00ad\nconstructs for evaluating both structural and behavioral design elements that interact and \ncollaborate with each other, provide the means for evaluating design alternatives, and \n\u00ad\nprovide the sufficient information to build the software system. TABLE\u00a02.3\nCommon Types of UML Relationships\nRelationship\nDescription\nDependency\nDashed line (typically directed with a stick arrow) used to model the relationship between \ntwo UML elements indicating that changes to one element affect the other\nAssociation\nLine used to model the relationship between two UML elements indicating that a connection \nexists between associated instances at run time; associations can be directed using a stick \narrow\nGeneralization\nLine with a hollow arrowhead used to model the relationship between two UML elements \nindicating that one element (i.e., the child) inherits features from another (i.e., the parent)\nRealization\nRelationship between two UML elements indicating that one element realizes a specified \ninterface; modeled using a dashed line with hollow arrowhead\nTABLE\u00a02.4\nCommon UML Mechanisms for Enhancement\nMechanism\nDescription\nNotes\nMechanism for adding descriptive information to UML elements and diagrams; modeled \nusing a rectangle with a dog-eared corner and can be connected to a design element using a \ndashed line\nStereotypes\nMechanism for extending UML by adding information that gives existing UML element a \ndifferent meaning, therefore creating a semantically different element for modeling \napplication-specific concepts; modeled as existing UML elements with the <<stereotype>> \nmechanism (e.g., <<subsystem>>)\nTagged Values\nMechanism for adding new properties to a stereotype; modeled by adding the tagged value in \nthe form of property = value to existing stereotyped UML elements (e.g., data rate = 5\u00a0Mbps)\nConstraints\nMechanism for specifying constraints to design elements; associated with specific design \nelements in the form of {constraint description} (e.g., {secure line})", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 63", "position": 63, "chunk_type": "semantic", "token_estimate": 312}
{"text": "Structural modeling is concerned with capturing and specifying structural elements and: interrelationships required for supporting the solution to a given problem, within a given \ncontext. Structural models are static in nature, since they model structure and not behav-\nior; therefore, they provide the main avenues for evaluating design decisions that directly \nsupport functional requirements as well as desired quality attributes, such as modularity, \nportability, and maintainability. A list of common UML structural diagrams is presented \nin Table\u00a02.5. Other structural diagrams include composite structure and profile diagrams. As seen, each \nstructural diagram addresses a particular system concern; therefore, the set of classifiers \nand relationship employed varies from diagram to diagram. Understanding the capabilities \nand goals of each structural diagram is important for determining the selection of effective \nconstructs that are appropriate at particular levels of abstraction during system design.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 64", "position": 64, "chunk_type": "semantic", "token_estimate": 139}
{"text": "A component represents a modular part of a system that encapsulates its contents and: whose manifestation is replaceable within its environment (UML 2.3 Superstructure 2010). For this reason, component diagrams can be used to decompose systems and represent \ntheir structural architecture, from a logical perspective. Components can be modeled \nusing an external black-box view or internal white-box view. With the black-box view, \ncomponents encapsulate their internal structure; therefore, collaboration with other com-\nponents is achieved through well-defined interfaces. These interfaces can be classified as \nprovided or required interfaces. Provided interfaces are used by other external components \nto interact with the component providing the interface. Required interfaces are those the \nTABLE\u00a02.5\nUML 2.3 Structural Diagrams\nDiagram\nDescription\nComponent\nHigh-level; used to model the software as group of components connected to each other \nthrough well-defined interfaces and thus said to be replaceable within its context\nClass\nUsed to model software as a set of classes, including their operations, attributes, and \ntheir\u00a0mutual relationships\nObject \nUsed to model an instant snapshot of the life of an object during execution, including \nits\u00a0state and attribute values\nDeployment \nUsed to model the physical realization of software systems, including physical nodes \nwhere software is deployed, interfaces between nodes, software artifacts executing on \nnodes, and the manifestation of software components within the software artifacts\nPackage Diagram\nDiagram used to model the division of software as a set of packages, including the \nrelationships between packages", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 64", "position": 64, "chunk_type": "semantic", "token_estimate": 238}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 41: components need to realize a component\u2019s function. Modeling component interfaces in \nUML can be achieved using two distinct notations: the ball-and-socket notation or the \ndependency and realization relationships, as seen in Figure\u00a02.1. Figure\u00a0 2.1 shows the basic component relationships and examples of component \ndiagrams\u00ad\n. As seen, the basic notations for modeling components are components, assembly \nconnectors, and provided/required interfaces. The notations presented in Figure\u00a02.1 are used \nto model components using an external, black-box view; however, components can also \nbe designed using an internal, white-box view, not presented in Figure\u00a02.1. When using \nComponent Relationships\nProvided Interface\n<<component>>\nComponentA\nRequired Interface\n<<assembly>>\nDependency\nDependency\nRealization\nRealization\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentB\n<<component>>\nComponentB\n<<interface>>\nInterfaceB\n<<interface>>\nInterfaceB\nClassA\nIRequired\nIRequired\nIProvided\nIProvided\nPort 2\nPort 1\nPorts and Delegates\n<<delegate>>\n<<delegate>>\n<<component>>\nComponentB\n<<component>>\nClientCollectionSystem\n<<component>>\nSensorManager\nIClientData\nIClientData\nISchedule\nISchedule\nPort 2\nPort 1\nSample Component Diagram\n<<delegate>>\nISensorControl\nIVideoControl\n<<delegate>>\n<<component>>\nClientManager\n<<component>>\nVideoManager\nFIGURE 2.1\nOverview of UML component diagram.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 65", "position": 65, "chunk_type": "semantic", "token_estimate": 184}
{"text": "42\u2002 \u2022\u2002 Software Engineering Design\ufeff: the black-box approach, components use the ports and delegates concepts to model how \ncomponents interact with other (external) components and how the responsibility for real-\nizing external requests are delegated throughout parts of components. As seen, ports are \nused to model access points for allowing the external environment to access the compo-\nnents\u2019 \u00ad\nservices and for allowing components to interact with their  external environment. Delegation connectors are used to model the link between the external provided inter-\nfaces of a component to the realization of those interfaces internally within the component \n(UML 2.3 Superstructure 2010). Similarly, delegation connectors model the link between \ninternally required interfaces to ports requiring the interface from external components. Figure\u00a02.1 presents a design element for devising a logical representation for the software \narchitecture of a sensor collection system. The system includes a client collection node \nthat is decomposed into ClientManager, SensorManager, and VideoManager. The \u00ad\nclient \n\u00ad\nsubsystem requires a collection schedule, which provides the information necessary for \nactivating sensor and video nodes to begin collection. The client subsystem makes this \ninformation available to other nodes upon request. As seen, the ClientManager component \nrequires a collection schedule, which is delegated to Port 2; this interface requires external \ncomponents to provide the collection schedule using the ISchedule interface. In\u00a0addition, \nthe ClientCollectionSystem component provides status information to external components \nvia Port 1 using the IClientData interface. The responsibility of realizing the IClientData \ninterface to provide status data is delegated to the ClientManager component so that all \nrequests received at Port 1 can be handled by the target component. Logical versus Physical Components\nThe UML 2.3 Superstructure Specification supports the specification of both logical and \nphysical components and describes them as substitutable units that can be replaced at \ndesign time or run time (UML 2.3 Superstructure 2010). This, combined with the previous \nusage (in UML 1.x) of components, creates confusion among designers. Although UML 1.x \nand UML 2.x components can look the same in UML, the context in which they are used \nshould make the distinction between physical and logical components evident. For this \nreason, a thorough discussion is needed. Logical components are used from a logical perspective, while physical components \nare used from a deployment perspective, which in UML 2.0 can be modeled as artifacts. Logical components are components that can be replaced at design time.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 66", "position": 66, "chunk_type": "semantic", "token_estimate": 396}
{"text": "42\u2002 \u2022\u2002 Software Engineering Design\ufeff: Logical components are used from a logical perspective, while physical components \nare used from a deployment perspective, which in UML 2.0 can be modeled as artifacts. Logical components are components that can be replaced at design time. For example, \nthe internal structure of a software system may be composed of three logical components: \nthe UI component, the business logic component, and the database component. Each \nof these has well-known interfaces that allow them to be replaceable at design time. By \n\u00ad\nhaving well-known interfaces, the internal design of components (e.g., the UI \u00ad\ncomponent) \nbecomes irrelevant to other external components (e.g., the business logic component). Logical \u00ad\ncomponents specify the decomposed structure of software; they exist in the \u00ad\ncontext \nof the \u00ad\nlogical design of the software system. On the other hand, physical components are components that exist within the context \nof deployment; they are distinctively different from logical components in that they are", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 66", "position": 66, "chunk_type": "semantic", "token_estimate": 160}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 43: independently deployable units that reside on their own and provide services to other \nphysical components or software applications. They provide stable interfaces that allows \nthem to be replaceable at run time, for example, JavaBean components, EJB components, \nand .NET components, which can be deployed independently through a jar file, ear file, \nand DLL file, respectively (Qian, Qian, Fu, Tao, Xu, and Diaz-Herrera 2009). Using components to denote logical units (as opposed to physical units) is new to UML\u00a02.0; \ntherefore, they provide modeling features that are specially fitting for designing logical ele-\nments of the software architecture. In previous versions of UML, components were reserved \nexclusively for modeling physical entities deployable within a system and replaceable at run \ntime. Now, UML supports the specification of both logical and physical components, together \nwith the artifacts that implement them and the nodes on which they are executed (UML 2.3 \nSuperstructure 2010). This new paradigm allows designers to model physical deployment \naspects of components using the artifact classifier deployed on a node (Booch et al. 2007).", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 67", "position": 67, "chunk_type": "semantic", "token_estimate": 181}
{"text": "Class diagrams exist at a lower level of abstractions than component diagrams. That is, whereas: component diagrams serve well to modularize the system, they do not have a direct translation \nfrom model to code. Class diagrams have direct translation to object-oriented programming \nlanguages. In simple terms, class diagrams are models consisting of classes and relationships \nbetween classes necessary to achieve a system\u2019s functionality. Therefore, whether a detailed \nclass diagram is made or not, the resulting object-oriented code will always reflect some class \ndesign. This characteristic of class designs results in a two-way relationship between class \n\u00ad\ndiagrams and code, which allows designers to generate code from class diagrams (i.e.,\u00a0code \ngeneration or forward engineering) or to generate class diagrams from code (i.e., reverse \nengineering). This makes class diagrams the most powerful tool for component designers to \nmodel the design characteristics of object-oriented software before the construction phase. Class diagrams vary in complexity, ranging from diagrams with a few classes with \n\u00ad\nsimple relationships to diagrams with many classes interconnected via elegant and effi-\ncient relationships. Class diagrams are perhaps the most important UML diagrams for \nobject-oriented component designers. To effectively model object-oriented software, \ndesigners need to have an understanding of the basic class constructs, relationships, and \nthe direct mapping that result from model to code. Classes\nA class is the specification of a type, nothing more, nothing less. For a class to be useful to \nsoftware programs, objects of that class need to be instantiated during the program\u2019s execu-\ntion. Instantiation is the process of manifesting a class in the computer\u2019s memory. A single \nclass specification can be manifested in the computer\u2019s memory during program execution \nas multiple objects, their specific values for each having operations and relationships with", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 67", "position": 67, "chunk_type": "semantic", "token_estimate": 289}
{"text": "44\u2002 \u2022\u2002 Software Engineering Design\ufeff: other objects. Classes are the building blocks of object-oriented systems; therefore, being \nable to model classes in an efficient and reusable way is essential. In UML, a class is mod-\neled with a rectangular shape with three main compartments, namely, the name, attribute, \nand operation compartments. Name Compartment\nThe name compartment is reserved for the class name and its stereotype. A class name is \na string value that uniquely identifies a class from other classes in the system. Class names \ncan be qualified to show the package that they belong to in the form of Owner::ClassName, \nwhere Owner refers to the package that owns the class and ClassName refers to the class \nname. UML classes can be enhanced to convey more information by using stereotypes. Stereotypes are displayed above the class name using the format <<stereotype>>. Commonly \nused stereotypes for classes include the <<interface>> and <<utility>> \u00ad\nstereotypes. The \n<<interface>> stereotype is used to model interfaces, which specify the services of a class. The <<utility>> stereotype is used to model a class that has no instances but instead repre-\nsents a named collection of class-scoped (i.e., static) attributes and operations. Attribute Compartment\nAttributes are named properties used to specify the information required by objects to carry \nout their intended function or to represent the object modeled by the class. The attribute \ncompartment is reserved for specifying the class attributes, including their name, type, and \nother properties, such as visibility and scope. Attribute names, similar to class names, are \nstring values that uniquely identify one attribute from all other attributes. The attribute type \nspecifies the type of data appropriate for the attribute, for example, integer, string, or double. Typically, the attribute compartment is used to specify primitive types, whereas attributes \nthat result as consequence of relationships with user-defined types are kept from the attri-\nbute compartment; these are modeled using the appropriate UML relationship with a label \ncontaining the attribute\u2019s name. The attribute\u2019s visibility specifies policies on how attributes \nare accessed by clients. In UML, visibility can be set to the types represented in Table 2.6. The scope of an attribute can be specified to be class-specific (i.e., static) or object-specific, \nwhich allows each individual object to have individual copies that help keep track of attri-\nbute values independently.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 68", "position": 68, "chunk_type": "semantic", "token_estimate": 383}
{"text": "44\u2002 \u2022\u2002 Software Engineering Design\ufeff: In UML, visibility can be set to the types represented in Table 2.6. The scope of an attribute can be specified to be class-specific (i.e., static) or object-specific, \nwhich allows each individual object to have individual copies that help keep track of attri-\nbute values independently. TABLE\u00a02.6\nCommon Visibility Types in Class Diagrams\nVisibility\nSymbol\nDescription\nPublic\n+\nAllows access to external clients\nPrivate\n\u2013\nHides private members or operations from external clients\nProtected\n#\nAllows access internally within the class and to derived classes\nPackage\n~\nAllows access to entities within the same package", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 68", "position": 68, "chunk_type": "semantic", "token_estimate": 101}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 45: Operation Compartment\nOperations are services provided by classes. The operation compartment is reserved for \nspecifying the class operations, including their name, return type, parameters, and other \nproperties, such as visibility, scope, type (e.g., abstract), and constraints, as seen in\u00a0Figure\u00a02.2. The class concept is easier to understand for most programmers, since it directly maps \nto code in object-oriented languages. An important aspect of modeling software with class \ndiagrams is the understanding of how classes modeled in the design translate to code. <<Class Stereotype>>\nClassName\n<<interface>>\nAbstractClass\n+interfaceMethod(): void\n\u2013attribute: int\n+operation1(): void\n\u2013operation2(): void\n+publicAttribute: int\n\u2013privateMethod(param: int): void\n#protectedMethod(): int\n+abstractMethod(): void\n+publicStaticMethod(): void\nClass Structure\nClass Diagram\nRelationships\nSample Class Diagram\nClassA\nDependency\nClassB\nClassA\nAssociation\nClassB\nClassA Directed Association ClassB\nClassA\nAggregation\nClassB\nClassA\nComposition\nClassB\nClassA\nGeneralization\nClassB\nClassA\nRealization\nClassB\nPartClassA\nConcreteClass\n+interfaceMethod(): void\nWholeClass\nDerivedClass\nPartClassD\nIndependentClass\nSampleClass\nBaseClass\n\u2013pConcrete\n\u2013pPartA\n\u2013objectD\nFIGURE 2.2\nOverview of class diagram.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 69", "position": 69, "chunk_type": "semantic", "token_estimate": 163}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 47: Dependency\nIn a class diagram, the dependency relationship, rendered as a dashed line and stick arrow, \nis used to model the relationship between two UML classes. Dependency models the rela-\ntionship that indicates that changes to one class affect the other. In C++, dependency rela-\ntionship may translate to a #include statement, as seen in Listing 2.3. Association\nAssociations are structural relationships; that is, they affect the structure of UML classes. In a class diagram, associations are modeled with solid lines connecting two classes, as seen \nin Figure\u00a02.2 from BaseClass to SampleClass. This structural relationship indicates \nthat a connection exists between associated instances at run time. Associations are bidirec-\ntional by default. When using bidirectional associations, classes on each end of the associa-\ntion are structurally modified to provide navigation to their associated classes, providing \nListing 2.2: Java Code Generated from SampleClass Designed in Figure\u00a02.2\nclass SampleClass {\n\t // Public method. public void operation1() {\n\t }\n\t // Private method. private void operation2() {\n\t }\n\t // Private attribute. private int attribute;\n}\nListing 2.3: C++ Code Generated for UML Dependency Relationship\n// The dependency relationship can result in code as a #include. #include \u201cIndependentClass.h\u201d\nclass DependentClass {\n\t // Other attributes. // Other operations. };", "domains": ["Design Patterns", "Design Principles"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 71", "position": 71, "chunk_type": "semantic", "token_estimate": 213}
{"text": "48\u2002 \u2022\u2002 Software Engineering Design\ufeff: objects of one type ability to navigate to objects of another type and vice versa. Navigation \ncan be limited to one-way by modeling the association relationship with a directional \narrow. When this is the case, only the structure of one class is modified to provide navi-\ngational capabilities to the other. In C++, the structural modification resulting from using \nassociations is presented in Listing 2.4. As seen, the association from WholeClass and \nConcreteClass may translate to a pointer type. Aggregation\nAggregation is a specialized form of association to denote a whole\u2013part relationship. That is, \naggregation can be seen as association with special semantics for modeling that one object \nis part of another. This added semantic is purely conceptual, and its use is constrained to \ndesign time; that is, forward-engineered aggregation relationships may translate to code in \nthe same way that associations are translated. Therefore, aggregation is used to increase the \ncommunication language at design time. Aggregation is modeled using an association line \nwith a hollow diamond at one end. Similar to association, aggregation can be made direc-\ntional, as seen in Figure\u00a02.2. When aggregation is used, the class connected to the diamond \npart of the aggregation arrow is said to be the whole, and the one connected to the arrow is \nthe part. As seen in Listing 2.4, aggregation may not be differentiable from association in \ncode, since both associations and aggregation can translate the same way in code. Composition\nObject composition is a specialized form of aggregation used to model ownership rela-\ntionship. Similar to aggregation, object composition models a whole\u2013part relationship; \nListing 2.4: C++ Code Generated for UML Association Relationship\n#include \u201cPartClassA.h\u201d\n#include \u201cConcreteClass.h\u201d\nclass WholeClass {\n\t // Code here...\nprivate:\n\t // Association relationship. ConcreteClass* pConcrete;\n\t // Aggregation relationship. PartClassA* pPartA;\n};", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 72", "position": 72, "chunk_type": "semantic", "token_estimate": 300}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 49: however, unlike aggregation, composition provides deeper semantics to indicate that the \nlifetime of the part is owned by the whole. Therefore, when the whole object goes out of \nscope, so does the part. In UML, object composition is modeled similarly to aggregation, \nbut instead of using a hollow diamond a solid diamond is used. In code, object composition \ncan be manifested in different ways. For example, Listing 2.5 presents the forward engi-\nneering (using C++) of some designed EventLogger class, which is used to log events \nin a system. As seen, the EventLogger will own at run time an instance of the File class; there-\nfore, once the EventLogger goes out of scope, so will the instance of the File class. This relationship can be translated differently in C++, via pointers. Listing 2.6 presents \nthe forward engineering of the EventLogger class with a different manifestation of the \nobject composition relationship. As seen, object composition is achieved using a different approach that creates and \ndestroys the _file object. It is important to emphasize once again that UML is a flexible \nlanguage; therefore, forward engineering of UML models can be realized differently by dif-\nferent tools and different programming languages. For example, association, aggregation, \nand object composition can all look different in other object-oriented languages, such as \nJava and C#, which have no pointer notation. Generalization\nGeneralization is a relationship that denotes inheritance; that is, one (child) class inher-\nits the structure and behavior of another (parent) class. Child classes can reuse services \nprovided by parent classes, override these services, or add entirely new ones. In class \n\u00ad\ndiagrams, generalization is modeled using a solid line with a hollow arrowhead connecting \ntwo classes, as seen in Figure\u00a02.2. Generalization always translates to code as inheritance, \nas seen in Listing 2.7. Listing 2.5: C++ Code Generated for UML Composition Relationship\n// Object composition requires this dependency. #include \u201cFile.h\u201d\nclass EventLogger {\n\t // Code here...\nprivate:\n\t //The Object Composition Relationship. File _file;\n};", "domains": ["Design Principles"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 73", "position": 73, "chunk_type": "semantic", "token_estimate": 337}
{"text": "50\u2002 \u2022\u2002 Software Engineering Design\ufeff: Realization\nWhereas generalization allows classes to inherit a parent\u2019s class interface and behavior, \nrealization allows classes to inherit the interface. Realization is used to model a contract \nrelationship in which one class specifies an interface contract and another buys into that \ncontract. When realization is used, classes that realize interfaces are required by contract \nto provide implementations for those interfaces before objects of those classes can be \ninstantiated. In UML, realization is modeled using a dashed line with a hollow arrowhead \nListing 2.6: C++ Code Generated for UML Composition Relationship\n#include \u201cFile.h\u201d\nclass EventLogger {\n\t // Constructor. EventLogger() {\n\t \t // Instantiate the message object during initialization. _file = new File;\n\t }\n\t // Destructor. ~EventLogger() {\n\t \t // Because of UML composition relationship, once the this object\n\t \t // goes out of scope, so does the _file object. delete _file;\n\t }\nprivate:\n\t // Object composition via pointers. File* _file;\n};\nListing 2.7: C++ Implementation for UML Generalization Relationship\n#include \u201cBaseClass.h\u201d\n// Generalization results in inheritance. class DerivedClass : public BaseClass {\n\t // Code here...\n};", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 74", "position": 74, "chunk_type": "semantic", "token_estimate": 177}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 51: connecting two classes. In code, realization can translate in different ways depending on \nthe target programming language; however, the semantics remain the same. In the code \ncontext, an interface is the collection of public methods that define the services provided \nby class. In C++, interfaces are created using pure virtual methods as seen in Listing 2.8. As seen, the Gps class is made up of two pure virtual methods, which means that objects \nof the Gps class cannot be instantiated; the Gps class is typically referred to as an interface \nto define a common set of services, in this case, global positioning system (GPS) services. Similar to all other relationships discussed so far, the realization relationship trans-\nlates different in different languages. In C++, the realization relationship translates iden-\ntical to the generalization relationship. As seen in Listing 2.9, the forward engineering \nListing 2.8: C++ Code Generation for Interfaces\nclass Gps {\npublic:\n\t // The interface method to obtain latitude information. virtual double getLatitude() = 0;\n\t // The start interface method. virtual double getLongitude() = 0;\n};\nListing 2.9: C++ Implementation for UML Realization Relationship\n#include \u201cGps.h\u201d\n// SimulatedGps realizes the Gps interface. class SimulatedGps : public Gps {\npublic:\n\t // The interface method to obtain latitude information. double getLatitude() {\n\t \t // Generate a sample latitude and return.\n\t } // The interface method to obtain longitude information. double getLongitude() {\n\t \t // Generate a sample longitude and return.\n\t } };", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 75", "position": 75, "chunk_type": "semantic", "token_estimate": 247}
{"text": "52\u2002 \u2022\u2002 Software Engineering Design\ufeff: of the SimulatedGps class results in inheritance with provided methods for both \ninterface\u00a0methods. Gps services can be realized by different Gps classes differently; for example, one \nderived Gps class (e.g., HardwareGps) may realize the Gps interface by providing code \nthat interfaces with specific hardware to obtain actual readings for latitude and longi-\ntude. Another derived Gps class (e.g., SimulatedGps) can realize the Gps interface by \nproviding code that simulates latitude and longitude readings in case the Gps hardware \nis not available. By designing such framework (i.e., Gps interface, HardwareGps, and \nSimulatedGps) \u00ad\nclients can create their designs relying on using the Gps interface; by \nrelying on a well-defined interface, objects of type HardwareGps or SimulatedGps \ncan be swapped without ever having to change the client code. Interfaces and the realization relationship are so essential to object-oriented systems that \nmodern languages include keywords to support this relationship. In Java, the forward engi-\nneering of the Gps interface translates to an interface, as seen in Listing 2.10. The forward engineering of the realization relationship in Java results in a class \nthat implements and interface. Listing 2.11 presents the forward engineering of the \n\u00ad\nrealization relationship for the SimulatedGps class in Java. Listing 2.10: Java Code Generated for Interfaces\ninterface Gps {\n\t // The interface method to obtain latitude information. public double getLatitude();\n\t // The interface method to obtain longitude information. public double getLongitude();\n}\nListing 2.11: Java Code Generated for UML Realization Relationship\nclass SimulatedGps implements Gps {\n\t // The interface method to obtain latitude information. public double getLatitude() {\n\t \t // Generate a sample latitude and return.\n\t } // The start interface method. public double getLongitude() {\n\t \t // Generate a sample longitude and return.\n\t } }", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 76", "position": 76, "chunk_type": "semantic", "token_estimate": 290}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 53: Skill Development 2.1: Modeling Structure with Class Diagrams\nUsing pencil and paper, create the class diagram that models the following relation-\nships. Class B inherits from class A. Class B is directionally associated with class F and \nhas a special whole\u2013part relationship with class C, so that when B goes out of scope, \nso does C. Class B has another whole\u2013part relationship with class D, which depends \non interface E. When class B goes out of scope, D remains active as an object during \nrun time. Both classes G and H realize the E interface. When done, replace the class \nnames A, B, C, D, E, F, G, and H with names that represent types appropriate for these \nrelationships. Discuss your results with your peers.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 77", "position": 77, "chunk_type": "semantic", "token_estimate": 133}
{"text": "Deployment diagrams are structural diagrams used to model the physical realization: of software systems. They provide the means for visualizing the environment in which \nsoftware executes and how different entities communicate with each other to achieve the \n\u00ad\nsystems\u2019 functions. Deployment diagrams provide a static holistic view of the software \nsystem, from the deployment perspective, by providing avenues for modeling and speci-\nfication of the physical nodes, software artifacts, and the interrelationship among them. A node is a computational resource that host software artifacts for execution (UML 2.3 \nSuperstructure 2010). In UML, nodes are named classifiers modeled as a cube. Nodes can be \nassociated with other nodes to model the communication path between them; these com-\nmunication paths can be enhanced with stereotypes, multiplicity, and other adornments \nto further specify their properties and constraints. For example, in Figure\u00a02.3, communi-\ncation paths are enhanced by specifying the communication protocol (e.g., Transmission \nControl Protocol/Internet Protocol [TCP/IP], Universal Serial Bus [USB], and ZigBee). In addition, multiplicity is used to model the number of elements connected to other \n\u00ad\nelements. As seen, there is a plurality of sensor nodes connected to the embedded \u00ad\nclient \ncomputer via the ZigBee wireless protocol. This deployment diagram also models the \noptional use of mobile devices in the system; that is, the embedded client computer may \nor may not have mobile devices interfacing to it. Nodes can also be modeled as hosts by \nincluding the components that execute in the node and their manifestation as artifacts. Artifacts are used to model physical units of information that form part of the software \nsystem, such as binary executable files, configuration files, and scripts. Artifacts are \u00ad\nmodeled \nusing the <<artifact>> keyword and can be related to nodes, components, and other arti-\nfacts using the dependency relationship, as seen in Figure\u00a02.3. Artifacts that collaborate with \nother artifacts can be modeled using the dependency relationship. To model the deployment \nrelationship, artifacts are connected to nodes using the dependency relationship with the \n<<deploy>> stereotype. When connected this way, it is said that the artifact is deployed on \nthe node connected to the other end of the dependency relationship. When necessary, the", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 77", "position": 77, "chunk_type": "semantic", "token_estimate": 360}
{"text": "54\u2002 \u2022\u2002 Software Engineering Design\ufeff: manifestation of components (designed in component diagrams) on a target node can be \nmodeled using the dependency relationship from the artifact to the component with the \n<<manifest>> stereotype. Together, the concepts of nodes, relationships, and artifacts can be used to create deploy-\nment diagrams that include the physical nodes where software is deployed, communica-\ntion paths between nodes, software artifacts executing on nodes, and the manifestation of \nsoftware components within the software artifacts, as seen in Figure\u00a02.3. NodeA\nSensorNode\nWireless 3G Card\nMobilePhone\nDatabaseServer\nEmbeddedClientComputer\nVideoNode\nNodeB\n<<artifact>>\nArtifactA\nAssociation\nDeployment Diagram Relationships\n<<deploy>>\n<<manifest>>\n<<manifest>>\n<<deploy>>\n<<manifest>>\n<<TCP/IP>>\n<<ZigBee>>\n<<USB>>\n1\n1\n1\n1\n<<TCP/IP>>\n<<TCP/IP>>\n0..*\n1\n<<artifact>>\nClientCollectionSystem.exe\n<<TCP/IP>>\n1..*\n1..*\n1\n1\n1\n1\nDependency\nNodeB\n<<artifact>>\nArtifactA\n<<component>>\nComponentA\n<<component>>\nClientCollectionSystem\n<<component>>\nServerMonitorSystem\nApplicationServer\n<<artifact>>\nMonitorSystem.exe\n<<artifact>>\nArtifactA\n<<artifact>>\nArtifactB\nSample Deployment Diagram\nFIGURE 2.3\nOverview of UML deployment diagram.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 78", "position": 78, "chunk_type": "semantic", "token_estimate": 151}
{"text": "Structural modeling is essential to evaluate, characterize, and visualize the structural: design of software systems from various perspectives. These static diagrams provide good \navenues for analyzing properties that are the direct result of structural designs, such as \ntheir ability to meet functional requirements, reusability, and maintainability; however\u00ad\n, \nthey are not adequate for modeling the inherent complexities present in the behavioral \naspects of software systems. For this reason, behavioral diagrams are necessary to models \nand \u00ad\nspecify the dynamic aspects and evaluate the quality attributes related to the system \nbehavior. To\u00a0this end, UML provides several diagrams that can be used to model impor-\ntant \u00ad\nbehavioral aspects of software. These are presented in Table\u00a02.7. Table\u00a02.7 does not present an exhaustive list of UML behavioral diagrams. However, these \ndiagrams can be used to model almost any behavioral aspect of modern software \u00ad\nsystems, \nand their use is ubiquitous in practical development efforts. Therefore, their understanding \nand applicability must be well understood. Other diagrams, such as timing and interaction \noverview diagrams, are not covered here.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 79", "position": 79, "chunk_type": "semantic", "token_estimate": 176}
{"text": "Use case diagrams are behavioral diagrams used to capture, specify, and visualize required: system behavior. The main elements of use case diagrams are actors, use cases, and the \nrelationships connecting them together. Actors are entities used to model users or other \nsystems that interact with the system being modeled (i.e., the subject); that is, operators \nusing the system, sensors providing information, and a client computer in a client\u2013server \nsystem can all be modeled as actors. Use cases are entities used in use case diagrams to \nTABLE\u00a02.7\nUML 2.3 Behavioral Diagrams\nDiagram\nDescription\nUse case diagram\nUsed to capture, specify, and visualize required system behavior (i.e., requirements)\nSequence diagram\nUsed to capture, specify, and visualize system interactions with emphasis on the \ntime-order sequence of messages exchanged\nCommunication diagram\nUsed to capture, specify, and visualize system interactions with emphasis on the \nstructural order of entities participating in the message exchange\nState machine diagram\nUsed to capture, specify, and visualize system behavior as a set of discrete states \nand the transitions between them\nActivity diagram\nUsed to capture, specify, and visualize system behavior; provide mechanisms for \nmodeling that includes conditional statements, repetition, concurrency, and \nparallel execution and thus can be used at many different levels of abstraction, \nfrom modeling business work flows to code", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 79", "position": 79, "chunk_type": "semantic", "token_estimate": 212}
{"text": "Interaction diagrams exist at lower levels of abstraction than use case diagrams and can: be used extensively during the complete life cycle of software projects. At the architectural \n(system) level, interaction diagrams can be used for modeling interactions among software \ncomponents; during detailed design, they provide interaction modeling capabilities among \nobjects at run time; and at the construction level they can be used to model collaborative \nalgorithms that include conditional and repetition structures, such as loops. Interaction \ndiagrams are popular because they provide avenues for modeling complex interactions \namong software units together with the messages exchanged and the type of the exchange. By modeling the interactions required to realize a particular system function, designers \ncan determine if current structural diagrams are adequate to support the system; this gives \ndesigners the ability to model interactions for which the capability of the structural design \nto meet its functional and quality requirements may be in question. In these cases, inter\u00ad\naction diagrams can serve as validation tool before construction can begin. In many situa-\ntions, interaction diagrams can reveal many important issues related to the overall quality \nof the system (e.g., performance). Two types of interaction diagrams are\n\u2022\t Communication diagrams\n\u2022\t Sequence diagrams", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 81", "position": 81, "chunk_type": "semantic", "token_estimate": 201}
{"text": "58\u2002 \u2022\u2002 Software Engineering Design\ufeff: Communication Diagrams\nCommunication diagrams are behavioral diagram used to capture, specify, evaluate, and \nvisualize system interactions with emphasis on the structural order of entities participating \nin the message exchange. When using communication diagrams, entities can be modeled \nas objects representing instances of classes or as roles representing prototypical instances of \nother entities, such as classes and components (Booch et al. 2005). Both objects and roles \ncan be connected to model the exchange of messages using links or connectors, respectively\u00ad\n. As\u00a0seen in Figure\u00a02.5, a role is modeled using a named box (similar to a class) without under-\nlining the role\u2019s type. In addition, roles can be named or anonymous, as seen in Figure 2.5. On the other hand, objects are modeled using similar notation, but the name of the object \nis underlined. In many practical situations, designers are interested in modeling how roles \ninteract with each other to model a system behavior and not on how individual objects \ninteract. For these situations, roles provide the appropriate modeling entity. When using \nroles for modeling behavior, they can be connected using a solid \u00ad\nconnector line to represent \n: FileSystemMgr\ndb : EventLogger\nsynchronous message\nCommunication Modeling\nObject-Based Communication\n: FileSystemMgr\ndb : EventLogger\nasynchonous message\nfs : FileSystemMgr\nel : EventLogger\nsynchronous message\nfs : FileSystemMgr\ncm : CommMgr\n1 : put(msg)\n2 : decodeMsg()\n4 : format(fast)\n3 : log(received,msgId)\n5 : log(success)\nam : AppMgr\nel : EventLogger\nfs : FileSystemMgr\nel : EventLogger\nasynchronous message\nFIGURE 2.5\nSample UML communication diagram.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 82", "position": 82, "chunk_type": "semantic", "token_estimate": 260}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 59: a prototypical connection between roles. Similarly, when using objects, their connection \nis made using links, which represent an instance of an association\u00ad\n (Booch et\u00a0 al. 2005). Connectors and links look exactly alike and differ only semantically. To model the message exchanges in communication diagrams, messages in the form of \narrows are used. Two common types of messages include synchronous and asynchronous \nmessages. Synchronous messages\u2014modeled using a solid arrowhead\u2014are used to model \ninteractions in which both sender and receiver work in lock-step to achieve an operation. Asynchronous messages\u2014modeled using a stick arrow\u2014model interactions that are car-\nried out by receivers independently from the sender. That is, upon sending an asynchro-\nnous message, the sender continues working while the receiver carries out the message \nrequest. The main elements present in communication diagrams, together with sample \nobject-based communication diagram design, are presented in Figure\u00a02.5. The communication diagram presented in Figure\u00a02.5 models a system receiving a message \nto initiate a file system format. As seen, the \u201ccm\u201d object sends a message to the application \nmanager object \u201cam,\u201d which decodes the message, logs the receipt of the message by sending \na message to the event logger object \u201cel,\u201d and initiates a format by sending a message to the \nfile system manager object \u201cfs.\u201d Once finished formatting the file system the \u201cfs\u201d object logs \nan event. All messaging in the communication is done synchronously using links. Sequence Diagrams\nSequence diagrams are behavioral diagrams used to capture, specify, and visualize system \ninteractions with emphasis on the time-order sequence of messages exchanged. Sequence \ndiagrams are closely related to communication diagrams. Therefore, many of the modeling \ntechniques are the same; that is, sequence diagrams include objects, roles, synchronous, \nand asynchronous messages. Sequence diagrams put emphasis on the time order of mes-\nsages by introducing a lifeline and activation bar. Lifelines are modeled with the object/role \nconnected to a vertical dashed line that represents the lifetime of the object/role. Typically, \nobjects/roles in a sequence diagram are aligned from left to right, depending on the order \nin which messages are sent. Once a message is sent, the activation bar is rendered on \nthe object\u2019s lifeline to model the relative processing time that results from the message \nexchange. Asynchronous and synchronous messaging are modeled similar to communica-\ntion diagrams, and return messages can be modeled using a dashed line with a stick arrow.", "domains": ["Design Patterns", "Design Principles"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 83", "position": 83, "chunk_type": "semantic", "token_estimate": 401}
{"text": "60\u2002 \u2022\u2002 Software Engineering Design\ufeff: sender of an asynchronous message continues on executing while the receiver carries out \nthe work requested. Typically, independent flows of executions are manifested as \u00ad\nmultiple \nprocesses or threads. When applications are multiprocessed or multithreaded, concurrency \nissues arise when they execute in parallel (or pseudo-parallel) with each other. Therefore, \nit\u00a0is important to model concurrent design issues so that their impacts are well understood \nbefore construction begins. Concurrent designs require designers to decompose applications into multiple processes \nor threads to meet performance (e.g., usability, throughput) requirements. Processes can \nexecute concurrently with other processes, while threads can execute concurrently with \nother threads (within the same process). The importance of modeling concurrent designs up \nfront is often overlooked in many design efforts; that is, too much concurrency can end up \ndegrading the systems while insufficient concurrency results in decreased systems through-\nput (Booch et al. 2005). Developing these systems requires skills typically acquired through \n: Operator\n1 : asyncMessage\nobjectA : ClassA\nobjectB : ClassB\n2 : selfMessage()\n3 : syncMessage()\n5 : returnMessage\n4 : syncMessage()\nGeneral Sequence Diagram\nApplied Sequence Diagram\n1 : put(msg)\n7 : return status\nam : AppMgr\ncm : CommMgr\nel : EventLogger\nfs: FileSystemMgr\n2 : msgId := decodeMsg()\n3 : log(received,msgId)\n4 : format(fast)\n6 : return status\n5 : log(success)\nFIGURE 2.6\nUML sequence diagram.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 84", "position": 84, "chunk_type": "semantic", "token_estimate": 227}
{"text": "UML is a visual language with an extensive set of features appropriate for designing soft-: ware systems across a broad set of application domains. The current version of UML (2.3) \nprovides 14 diagrams for structural and behavioral modeling of software systems. These \ndiagrams support software design during architectural, detailed design, and construction \ndesign activities. Since UML has been designed with flexibility in mind, it is important \nto understand how the its fundamental building blocks (i.e., classifiers, relationships, and \nenhancing features) can be used to model systems of disparate capabilities and domains. While some UML diagrams provide modeling concepts that are too abstract for direct \ntranslation to code, others are not. Therefore, it is essential that designers understand \nhow these models translate to code and how they are used to model quality attributes. By providing a unified communication language for software design, UML is appropri-\nate and efficient for capturing and conveying information that can be evaluated by many \n\u00ad\nstakeholders including customers and software engineers alike, resulting in a more effi-\ncient design process.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 87", "position": 87, "chunk_type": "semantic", "token_estimate": 174}
{"text": "1.\tWhat is UML, and why is it important in software design?: 2. What are the two main classifications for UML diagrams, and how do these differ \nfrom one another? 3. List and explain two important reasons for software designers to study UML. 4. In UML context, what are classifiers? Provide examples of classifiers. 5. What are the main relationships used in UML diagrams? Provide examples of each. 6. List and explain the main mechanisms for extending UML. 7. What is structural modeling? 8. Compare and contrasts the following:\n\t\na. Component diagram\n\t\nb. Class diagram\n\t\nc.\t Deployment diagram", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 87", "position": 87, "chunk_type": "semantic", "token_estimate": 98}
{"text": "64\u2002 \u2022\u2002 Software Engineering Design\ufeff: 9. Explain the following relationships, and show how they are modeled in component \ndiagrams:\n\t\na. Provided and required interfaces\n\t\nb. Assembly connector\n\t\nc.\t Delegates\n\t 10. What is a UML artifact? How are artifacts different from components? 11. List and explain the main compartments of UML class. 12. What are the possible types of visibility that can be used in items of class diagrams? Explain. 13. In a class diagram, what is the difference between the following relationships:\n\t\na.\t Generalization vs. realization\n\t\nb.\t Aggregation vs. object composition\n\t\nc.\t Dependency vs. association\n\t 14. How can the manifestation of software components in a deployed environment be \nmodeled in UML? Explain. 15. In a UML deployment diagram, what is a node? 16. Compare and contrasts the following:\n\t\na. Use case diagram\n\t\nb.\t Sequence diagram\n\t\nc.\t Communication diagram\n\t 17. What is the difference between synchronous and asynchronous messages? 18. Explain how concurrency issues can be addressed using UML. 19. Compare and contrasts the following:\n\t\na.\t Sequential synchronization\n\t\nb. Guarded synchronization\n\t\nc.\t Concurrent synchronization", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 88", "position": 88, "chunk_type": "semantic", "token_estimate": 173}
{"text": "1.\tConsider the software design of a car in a racing game. Use a software modeling tool: to identify the major components of the car, define the component\u2019s interfaces, and \nconnect all components the way you think provides the best design for developing the \ncar. Create a list of design factors that influenced the final car\u2019s design and the benefits \nprovided by your approach. When done, ask a peer to do the same and compare your \napproach and final results. 2. Use the component design created in Exercise 1 to design the classes required to sup-\nport the component\u2019s interfaces and provided services. Create a list of design factors \nthat influenced the final car\u2019s design and the benefits provided by your approach. When done, ask a peer to do the same and compare your approach and final results.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 88", "position": 88, "chunk_type": "semantic", "token_estimate": 138}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 65: 3. Create a UML class diagram containing the following information. Class Name\nOperations\nAttributes\nRelationships\nName\nType\nReturn \nName\nVisibility\nReturn\nName\nVisibility\nInherits from \nClassZ and \nuses \naggregation \nwith ClassT\nClassA\nClass\nvoid\noperation1\npublic\nchar*\nx\nprivate\nint\noperation2\nprivate\nbool\ny\nprotected\nClassB\nInterface\nvoid\noperation3\npublic\nNone\nDepends on \nClassA and is \nassociated with \nClassO using a \ndirectional \nassociation\nvoid\noperation4\npublic\nClassC\nClass\nnone\nNone\nRealizes ClassB \nand is \ncomposed of \nClassA\n\t\n4. Matt and Alice are starting a bed-and-breakfast in a small Virginia town. They will \nhave three bedrooms for guests. They want a system to manage the reservations and \nto monitor expenses and profits. When a potential customer calls for a reservation, \nthey will check the calendar, and if there is a vacancy they will enter the customer \nname, address, phone number, dates, agreed upon price, credit card number, and \nroom number. To facilitate reservations, the system needs to print weekly schedules, \nincluding available rooms, their locations, price, and special rates. Reservations must \nbe guaranteed by one day\u2019s payment. Reservations will be held without guarantee for \nan agreed upon time. If not guaranteed by that date, the reservation will be dropped. Create a UML use case diagram using a system boundary for this system.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 89", "position": 89, "chunk_type": "semantic", "token_estimate": 219}
{"text": "68\u2002 \u2022\u2002 Software Engineering Design\ufeff: WHAT IS SOFTWARE ARCHITECTURE? In a broad context, software architecture refers to both the process and design products \nrequired to systematically build software systems that meet their intended functions and \nquality. Of\u00a0course, such broad definition of software architecture leaves out many of the \ndetails that make architecture essential in designing today\u2019s complex software systems. To understand the meaning and importance of software architecture, it helps to examine \nhow other engineering disciplines employ architectural designs to build complex systems \nwith demanding functional and quality requirements. Consider the role of architecture in \ncivil engineering, where designing and building structures such as houses, bridges, and \nhigh-rises is a nontrivial task. In these cases, architectural designs are used to specify the \noverall appearance of physical structures. When examined closer, it becomes evident that \nthis broad definition is insufficient to describe to actual role of architecture in the process of \nbuilding these \u00ad\nsystems, which involve far more than structural appearance. Architectural \ndesigns must also specify a variety of quality properties that make structures functional, \nsafe, and economical. This requires architects to incorporate design alternatives that con-\nsider a wide variety of factors (e.g., social, aesthetic, and cost) supporting the needs of \nstakeholders, including the people who use these physical structures. In software engineering, architects work to create the overall design elements appro-\npriate for supporting efficient refinement and construction of software systems. However, \nas in the previous discussion, architectural designs in software engineering involve far \nmore than structural composition. They must also address numerous quality properties\u00ad\n \n(e.g.,\u00a0 performance, usability, and maintainability) that combine together to produce \nsoftware systems that meet the quality expected by their stakeholders. To address these \nnumerous concerns, software architects create different models of the software system, \neach addressing the system design from different perspectives. From the structural, logical \nperspective, the software architecture should address the needs of downstream designers \nand developers by decomposing the software (in an efficient manner) and defining the \nmajor components of the system, identifying their interfaces and interrelationships, and \nproviding support for both functional and quality attributes of the system. From the con-\nfiguration management perspective, the architecture should provide information about \nthe hierarchy of files in the file system, their interrelationships, and the process for building \none or more versions of the software system.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 92", "position": 92, "chunk_type": "semantic", "token_estimate": 385}
{"text": "68\u2002 \u2022\u2002 Software Engineering Design\ufeff: From the structural, logical \nperspective, the software architecture should address the needs of downstream designers \nand developers by decomposing the software (in an efficient manner) and defining the \nmajor components of the system, identifying their interfaces and interrelationships, and \nproviding support for both functional and quality attributes of the system. From the con-\nfiguration management perspective, the architecture should provide information about \nthe hierarchy of files in the file system, their interrelationships, and the process for building \none or more versions of the software system. From a systems engineering perspective, the \narchitecture provides information about the physical deployment of the system, including \nthe location of distributed subsystems, their interfaces and interrelationship, and specifi-\ncation of communication protocols between them. Other architectural perspectives exist \nfor addressing various concerns that stakeholders may have and should be considered and \ndesigned for during the software architecture activity. Since the nature of stakeholders\u00ad\n \n\u00ad\nvaries greatly in software systems, the perspective used to model the structure and behav-\nior of software systems varies as well. Therefore, it is almost never the case that a single \ndesign element, from a single perspective, can represent the software architecture, espe-\ncially for large-scale software intensive systems. In these cases, the collection of design", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 92", "position": 92, "chunk_type": "semantic", "token_estimate": 210}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 69: elements and their detailed descriptions help form the software architecture. Formally, \nsoftware architecture is defined as\nThe foundational software design activity that evaluates and translates software require-\nments (both functional and non-functional) into a collection of design elements that specify \nstructural and behavioral aspects of the major components of the system, together with their \nprovided quality, and interrelationships required to support the detailed design and con-\nstruction of software systems; and the product resulting from such activity. From this definition, a few things are of interest and need further explanation. First, as \nfoundational design, software architecture provides the groundwork essential for meeting \nfunctional and nonfunctional requirements. The architectural design foundation provides \nthe necessary structure for achieving quality throughout subsequent phases of the software \nengineering life cycle. This suggests that architecture is not an optional design activity or \nan activity performed as a means of documenting software systems long after they are \nimplemented. Although deriving and documenting a system\u2019s software architecture from \nits implementation in legacy systems provides an excellent avenue for capturing and trans-\nferring knowledge about the system\u2019s design, new development efforts should approach \nsoftware architecture as a forward engineering activity that leads to the implementation of \nsystems and not as a reverse engineering mechanism for documentation. Second, software \narchitecture provides abstractions for software requirements in the design domain, so that \ndesign elements, components, and alternatives all derive from requirements. This suggests \nthat as part of the architectural effort architects must be proficient in activities related to \nrequirements engineering. Third, by specifying that architecture is a collection of design \nelements, it is implied that software architectures are composed of multiple structures and \nthat no one structure can fully describe the software architecture (Bass, Clements, and \nKazman 2003). Fourth, as a design activity that deals with the major system components, \nit\u00a0is suggested that software architecture works at a distinct level of abstraction that differs \nfrom other forms of design, such as detailed design. This means that architectural work \nfocuses on the major components\u2014which become the units of system composition\u2014and \nthe properties and services that these components exhibit and provide to other compo-\nnents. This clearly delineates architectural efforts from other detailed design efforts. Fifth, \na sometimes overlooked or underappreciated piece of the software architecture definition \nis its support for detailed design and construction.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 93", "position": 93, "chunk_type": "semantic", "token_estimate": 390}
{"text": "70\u2002 \u2022\u2002 Software Engineering Design\ufeff: WHY STUDY SOFTWARE ARCHITECTURE? Architectural designs identify the necessary elements\u2014and attributes of those \u00ad\nelements\u2014\nthat support detailed design and construction efforts. These design elements are presented \nin context for examining how well the system as a whole collaborates to meet its intended \nfunctions. In many cases, this includes the modeling of other nonsoftware \u00ad\nelements \n(e.g.,\u00a0physical nodes) that play a key role in assessing the system\u2019s capabilities for achieving \na desired quality goal. An understanding of architectural modeling capabilities is essential \nin problem solving, since they provide the means to overcome functional fixedness early on \nin the development process by allowing designers to model and evaluate the same problem \nfrom different perspectives. Benefits from studying software architecture are also evident in \nnumerous aspects of both product development and management. From the product devel-\nopment perspective, studying software architecture is important for creating an efficient \nbridge between the software requirements phase and the detailed design phase. Having \nextended knowledge of software architecture provides architects with a wider pool of design \nalternatives, some of which have been proven successful in previously developed and similar \nsystems. In these cases, architects can reuse structural design elements and interconnec-\ntions and their responsibilities and can gain insight into their quality properties, all based \non previously used architectures. This provides quick insight into the system\u2019s or individ-\nual component\u2019s ability to meet quality expectations. Besides aiding in product develop-\nment activities, studying software architecture also enhances project managers\u2019 activities \nbecause it helps dictate units of planning, scheduling, and budget; it helps establish inter-\nteam communication channels, configuration control, and file system organization; and it \nhelps manage the integration, test, and maintenance efforts (Bass et al. 2003).", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 94", "position": 94, "chunk_type": "semantic", "token_estimate": 287}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 71: Identifying Stakeholders\u2019 Concerns\nStakeholders are persons, groups, or organizations that have a direct or indirect stake in the \nsystem. They include systems engineers, software engineers, hardware engineers, project \nmanagement, customers and their representatives, testing teams, quality assurance teams, \nand members of the configuration management team. The list of stakeholders and the abil-\nity to manage them from an architectural design\u2019s perspective varies in magnitude and \ncomplexity per project. An important job of the software architect is to ensure that the \nsoftware to be developed addresses stakeholders\u2019 concerns. Stakeholders\u2019 concerns provide \nhigh-level information about desired characteristics of the software system. Therefore, a\u00a0key \nfactor in the architectural design activity is identifying and understanding the different \nways stakeholders influence the system and how they interact with each other. These con-\ncerns need to be elicited and captured before any design effort can begin. Stakeholders\u2019 \nconcerns (e.g., requirements) are the driving force behind architectural decisions and can \ninfluence both product and processes, may be functional or quality in nature, and may have \ndifferent levels of abstraction. During project inception, stakeholders\u2019 concerns are cap-\ntured and specified in a clear and consistent manner to define the expected functions and \nquality of the software system. An essential characteristic of the specification of concerns \nis their ability to provide verifiable specifications, which are used as evaluation criteria for \nall architectural design activities. Therefore, when identifying stakeholders\u2019 concerns, addi-\ntional effort is required so that they are understandable, achievable, and consistent with all \nother identified concerns from all other stakeholders. Identifying Appropriate Architectural Views\nSoftware architects work hard to create designs that achieve all functional and quality features \nexpected from stakeholders. In complex software systems, there can be a multitude of stake-\nholders with myriad backgrounds, all shaping the way the system development is approached \nbased on their perception of what the final product should be. Different perceptions signifi-\ncantly influence the way these stakeholders evaluate the system\u2019s design and determine the \nappropriateness of the design to meet their goals. For this reason, architectural designs must \nsupport different architectural views used to evaluate the design from a particular stakeholder\u2019s \nperspective. By providing different architectural views of the system, communication among \nstakeholders is enhanced during new or ongoing development or during a system\u2019s mainte-\nnance phase.", "domains": ["Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 95", "position": 95, "chunk_type": "semantic", "token_estimate": 384}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 71: For this reason, architectural designs must \nsupport different architectural views used to evaluate the design from a particular stakeholder\u2019s \nperspective. By providing different architectural views of the system, communication among \nstakeholders is enhanced during new or ongoing development or during a system\u2019s mainte-\nnance phase. These architectural views provide designers the ability to address concerns using \na perspective and design elements well suited for analyzing and evaluating the particular prob-\nlem. By using appropriate views, architectural design can be placed in context to yield better \nmodeling and evaluation capabilities. Therefore, the result of any architectural effort must \ncontain design solutions that address one or more viewpoints specific to the problem at hand. Identifying Architectural Styles and Patterns\nThe concepts of architectural styles and patterns are fundamental to the efficient creation \nof software architectures. Architectural styles and patterns provide an overall strategy", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 95", "position": 95, "chunk_type": "semantic", "token_estimate": 147}
{"text": "72\u2002 \u2022\u2002 Software Engineering Design\ufeff: for designing a family of software systems. They provide generic, reusable architectural \nsolutions, documented in a way that is easily understood and applied to new problems \nrequiring similar architectural features. For this reason, identifying architectural styles \nand patterns is one of the first decisions that software architects make. This decision has \nlong-lasting effects on all subsequent design and construction efforts. Decisions based on \narchitectural styles and patterns benefit from years of documented experience that high-\nlight the solution approach to given problems, from the advantages of these approaches, \nand from gaining understanding of the consequences of designing the system with a par-\nticular style. Today, numerous architectural styles and patterns have been documented, \nso software architects need to identify and determine the appropriateness, benefits, and \nconsequences of choosing a particular style or pattern for their system\u2019s design. Identifying System Interfaces\nInterface identification and definition compose another essential task of the software \narchitecture activity. Interfaces are defined for components residing within single physical \nnodes within a single process space, for components residing within a single node in dif-\nferent process spaces, or for components residing in separate processes distributed across a \nnetwork. Interface definition may include the definition of stable interfaces such as abstract \nclasses in object-oriented environments. When using a structured design approach, identi-\nfying internal interfaces can result in determining the set of services required by each archi-\ntectural component to collaborate with all other architectural components. These identify \nthe major access points for architectural components together with the communication \nrules that must be followed during the detailed design activity. Having well-defined inter-\nfaces allows the software system to evolve gracefully with time when existing capabilities \nare modified or new capabilities are added to the system. Defining the interfaces between \ncomponents that reside in different nodes may include specifying messaging structures, \nprotocols, and other communication mechanisms for allowing communication across \ndistributed components. These can include identification of physical medium, data-link \nprotocols, network and transport protocols, messaging specification, and application-level \nprotocols. Identification of external interfaces can significantly impact a system\u2019s ability to \nsupport its identifying quality properties. Identifying Impact of Architectural Decisions in Organization\nDuring the architectural design activity, software architects are required to make decisions \nthat support the efficient development of the software system within bounds placed by \nthe organization mission and goals.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 96", "position": 96, "chunk_type": "semantic", "token_estimate": 389}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 73: in\u00a0practical applications, other key organizational issues need to be addressed to determine \nthe right granularity of components when decomposing a system. When approached this \nway, architectural decisions are driven not only by common design principles discussed in \nChapter 1 but also by other organizational and project-specific factors, such as \u00ad\nstakeholders\u2019 \nconcerns, resource availability, resource location, schedule, and budget. These factors drive \narchitectural decisions to create design solutions that are appropriate for meeting both \nproduct and organizational requirements, therefore bridging the gap between the business \norganization and its technical products. Impact on Customer Base\nDecisions made during the architectural activity affect not only subsequent activities in the \nsoftware life cycle but also stakeholders, especially customers. When faced with competing \nalternatives, each benefiting one customer more than others, architects have to find ways to \nmake decisions that accommodate each customer and minimize overall customer dissatis-\nfaction. In these cases, software architects must be skilled at predicting, verifying, and vali-\ndating the effects of their design decisions. This issue is further complicated by the presence \nof quality requirements. The problem with quality attributes is that they typically contradict \neach other. This property of quality attributes is described in detail by Gorton (2011, p. 37):\nQuality attributes are not orthogonal. They interact in subtle ways, meaning a design that \n\u00ad\nsatisfies one quality attribute requirement may have a detrimental effect on another. For exam-\nple, a highly secure system may be difficult or impossible to integrate in an open environment. Software architects are constantly faced with the challenging task of determining the \neffects of individual design alternatives, identifying conflicting design solutions, negotiat-\ning systems\u2019 features among stakeholders, and verifying and documenting the final archi-\ntectural solution, all of which impact the customer base. Impact on Budget and Schedule\nArchitectural designs provide project management with more concrete representations of \nthe effort required to build the software system. Specifically, they provide the best source \nof information for creating or reevaluating schedules and cost so that they reflect realistic \nand achievable milestones. Once schedule and budget are established, other attributes of \nthe project can be fine-tuned to meet the established goals. For example, architectural \ndesigns can highlight inadequacy in resources required for completing the system on time \nand within budget. In these cases, architectural designs are used as concrete justifica-\ntion for requesting more resources early on in the project life cycle.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 97", "position": 97, "chunk_type": "semantic", "token_estimate": 403}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 73: For example, architectural \ndesigns can highlight inadequacy in resources required for completing the system on time \nand within budget. In these cases, architectural designs are used as concrete justifica-\ntion for requesting more resources early on in the project life cycle. In cases where adding \nresources is infeasible, architectural designs can help justify reevaluation of the strategy, \nwhich requires decision making in all aspects of the project, such as schedule, budget, \nor\u00a0make versus buy decisions. These adjustments based on architectural designs impact", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 97", "position": 97, "chunk_type": "semantic", "token_estimate": 89}
{"text": "74\u2002 \u2022\u2002 Software Engineering Design\ufeff: the development organization\u2019s budget and schedule and are necessary to manage risks, \nto\u00a0maintain customer satisfaction, and to ensure the project\u2019s success. Impact from Resource Availability\nThe previous section introduced human resource availability as an impacting factor in the \ndevelopment project. However, architectural decisions are also affected by other differ-\nent forms of resource availability. Resource availability, such as employees, software, and \nhardware, can all prompt adjustments to the architecture. Architectural designs that take \ninto account human resources can maximize employee efficiency throughout the detailed \ndesign and construction phase. By taking into account employee availability, location, and \nteam composition, work can be compartmentalized and developed in parallel. Employees \nthat are distributed across different sites can prompt the creation of components with \nwell-defined interfaces that can be developed independently and integrated into the sys-\ntem with minimal effort. Hardware availability can also prompt adjustment in the software \narchitecture. In cases where hardware availability is essential to the development and test \nof software, the architecture may be adjusted to provide simulation components that can be \nused to move the development effort forward in case hardware is unavailable. In these cases, \nconstruction and test can continue until the hardware becomes available. At any point, the \nsimulation component can be swapped easily for the real hardware component without \nchanges to the overall architecture or software. The same approach can be employed for \nother software resources that are essential to the development of the system. Identifying the System\u2019s Major Components and Interfaces\nA major task performed during the software architecture activity involves decomposing \nsystems into manageable component units. In doing so, it is important to identify the inter-\nfaces that these components use to collaborate with each other. Components and interfaces \nare identified during system decomposition; however, the nature of these significant ele-\nments varies according to the perspective used for system decomposition. In the broad \ncontext of system decomposition, identifying the major components and interfaces may \ninvolve, for example, logical components, physical nodes, files, or directories, and physi-\ncal or logical interfaces required for these components to interoperate with each other. Examples of identifying logical and physical components and their interfaces are presented \nin Chapter 4. Evaluating and Validating the Architecture\nConsider designing a large-scale, secure, high-performing, distributed system composed \nof multiple nodes, each with usable interfaces, all while emphasizing the system\u2019s \u00ad\ntestability \nand maintainability.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 98", "position": 98, "chunk_type": "semantic", "token_estimate": 397}
{"text": "74\u2002 \u2022\u2002 Software Engineering Design\ufeff: Examples of identifying logical and physical components and their interfaces are presented \nin Chapter 4. Evaluating and Validating the Architecture\nConsider designing a large-scale, secure, high-performing, distributed system composed \nof multiple nodes, each with usable interfaces, all while emphasizing the system\u2019s \u00ad\ntestability \nand maintainability. In addition, the system needs to be built using a joint approach among \nthree organizations in separate geographical locations. For such development efforts, an \nunsuitable architecture is a recipe for disaster. Therefore, software architecture evaluation", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 98", "position": 98, "chunk_type": "semantic", "token_estimate": 85}
{"text": "Software architects spend a great deal of time working with software requirements. Even: after requirements are specified, software architects find themselves going back and forth \nbetween requirements and design to clarify them, correct them, or completely revise them. In some cases, software architects are completely immersed in the requirements process, \nplaying a key role in specifying the requirements of the system. For this reason, software \narchitects need to understand RE, the discipline within software engineering that is con-\ncerned with the systematic approach to requirements specification, mainly through the \nfollowing activities (Abran, Moore, Bourque, and Dupuis 2005):\n\u2022\t Elicitation\n\u2022\t Analysis\n\u2022\t Specification\n\u2022\t Validation\nTogether, these activities are performed to express the needs and constraints placed on the \nsoftware system, which provides the foundation for all architectural and subsequent design \nand construction work. Understanding RE and how the fundamental activities relate to \ndesigning software architectures provides architects with a different dimension for design-\ning successful systems by filling gaps or making appropriate corrections to the software \n\u00ad\nspecification before committing to a particular design solution. Elicitation\nElicitation is the requirement activity that deals with identifying stakeholders, with \nuncovering what the customer needs and wants, and with determining the (often over-\nlooked) nonfunctional requirements (Laplante 2009). Elicitation begins by identifying all \nsources of information that can be used to generate requirements. Sources of informa-\ntion vary from project to project and can provide bias information to shape the system \nin a way that addresses their particular needs. Sources of information also come from a \nvariety of backgrounds; therefore, the use of techniques that are effective in extracting \nimportant information from a variety of sources with different expertise and background \nis essential. Requirement Sources\nSoftware requirements originate from many different sources. In some cases, require-\nments may originate from one source with an overall strategy and consistent vision for \nthe system, which makes analyzing, specifying, and validating requirements more man-\nageable. In most large-scale software efforts, requirements originate from many different \nsources with similar but inconsistent visions for the system. In these cases, identifying", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 103", "position": 103, "chunk_type": "semantic", "token_estimate": 343}
{"text": "80\u2002 \u2022\u2002 Software Engineering Design\ufeff: By transforming goals to nonfunctional requirements, they can be used \nnot only for decision making during architectural, detailed, and construction design but \nalso as evaluation criteria during system test, after the system is designed, constructed, and \nunit tested. A list of common quality attributes with descriptions is presented in Table\u00a03.1. Domain knowledge provides an essential source for requirements since it provides \ndetails of how the system should behave and help determine obscure functions that the \nTABLE\u00a03.1\nCommon Quality Attributes for Software Systems\nQuality\nDescription\nUsability\nA goal that seeks to minimize the degree of complexity involved when learning or using the \nsystem\nModifiability\nA goal that seeks to minimize the degree of complexity involved when changing the system \nto fit current or future needs\nSecurity\nA goal that seeks to maximize the system\u2019s ability to protect and defend its information or \ninformation system\nPerformance\nA goal that seeks to maximize the system\u2019s capacity to accomplish useful work under time \nand resource constraints\nReliability\nA goal that seeks to minimize the system\u2019s failure rate\nPortability\nA goal that seeks to minimize the degree of complexity involved when adapting the system \nto other software or hardware environments\nTestability\nA goal that seeks to minimize the degree of complexity involved when verifying and \nvalidating the system\u2019s required functions\nAvailability\nA goal that seeks to maximize the system\u2019s uptime\nInteroperability\nA goal that seeks to maximize the system\u2019s ability to collaborate with other software or \nhardware systems", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 104", "position": 104, "chunk_type": "semantic", "token_estimate": 250}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 81: system needs to provide in special cases. This knowledge is obtained through the design \nand development of similar systems or through involvement in the development effort \nunder different disciplines, such as hardware, test, and management. Finally, the opera-\ntional and organizational environment can be used as a source for requirements common \nto software product lines within the organization to maintain consistency among all prod-\nucts developed in the organization. Elicitation Techniques\nDifferent stakeholders view systems differently, based on their specific background and \nspecialization. When eliciting information from different stakeholders, it is sometimes \ndifficult to compile a consistent set of requirements, since needs from stakeholders may \ncontradict each other. Therefore, effective elicitation techniques are required to gather and \nconsolidate a consistent set of requirements for the system. Some of the most common \ntechniques for requirements elicitation include (Abran et al. 2005):\n\u2022\t Interviews\n\u2022\t Facilitated meetings\n\u2022\t Observation\n\u2022\t Scenarios\nInterviews and facilitated meetings are both common techniques for requirement elicita-\ntion. During interviews, meetings are scheduled individually with different stakeholders \nto bring forth their particular needs and gain understanding of their particular expecta-\ntions for the system. On the other hand, facilitated meetings are performed with a group \nof stakeholders to bring forth a collective vision and to gain more insight into the overall \nexpectations of the system. Typically, facilitated meetings include a moderator, the design \nteam, and peer reviewers (including stakeholders). By eliciting requirements in a collec-\ntive fashion, details that affect different stakeholders can be identified, negotiations can be \nmade, and collective resolutions can be achieved. Information from both interviews and \nfacilitated meetings needs to be carefully documented, further elaborated, and iteratively \nrefined until a solid grasp of the system needs is acquired. In many cases, stakeholders are unaware or cannot articulate desirable system features. When this occurs, observations of similar systems can help capture desired functions of \nthe system behavior under particular (nonobvious) conditions. This information can be \nlearned to gain insight into a particular system behavior, quality, or interaction and used \nto generate appropriate requirements for the system. When systems are hard to specify, \nobservation allows both engineers and stakeholders to effectively conceptualize and trans-\nfer knowledge required to yield important system information; however, in some cases it \ncan be intrusive, expensive, or impossible. Finally, a popular approach to eliciting requirements is through scenarios.", "domains": ["Design Principles"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 105", "position": 105, "chunk_type": "semantic", "token_estimate": 394}
{"text": "82\u2002 \u2022\u2002 Software Engineering Design\ufeff: are born out of perceived expected behavior by the software architect and refined and vali-\ndated through stakeholders\u2019 reviews. Scenarios provide a valuable means for establishing \na framework for eliciting requirements, identifying major system functions and details of \nthe software, and providing initial insight in the required testing of the software. In\u00a0Unified \nModeling Language (UML), scenarios can be grouped by use cases, as presented in Chapter \n2. For each use case, one or more scenarios\u2014one for the main flow of events and others for \nalternate scenarios\u2014are created to document the expected system behavior and deviations \nfrom its main flow of events. Scenarios represent instances of use cases; therefore, there \nexists a one-to-many relationship between use cases and scenarios. Since there are no uni-\nversal methods accepted as standard for formatting and capturing scenarios, scenarios can \nbe created as paragraphs, numbered list, tabular or graphical form, or any other convenient \nform that is appropriate for systems analysis and knowledge transfer. Table\u00a03.2 contains a \nsample scenario for the Search Product use case presented in Chapter\u00a02. Scenarios provide an effective method for eliciting the system\u2019s functions and serve as \nexcellent communication avenue between stakeholders and engineers. They also provide \nan effective method for identifying quality information that can lead to the creation of \nnonfunctional requirements. By presenting a particular quality attribute within context, \nstakeholders can get a better appreciation of how it relates and affects the system. For \nexample, as seen in step 3 of the search product\u2019s main scenario, a statement of perfor-\nmance is initially brought forth for evaluation and (if necessary) modification to specify \nthe actual expected performance of the system. In this example, the scenario helped iden-\ntify an important quality of the system, and, if required, prototypes can be developed to \nfurther evaluate the adequacy of the desired performance. Skill Development 3.2: Eliciting Requirements Using Scenarios\nUse any of the other remaining use cases presented in Figure\u00a02.4, and create a detailed \nscenario description including steps, operator actions, and system actions. After \n\u00ad\ncompleting the task, can you think of any quality requirements that can be derived from \nthe \u00ad\nscenario? Explain. Lists the steps that would you consider taking after completion \nof the scenario to ensure that requirements derived from the scenario are \u00ad\nincorporated \ninto the system.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 106", "position": 106, "chunk_type": "semantic", "token_estimate": 389}
{"text": "84\u2002 \u2022\u2002 Software Engineering Design\ufeff: importance of each requirement and can serve as a driver for prioritization of work units \nand negotiation and trade-off throughout. Common criteria for classifying requirements \nare presented in Table\u00a03.3. Prioritization of requirements is done to help identify the most important functions of the \nsoftware system. When done properly, prioritization can help refine the projected schedule \nby determining which requirements (or component carrying out these requirements) need \nto be developed first or can help identify different builds of the software \u00ad\nsystem, which \ncan be designed, developed, and deployed at different times. Prioritization also helps dur-\ning requirement negotiation when conflicts between requirements are identified during \nanalysis. When this occurs, negotiation takes place among stakeholders, and resolutions \nto conflicts are made while taking into account requirement priorities. Finally, an integral \ntask of the analysis activity is conceptual modeling. Conceptual models are created to fur-\nther identify the requirements by understanding their context, discovering the bounds of \nthe software system, and conceptualizing how the system interacts with its environment. In many projects, conceptual modeling is where architectural design begins, since system \ndecomposition is essential to developing effective conceptual models. Specification and Validation\nSpecification is the activity of the requirements phase where the results of elicitation and \nanalysis are formally captured and documented in an appropriate format for the use and \nreview of all stakeholders. The format of the specification varies depending on the develop-\ning organization or project; however, it is typically produced as a document or its electronic \nequivalent (Abran et al. 2005) and is referred to as the software requirements specifica-\ntion (SRS). When specifying requirements, it is important that each requirement exhibit \n\u00ad\ncertain characteristics desired for designing successful systems, including the following:\n\u2022\t Specific\n\u2022\t Correct\n\u2022\t Complete\n\u2022\t Consistent\n\u2022\t Attainable\n\u2022\t Verifiable\nTABLE\u00a03.3\nCommon Criteria for Requirement Classification\nCriteria\nDescription\nFunctional vs. \nnonfunctional\nClassification that differentiates between requirements that specify the functional \naspects of the system versus the ones that place constraints on how the functional \naspects are achieved\nProduct vs. process\nRequirement placed on the system product versus requirements placed on the process \nemployed to build the product\nImposed vs. derived\nRequirements imposed by stakeholders versus requirements that are derived by the \ndevelopment team", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 108", "position": 108, "chunk_type": "semantic", "token_estimate": 376}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 85: Once requirements are specified and the SRS is created, validation can occur. \u00ad\nRequirements validation is the process of ensuring (through well-known techniques) that \nthe SRS provides a complete and correct representation of what the stakeholders need \n(Laplante\u00a02009). Specific\nRequirements need to be specified in a clear, concise, and exclusive manner. Clear require-\nments are not open to interpretation; unclear or ambiguous requirements lead to incorrect \ndesigns, incorrect implementations, and deceptive validation during test. Concise require-\nments are brief and to the point and are therefore easier to understand. Finally, exclusive \nrequirements specify one, and only one, thing, making them easier to verify. Consider the \nfollowing statements:\n\u2022\t The software needs to provide an easy-to-use interface; that is, it must be usable. \u2022\t Speed is a concern; therefore, the software should operate with high performance. \u2022\t Software evolution is a concern; therefore, the software shall be testable and \nmaintainable. These statements provide important information to begin thinking about what the cus-\ntomer wants and expects from the software system. However, in their current form, the \nstatements are too generic to use as a basis for design, construction, and verification of \nsoftware systems. For example, a console-based user interface may be highly visible for \nthe system\u2019s developers but not its customers or intended users. Alternatively, the \u00ad\nsystem\u2019s \ntechnical developers may interpret speed as the system responding to received mes-\nsage within 5 milliseconds; anything above would be considered an infeasible solution. Designing the system based on this interpretation may entail sacrificing other functions \nthat may be important to customers and users, when all the while customers and intended \nusers perceived speed as receiving responses within 2 seconds. When left unresolved, state-\nments like these become a major reason for the failure of the project. Examples of specific \nrequirements are presented in Table\u00a03.4. TABLE\u00a03.4\nExample of Specific and Nonspecific Requirements\nSpecific\nRequirement\nNo\nThe software shall search the database. Yes\nThe software shall search for a product using the product ID. No\nThe software shall be secure. Yes\nThe software shall authenticate users with user ID and password. No\nThe software shall be secure and fast. Yes\nThe software shall authenticate users with user ID and password. Server acknowledgment message shall be sent within 1/2 second from the time a request is received.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 109", "position": 109, "chunk_type": "semantic", "token_estimate": 391}
{"text": "86\u2002 \u2022\u2002 Software Engineering Design\ufeff: Correct\nRequirements need to be correct in the sense that they must accurately describe a desired \nsystem function. Similar to ambiguous or unclear requirements, specifying incorrect system \nfunctions leads to a chain of incorrect solutions in subsequent development phases. In some \ncases, correctness of requirements is easily identified; in others, it is not. To illustrate this \nproblem, Laplante (2009) presents an example based on requirements for a computer secu-\nrity system for which it requires users to log on using a unique combination of user ID and \npassword. In this case, when users attempt to log on using an already existing user name or \npassword, the system is required to reject the attempt, therefore giving insight into someone \nelse\u2019s logon information. Incorrect requirements, when left unchecked, can lead to incor-\nrect or undesired behavior, such as the vulnerability found in the computer security system \ndescribed above. Examples of correct and incorrect requirements are presented in Table\u00a03.5. Complete\nRequirements should be complete both individually and as collective set. This means that \neach requirement should be specified thoroughly so that it absolutely describes the func-\ntions required to meet some need. Collectively, requirements need to provide complete \nspecification of the software\u2019s required functionality in the SRS. Incomplete requirements \nlead to incomplete designs, which in turn leads to incomplete construction of the software \nsystem. Requirements that are complete help clarify questions during construction and \ntesting by providing the information necessary to disambiguate or prevent misinterpre-\ntations of required functionality. Consider requirements for a software system that sup-\nports generation of product reports. An example of an incomplete requirement created for \nthis system is presented in Table\u00a03.6. As seen, determining incomplete requirements is not \nalways an easy task. As seen, the first requirement presented in Table\u00a03.6 specifies the system\u2019s function to \ngenerate product reports; this is a good requirement in the sense that it specifies a function \nTABLE\u00a03.5\nExample of Correct and Incorrect Requirements\nCorrect\nRequirement\nNo\nThe software shall require users to log on using a unique combination of user ID and password. Yes\nThe software shall require users to log on using a user ID and password. The software shall require users to log on using a valid e-mail address. TABLE\u00a03.6\nExample of Complete and Incomplete Requirements\nComplete\nRequirement\nNo\nThe software shall generate product reports.", "domains": ["Software Quality Attributes", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 110", "position": 110, "chunk_type": "semantic", "token_estimate": 394}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 87: that the system must perform. However, when additional information is available, this \nrequirement becomes incomplete when this information is not specified and is necessary \nfor providing the correct function that meets a particular stakeholder\u2019s need. Consider the \ncase where products have vast amounts of information, such as color, dimensions, store \nlocation, \u00ad\nhistory, and other product information. Generating reports containing all prod-\nuct information may be undesirable if the intended reporting function requires only the \nproduct\u2019s description, picture, and price. In this case, making requirements as complete \nas possible improves the efficiency of the construction and verification phases. Consider \nanother case where there is a need for a client system to interoperate with two existing leg-\nacy servers by sending and receiving messages back and forth using two different (already \nexisting) \u00ad\nmessaging specifications. A requirement that fails to specify a mandate to inter-\noperate with both existing servers supporting both messaging specification may easily lead \nto \u00ad\nclient \u00ad\nsystems that are unable to interoperate with one of the servers, therefore render-\ning the \u00ad\nclient unusable for the system in mind. Completeness is hard because it is not \nalways obvious or it is sometimes too difficult to determine when information is missing \n(Laplante\u00a02009). Consistent\nRequirements are consistent when they do not preclude the design or construction of \nother requirements. When they do, individual requirements or the SRS as a whole are \nreferred to as inconsistent. Inconsistent requirements are hard to resolve, since they almost \nalways originate from different stakeholders\u2019 needs. When this occurs, negotiation and \ntrade-offs need to occur to consolidate the requirements and provide a consistent specifica-\ntion. Requirements can also be inconsistent due to incorrect requirements. In these cases, \nrequirements are made consistent easily by removing them from the SRS. Attainable\nRequirements that are unattainable serve no purpose. Attainability is a property that spans \nmany different characteristics of the software system, including product characteristics \nsuch as functionality as well as project characteristics such as cost and schedule. When \nspecifying requirements, it is important to evaluate their attainability under both cost and \nschedule constraints. Examples of attainable and unattainable requirements are presented \nin Table\u00a03.7. As seen, although it is nice to develop software without platform limitations \nnow or in the future, verifying this requirement is impossible since it is unattainable.", "domains": ["Design Principles", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 111", "position": 111, "chunk_type": "semantic", "token_estimate": 391}
{"text": "In a typical waterfall model for software development, once the software specification: (i.e.,\u00a0SRS) is validated, the architectural design effort can begin. In practical applications, \nfollowing a strict waterfall model is rarely productive, since new knowledge acquired dur-\ning the development process forces iterative approaches between requirements and archi-\ntectural design. As discussed in previous sections, architectural designs can begin as early \nas the analysis activity of the requirements phase, where conceptual models of the system \nare devised. In either case, be it during requirements or design, designing architectures \nrequire the selection of particular perspectives for design that are appropriate for describ-\ning the system to be developed. To this end, several models have been created that suggest \npopular views that are useful in the design of most systems. These models propose address-\ning the system\u2019s architectural design from perspectives that are common to most software \nTABLE\u00a03.8\nExample of Verifiable and Unverifiable Requirements\nVerifiable\nRequirement\nNo\nThe system shall maximize communication speed. Yes\nThe system\u2019s data rate shall be no less than 1 Mbps.", "domains": ["Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 112", "position": 112, "chunk_type": "semantic", "token_estimate": 175}
{"text": "90\u2002 \u2022\u2002 Software Engineering Design\ufeff: architectural design decisions. The user view also provides an effective source of informa-\ntion for verifying and validating system functions, after the system is built. In\u00a0addition to \nUML use cases, UML activity diagrams can be used to flush out important user interactions \nthat are important during architectural design (Pressman 2010). Process View\nThe process view of a software system represents the dynamic or behavioral aspects of the \nsoftware system where the main units of analysis are processes and threads. Using this \nview, software systems are decomposed into processes and threads to address design issues \nthat deal with the dynamic flow of control between architectural elements, such as concur-\nrency, distribution, system\u2019s integrity, fault tolerance, and other nonfunctional require-\nments (Kruchten 1995). Since analysis using the process view is behavioral in nature, \nbehavioral UML diagrams can be used efficiently to address issues pertinent to the process \nviews. Particularly, UML sequence and communication diagrams, together with the active \nobject notation (presented in Chapter 2), can be used to evaluate, analyze, and characterize \nthe system\u2019s capabilities from the process perspective. This view is necessary for projects \nthat need to meet performance and availability requirements by modeling aspects of con-\ncurrency, distribution, and fault tolerance. Physical View\nThe physical view of a software system represents the deployment aspects of software systems \nwhere the main elements of analysis are nodes, connections between nodes, and maps of \nsoftware artifacts to nodes. The physical view focuses on modeling of elements that directly \naffect quality requirements, such as availability, performance, and scalability (Kruchten \n1995). For example, consider a case where system quality is measured in part by the avail-\nability of the system. That is, systems are perceived as low quality when they fail to provide a \nspecified behavior. In this case, availability can be addressed via redundancy of processors or \ncomplete nodes, which both can be depicted using UML deployment \u00ad\ndiagrams. The identifi-\ncation of redundant nodes using the physical view requires downstream design and develop-\nment to think about techniques for identifying faults and swapping between primary and \nredundant nodes when necessary to support the system\u2019s availability. Similarly, aspects that \naffect system performance must be addressed using the physical view. When performance \nis measured with throughput, the physical view of \u00ad\nsystems must identify the elements that \ndirectly impact this metric, such as required bandwidth between a client and server.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 114", "position": 114, "chunk_type": "semantic", "token_estimate": 401}
{"text": "90\u2002 \u2022\u2002 Software Engineering Design\ufeff: Similarly, aspects that \naffect system performance must be addressed using the physical view. When performance \nis measured with throughput, the physical view of \u00ad\nsystems must identify the elements that \ndirectly impact this metric, such as required bandwidth between a client and server. In some applications, modeling system deployment may require one or more UML \ndeployment diagrams. Different deployment diagrams may be necessary to model dif-\nferent deployment configurations of the same software system, for example, deployments \nof software systems in testing environments or in different locations where deployment \nconfigurations may differ. In each case, the physical view provides insight into necessary \nelements that directly affect the perceived quality of the software system. An example of \nthe physical view of software systems is presented as a deployment diagram in Chapter 2.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 114", "position": 114, "chunk_type": "semantic", "token_estimate": 136}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 91: Development View\nThe development view of software systems represents the software development configu-\nration aspects of the software system, where the main units of decomposition are actual \nphysical files and directories. The development view is used to analyze the system from the \nperspective of how logical components map to physical files and directories. These analyses \ncan be employed to address concerns that deal with ease of development, \u00ad\nreusability, con-\nstraints imposed by tool sets, allocation of work to teams, cost evaluation and planning, \nmonitoring the project\u2019s progress, portability, and security (Kruchten 1995). In\u00a0 UML, \narchitectural elements resulting from analyzing systems from the development\u2019s perspec-\ntive can be documented using package diagrams in combination with components and \nclass diagrams as well as notes, tagged values, and constraints to enhance the meaning \nof the diagrams. This way, components can be mapped to the hierarchy of files in the file \nsystem, and their interrelationships and process for building one or more versions of the \nsoftware system can be carefully specified. Logical View\nThe logical view of a software system is used to decompose systems into logical compo-\nnents that represent the structural integrity that supports functional and nonfunctional \nrequirements. Examples of architectural design elements using the logical view are pre-\nsented in Figure\u00a02.1. Using this view, the static structure of the system can be modeled \nusing high-level diagrams to decompose, abstract, and encapsulate the services that the \nsystem needs to provide to its users. By using these diagrams, the major components, their \ninterfaces, and their associations with all other components are identified. Architectural \nlogical designs exist at a higher level of abstraction than detailed designs and can be mod-\neled using box and line diagrams, UML component diagrams, package diagrams, or class \ndiagrams. Architectural logical designs provide the building blocks for detailed design; \ntherefore, they are indispensable in the architectural design of software systems. Skill Development 3.4: Designing with Architectural Views\nAs seen, views are used to present the system from particular perspectives so that \ndesign elements particular to that perspective can serve as tool for evaluating a desired \nproperty of the system. Using the logical view, the system\u2019s reusability can be evalu-\nated; through the physical view, the system\u2019s availability can be examined; and the pro-\ncess view can be used to evaluate the system\u2019s performance.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 115", "position": 115, "chunk_type": "semantic", "token_estimate": 392}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 91: Skill Development 3.4: Designing with Architectural Views\nAs seen, views are used to present the system from particular perspectives so that \ndesign elements particular to that perspective can serve as tool for evaluating a desired \nproperty of the system. Using the logical view, the system\u2019s reusability can be evalu-\nated; through the physical view, the system\u2019s availability can be examined; and the pro-\ncess view can be used to evaluate the system\u2019s performance. Consider the architectural \ndesign of two systems: a banking information system and a safety-critical medical sys-\ntem. For each system, come up with appropriate views\u2014feel free to come up with ones \nother than those presented in this chapter\u2014and how they could help address particular \nconcerns in each. Discuss and justify your results with peers.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 115", "position": 115, "chunk_type": "semantic", "token_estimate": 133}
{"text": "92\u2002 \u2022\u2002 Software Engineering Design\ufeff: Components and Connectors\nIn Chapter 2, components were presented to depict units of the logical architecture. Conceptually, a component is an entity that encapsulates some functionality and provides \nservices through well-known interfaces. By definition, then, components can be replace-\nable by other components that provide equal interfaces. Components are building blocks \nthat exemplify the general design principles of abstraction, encapsulation, and modular-\nization presented in Chapter 1. Prior to UML 2.0, the concept of components was different \nin that it denoted specifically a physically deployable unit, which limited the use of the \ncomponent entity in architectural diagrams. However, this is not the case in the current \nversion of the UML, so the component concept can be used to model logical, modular \nparts of a system. Components do not exist in isolation; they are part of a logical architecture that depicts \ninteractions with other components. In some applications, interactions between compo-\nnents are far more complicated than what UML\u2019s typical relationships (e.g., association, \ndependency) can reflect. In these systems, the proper identification and description of \nsuch interactions can have a profound impact on quality requirements. For this reason, the \nconcept of a connector is devised. A connector is an architectural entity that abstracts the \ncomplexities of the interactions between components. Therefore, connectors can represent \ninteraction between components as simple procedure calls, shared data access, or more \nadvanced mechanisms such as remote procedure calls (Taylor, Medvidovic, and Dashofy \n2009). Together, components and connectors can be used as fundamental building blocks \nfor large-scale software architectures. Designing Logical Architectural Elements Using Data Flows\nThere are many approaches for designing logical architectures. These approaches are typi-\ncally associated with the overall design strategy selected for a given product. For example, \nwhen using the structured design strategy, a disciplined approach is employed to decom-\npose systems into independent, single-purpose modules, using an iterative top-down \napproach. The main focus of structured design is on the functions that systems need to \nprovide, the decomposition of these functions, and the creation of modules that incorpo-\nrate these functions. Structured design approaches are typically employed after structured \nanalysis, where the main purpose is to derive a structure chart (i.e., logical software archi-\ntecture) from data flow diagrams (DFDs). A popular approach for creating structure charts \nincludes employing transform analysis (Pressman 2010).", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 116", "position": 116, "chunk_type": "semantic", "token_estimate": 386}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 93: Designing Logical Architectural Elements Using Styles and Patterns\nIn the 1990s, the software engineering community began paying attention to recurring \narchitectural solutions in terms of specific elements and their relationships. These solu-\ntions were known as architectural styles and patterns; these terms are used interchangeably \nthroughout (see Chapter 4). Architectural patterns provide the means for software architects \nto reuse architectural design solutions in different projects. Buschmann, Meunier, Rohnert, \nSommerlad, and Stal (1996) introduced a catalog of architectural patterns that conveyed \nfundamental structural organization for software systems, including predefined compo-\nnents, their responsibility, and rules for specifying the relationship between them. Together, \nthese architectural patterns serve as a blueprint for designing elements of the logical archi-\ntecture of particular groups of systems. The application of architectural patterns to the \ndevelopment of software systems occurs at the highest level of abstraction in the design pro-\ncess. Since they are used to create architectural elements, they do not describe the detailed \ndesign of the system and therefore cannot be directly translated into code. Identifying pat-\nterns at the architectural level (and designing around them) improves the quality of the final \nsystem by reducing the design of logical architectural elements to a \u00ad\ncollection of interacting \ncomponents whose expected behavior is well understood. Examples of architectural design \nelements using architectural patterns are presented in Chapter 4. Designing the Process Architecture\nWhereas logical elements of the software architecture model static, structural aspects of the \nsoftware system, process elements model how elements interact to evaluate certain aspects \nof the software\u2019s quality, such as concurrency. In software systems, concurrency is achieved \nmainly though multithreading or multiprocessing the system. Multithreading or multi\u00ad\nprocessing applications introduce concurrency issues that require careful analysis to ensure \nthat architectural designs account for effective synchronization techniques. Concurrent \ndesigns that work on the same data are tougher to design and manage since they can lead to \nsoftware errors that are hard to find (e.g., race conditions) and increase the complexity of the \nsoftware development effort. To fully understand and model issues such as performance, one \nmust have some understanding of the universal mechanisms in place when software applica-\ntions execute. Although code has no place during the software architecture activity, every soft-\nware architect must understand how the modeling of process elements affects the downstream \nwork performed during construction.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 117", "position": 117, "chunk_type": "semantic", "token_estimate": 391}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 93: To fully understand and model issues such as performance, one \nmust have some understanding of the universal mechanisms in place when software applica-\ntions execute. Although code has no place during the software architecture activity, every soft-\nware architect must understand how the modeling of process elements affects the downstream \nwork performed during construction. For this reason, an unconventional learning approach \ninvolving code in the study of software architecture to introduce important architectural \nconcepts and present the process view of software architecture is employed. This under-\nstanding is essential when modeling parts of the software that will affect its process quality. Processes\nProcesses and threads are fundamental units of execution in today\u2019s modern software \n\u00ad\nsystems. They are created, managed, and terminated by the operating system. A process is", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 117", "position": 117, "chunk_type": "semantic", "token_estimate": 135}
{"text": "94\u2002 \u2022\u2002 Software Engineering Design\ufeff: a unit of software execution, that is, a program in execution. When you execute software, \nfor example, an executable (.exe) file in Windows, a process is created by the Windows \noperating system. This process has some unique characteristics that distinguish from other \nprocesses. Whenever a process is created, the operating system creates a process control \nblock (PCB) with information required by the operating systems to schedule and manage \nthe process. This information can include the program counter, process state, registers, and \nstack. In single-processor systems, the operating system uses this information to switch \nbetween different processes while maintaining the integrity of all processes. This switch-\ning, known as a context switch, requires saving the information from a PCB of the active \nprocess and loading a PCB of the new process into memory to continue execution. A con-\ntext switch is pure overhead, since the processor\u2019s time is spent doing management tasks \nrather than useful work for the software system; however, it enables concurrency. These \noperations happen so quickly that programs executing are perceived as executing concur-\nrently. In single-processor systems, this pseudo-concurrency allows designers to model the \nsystem with concurrency in mind. In multiprocessor systems, processes are scheduled for \nexecution in more than one processor, so actual concurrency is achieved. In either case, \nconcurrency is used to increase the performance of the software system. Software systems, \nespecially distributed systems, can be designed as systems of multiple processes executing \non the same or different networked computing platforms. Multiple processes are used to \nleverage off the operating system to achieve concurrency of operations and increase the \n\u00ad\nsystem\u2019s performance. That is, modern operating systems provide scheduling mechanisms \nthat allow multiple processes to execute concurrently to maximize CPU usage. Threads\nThreads, sometimes called lightweight processes, are similar to processes in that they allow \ncode to be compartmentalized in a way that they are schedulable as independent flows \nof control by the operating systems. In most modern operating systems, threads execute \nwithin a single process in a one-to-many fashion\u2014that is, one process can contain one or \nmore threads. Threads, therefore, can be thought of as small, schedulable, and sequential \nprogram units executing (typically) within a process.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 118", "position": 118, "chunk_type": "semantic", "token_estimate": 367}
{"text": "94\u2002 \u2022\u2002 Software Engineering Design\ufeff: In most modern operating systems, threads execute \nwithin a single process in a one-to-many fashion\u2014that is, one process can contain one or \nmore threads. Threads, therefore, can be thought of as small, schedulable, and sequential \nprogram units executing (typically) within a process. Processes that execute with only one \nthread can be described as sequential, or serial, which means that the commands in the \nprograms are executed in turn so that a specific command is executed only after the previ-\nous command is finished. In single-threaded applications, if one statement halts waiting \nfor some computer resource (e.g., input\u2013output resource), the execution of the program \nblocks until the resource becomes available and execution can continue. For example, \n\u00ad\nconsider the code in Listing 3.1. In the Windows operating system, when the code in Listing 3.1 is compiled and built, \na file with an .exe extension is created. When this file is executed, a process is created \nwith one thread, whose body of execution is defined by the main function. In this case, \nthe operations in the main thread will execute sequentially until the return operation is \nencountered, at which point the operating system destroys both thread and process and the \nprogram is \u00ad\nfinished. Since there is only one independent flow of execution (i.e., one thread),", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 118", "position": 118, "chunk_type": "semantic", "token_estimate": 219}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 95: the program will halt at the cin>>number line until a number followed by the return \nkey is entered as input. This is true because the cin>> line results in a \u00ad\nblocking\u00a0call to the \noperating system; that is, the main thread will block execution until input is provided. While blocking, the program wastes execution time in the sense that it is not utilizing the \nprocessor for achieving other necessary application-dependent tasks. When the thread is \nblocked, the process can accomplish nothing else, since there is only one flow of execution. When multiple threads execute, multiple independent flows of control exit, so that if one is \nin a blocking state others can continue executing. To achieve this, the operating system needs \nto execute context switches to manage the program execution among the different threads \nin pseudo-concurrent fashion at the expense of causing similar but reduced overhead as the \nones described with processes. By allowing the executing software to perform other activi-\nties while waiting for some resource, its performance may be enhanced. Consider Listing 3.2 \nfor a number-guessing game where the executing software counts until user input is received \nand then determines if the input (i.e., guessed number) matches the counted number. When this program executes, a single process is created, and its main thread is \u00ad\nexecuted. As the main thread executes sequentially, a counter object of ThreadCounter type \nis \u00ad\ncreated. The ThreadCounter type abstracts the creation of another thread that is \nstarted by calling the object\u2019s count\n() method, which results in an independent flow of \nListing 3.1: C++ Code for Single-Threaded Application\n#include <iostream>\nusing namespace std;\nint main( int argc, char* argv[] ) {\n\t // A number to be guessed. const int THE_NUMBER = 10;\n\t // User input. int number;\n\t // Display message to user. cout<<\u201dGuess a number from 0-100:\\n\u201d;\n\t // Block waiting for user input. cin>>number;\n\t // Display results to user. cout<<\u201cYour guess is \u201d<<number<<\u201c, actual number is \u201d \n<<THE_NUMBER<<endl;\n\t // End of program. return 0;\n}", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 119", "position": 119, "chunk_type": "semantic", "token_estimate": 339}
{"text": "96\u2002 \u2022\u2002 Software Engineering Design\ufeff: execution created tasked with counting. This allows the main thread to continue execut-\ning sequentially while the counter thread counts. The main thread will block waiting for \nuser input (via cin) while the counter thread continues to count, therefore introducing \nconcurrency into the software. Once user input is received, the main thread terminates \nthe counter thread and displays the results. This process is presented in Figure\u00a03.3 using a \nsequence diagram with active objects relying on synchronous and asynchronous messages. Notice that once the counter threads calls its start\n() method, it counts and does nothing \nelse until it is finished counting, which is triggered by the stop() method. This is modeled \nusing the synchronous message to self. The code presented in Listing 3.2 serves as a good example for introducing the concept \nof concurrency in a simplified manner. Concurrency issues are always amplified when \ndata need to be shared among concurrent flows of executions. In these cases, correct \nListing 3.2: C++ Code for Concurrent Number-Guessing Game\n#include <iostream>\n#include \u201cThreadCounter.h\u201d\nusing namespace std;\nint main( int argc, char* argv[] ) {\n\t // User input. int number;\n\t // Create the thread counter object. ThreadCounter counter;\n\t // Start the counter. counter.count();\n\t // Display message to user. cout<<\u201dGuess a number from 0-100:\\n\u201d;\n\t // Block waiting for user input. cin>>number;\n\t // Stop the counter. counter.stop();\n\t // Display results to user. cout<<\u201cYour guess is \u201d<<number<<\u201c, actual number is \u201d\n\t\n<<counter.current()<<endl;\n\t // End of program. return 0;\n}", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 120", "position": 120, "chunk_type": "semantic", "token_estimate": 248}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 97: synchronization mechanisms need to be in place to ensure the proper execution of the soft-\nware system. Consider the case of a communication system receiving messages concurrently \nthrough two different interfaces. Upon receiving messages, the system updates its message \ncount statistic and continues on to process each message. Listing 3.3 presents the code for \nthe MessageStatistics type used to abstract services for managing message statistics. As seen, the MessageStatistics type has an interface method to increment the \nnumber of received messages throughout the system. Since the system requires concur-\nrency, each independent flow of message processing is carried out using two different \nthreads; therefore, it is assumed that a base Thread class exists that abstracts the creation \nand management of threads, providing a simplified interface that contains start\n() and \nstop() methods to execute and terminate the thread. In addition, the Thread base class \nprovides an abstract method run() used by derived classes to provide the implementation \nof the thread\u2019s main (entry) function and an isActive() method to determine if the \nthread should continue executing or not. With such framework in place, the code for the \nSerialReceiverThread class, used to receive messages through the serial communi-\ncation interface, is presented in Listing 3.4. As seen, the class is configured with a reference to an object of type Message\u00ad\nStatistics, which is used to update the message count once a serial message is received. Similarly, the EthernetReceiverThread class is designed to be a thread that waits \nfor incoming messages via the Ethernet interface, as presented in Listing 3.5. As seen, this class is also initialized using a reference to a MessageStatistics object, \nso that both serial and Ethernet threads rely on the same data structure to update message \nstatistics. Consider what happens when objects of type SerialReceiverThread and \nmain : MainTread\n1 : count( )\n2 : start( )\ncounter = 1, wait 1 sec. counter = 2, wait 1 sec. counter = 3, wait 1 sec. counter = 4, wait 1 sec. counter = 5, wait 1 sec. counter = 6, wait 1 sec. counter = 7, wait 1 sec. 4 : stop( )\n3 : user input\nsd Concurrent Number Guessing Design\ncounter : TreadCounter\nFIGURE 3.3\nUML design for concurrent guessing game.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 121", "position": 121, "chunk_type": "semantic", "token_estimate": 380}
{"text": "98\u2002 \u2022\u2002 Software Engineering Design\ufeff: EthernetReceiverThread are both initialized using the same object instance of the \nMessageStatistics class, as illustrated in Listing 3.6. Once instantiated, both threads \nstart to receive messages via their respective interfaces. The main thread simply waits until \nall expected messages are received. The main problem with Listing 3.6 can be traced to the critical section of code inside the \nincrement\n() method of the MessageStatistics class. A critical section is a code segment \nthat makes changes to common variables, such as the _messageCount. This makes software \nmore challenging to design and evaluate since the integrity of the data inside the critical section \nneeds to be preserved. Since there are no safeguards to ensure the proper synchronization of \nmultiple threads when updating the _messageCount variable, both threads may attempt \nto update the message count at the same time, therefore resulting in unpredictable results that \nmay hinder the system\u2019s integrity. To illustrate this point, consider the assembly (lower-level) \ncode generated to increment the _messageCount variable, as seen in Listing 3.7. Using a disassembly tool, it can be seen that the _messageCount++ written in C++ \nrequires three assembly lines of code: one to move the current value of _messageCount \nListing 3.3: C++ Code for Specification of the MessageStatistics Type\nclass MessageStatistics {\npublic:\n\t // Use constructor to set messageCount = 0;\n\t // Method to increment number of received messages. void increment() {\n\t \t // A message has been received, increment the current count. _messageCount++;\n\t }\n\t // Method to return the current number of messages received. int count() {\n\t \t // Return the number of messages received. return _messageCount;\n\t }\n\t // ...\nprivate:\n\t // Variable used to keep track of the number of messages received. int _messageCount;\n\t // ...\n};", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 122", "position": 122, "chunk_type": "semantic", "token_estimate": 288}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 99: to the accumulator eax register; one to increment the value; and the last one to move the \nresults back from the eax register to the address referenced by the _messageCount vari-\nable in C++. When executed concurrently, both threads of execution will execute the opera-\ntions. However the order in which they are executed cannot be guaranteed; that is, the order \ncan be interleaved in some arbitrary fashion. Consider the interleaved order of execution \namong the two threads\u2014each receiving messages at the same time\u2014presented in Table\u00a03.9. After execution, the value of _messageCount is incorrectly set to 1, when it should \nbe\u00a02, since two messages were received. This phenomenon is known as a race condition \nand occurs when two processes or threads operate concurrently on the same data and the \noutcome of the execution depends on the particular order in which the access takes place. This example shows the importance of designing and evaluating architectural elements \nusing the process view, which provides the appropriate perspective for detecting such \nListing 3.4: C++ Code for the Serial Message Processor Thread Class\nclass SerialReceiverThread : public Thread {\npublic:\n\t // Constructor. SerialReceiverThread(MessageStatistics& stats) {\n\t \t // Save the statistics object for later use. _stats = &stats;\n\t }\nprotected:\n\t // Thread\u2019s main function. virtual void run() {\n\t \t while( isActive() ) {\n\t \t \t // Wait for a message via the serial interface. // Once a message is received, increment count in the stats\n\t \t // object. _stats->increment();\n\t \t \t // Process received serial message.\n\t \t } // end while loop.\n\t } // end run() method. private:\n\t // The pointer to the stats object. MessageStatistics* _stats;\n};", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 123", "position": 123, "chunk_type": "semantic", "token_estimate": 272}
{"text": "100\u2002 \u2022\u2002 Software Engineering Design\ufeff: cases. When these cases are detected, guards in the design can be introduced to protect the \nintegrity of such critical sections of code. In UML, such design evaluations and decisions \ncan be captured using the synchronization properties such as Sequential, Guarded, and \nConcurrent presented in Chapter 2. These properties place constraints in process models \nto support concurrency by controlling the way multiple flows of execution access critical \nsections of code. The Sequential synchronization property specifies that no concurrency \nmanagement mechanism is associated with an operation, such as in the case of the existing \nincrement method in Listing 3.3. With sequential access, concurrency conflicts may occur, \nso clients that rely on the operation need to coordinate so that only one invocation occurs \nat any given point. The Guarded property specifies that the operation can be invoked from \nListing 3.5: C++ Code for the Serial Message Processor Thread Class\nclass EthernetReceiverThread : public Thread {\npublic:\n\t // Constructor. EthernetReceiverThread(MessageStatistics& stats) {\n\t \t // Save the statistics object for later use. _stats = &stats;\n\t }\nprotected:\n\t // Thread\u2019s main function. virtual void run() {\n\t \t while( isActive() ) {\n\t \t \t // Block waiting for a message via the serial interface. // Once a message is received, increment count in the stats\n\t \t \t // object. _stats->increment();\n\t \t \t // Process received Ethernet message.\n\t \t } // end while loop.\n\t } // end run() method. private:\n\t // The pointer to the stats object. MessageStatistics* _stats;\n};", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 124", "position": 124, "chunk_type": "semantic", "token_estimate": 239}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 101: Listing 3.6: C++ Code for Concurrent Application\n// Code to demonstrate the critical section concept in concurrent \nprograms. #include <iostream>\n#include \u201cSerialReceiverThread.h\u201d\n#include \u201cEthernetReceiverThread.h\u201d\n#include \u201cMessageStatistics.h\u201d\nusing namespace std;\nint main( int argc, char* argv[] ) {\n\t // Number of messages received. int messagesReceived = 0;\n\t // Number of messages expected. const int MESSAGES_EXPECTED = 10;\n\t // Create the object to keep track of message statistics. MessageStatistics msgStats;\n\t // Create the thread to receive messages via serial interface. SerialReceiverThread serial(msgStats);\n\t // Create the thread to receive messages via Ethernet interface. EthernetReceiverThread ethernet(msgStats);\n\t // Start receiving messages through both interfaces. serial.start();\n\t ethernet.start();\n\t while( msgStats.count() < MESSAGES_EXPECTED ) {\n\t \t cout<<\u201cMessages received: \u201d<<msgStats.count()<<endl;\n\t \t // if flag set, exit loop. // Blocking call. Wait one second before checking again. sleep(1000);\n\t }\n\t // Stop receiving through serial interface. serial.stop();\n\t // Stop receiving through Ethernet interface. ethernet.stop();\n\t // End of program. return 0;\n}", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 125", "position": 125, "chunk_type": "semantic", "token_estimate": 154}
{"text": "102\u2002 \u2022\u2002 Software Engineering Design\ufeff: multiple independent flows simultaneously, but only one flow of execution is allowed to \ncommence; other independent flows are blocked until the execution of a currently execut-\ning operation, under the currently executing thread, is complete. When using the Guarded \nsynchronization property, it is the responsibility of the designer to ensure that concurrency \nissues, such as starvation and deadlocks, do not occur. Finally, the Concurrent synchroniza-\ntion property specifies that multiple invocations may occur simultaneously and all of them \nmay proceed concurrently. Concurrency is achieved in languages with built-in support for \nconcurrency, such as Java, with the use of the synchronized property. To resolve the \nissue of concurrency caused by the increment\n() method, the Guarded synchronization \nconcept can be modeled and manifested in code by ensuring that the critical section of code \nthat increments the _messageCount is mutually exclusive to both threads of execution. This can be achieved by employing a mutually exclusive (Mutex) object, typically provided \nby the operating system. The code from Listing 3.3 is modified using pseudo-code to sup-\nport concurrency, as seen in Listing 3.8. The concepts presented in Listings 3.3, 3.4, 3.5, 3.6, and 3.8 can all be summarized using \ntwo simple UML designs, as seen in Figure\u00a03.4. The concepts presented so far are essential for understanding how the process view of \nsoftware architecture is used to evaluate and design for performance in software systems. These concepts play a key role in designing systems that meet performance and availability \nrequirements by modeling aspects of concurrency, distribution, and fault tolerance. Listing 3.7: Sample Assembly Program to Increment _ messageCount\n; Move contents of _messageCount to eax register. mov eax, dword ptr [_messageCount (417140h)]\n; Add one to the number in eax. add eax, 1\n; Copy the result from eax to _messageCount. mov dword ptr [_messageCount (417140h)], eax\nTABLE\u00a03.9\nInterleaved Execution in Concurrent Designs\nTime\nSource\nOperation\n_messageCount", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 126", "position": 126, "chunk_type": "semantic", "token_estimate": 319}
{"text": "The software architecture activity corresponds to a macrodesign approach for transform-: ing software requirements into design elements that support quality and functions of \nsoftware systems. Formally, software architecture is defined as the foundational software \ndesign activity that evaluates and translates software requirements (both functional and \nnonfunctional) into a collection of design elements that specify structural and behavioral \naspects of the major components of the system, together with their provided quality and \n_stats\n\u2013messageCount: int\n+increment(): void {Guarded}\n+count(): int\n_stats\n<<thread>>\nserial : SerialReceiverTread\nincrement()\n{Guarded}\nincrement()\n{Guarded}\nmsqStats : MessageStatistics\n#run(): void\n<<thread>>\nethernet : EthernetReceiverTread\nEthernetReceiverTread\nMessageStatistics\n#run(): void\nStructural View\nBehavioral View\n+start(): void\n+stop(): void\n+run(): void\n#isActive() : bool\nSerialReceiverTread\nTread\nFIGURE 3.4\nUML concurrent design for communication elements.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 128", "position": 128, "chunk_type": "semantic", "token_estimate": 124}
{"text": "1.\tSelect a problem of interest and write a statement of work that describes the over-: view of the problem. Use this statement of work to generate a list of requirements for \nthe system and to explain how each requirement meets the desired characteristics of \nrequirements. Once the list of requirements is defined, complete the \u00ad\nfollowing steps:\n\t\na. Determine at least two views appropriate for this problem. b. Using a UML modeling tool, create design elements appropriate for each view. c.\t For each design element, write a paragraph describing how the design element \nhelp address particular concerns for the system. d.\t Assume that portability and performance have been identified as new quality attri-\nbutes for the system. Integrate these into the design. Note that you will have to make \nassumptions to complete this step. Make sure that you document all assumptions. e.\t Evaluate how all assumptions, identified requirements, and quality attributes \nare supported by the resulting architectural elements. Create a report that docu-\nments the result of the evaluation process.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 130", "position": 130, "chunk_type": "semantic", "token_estimate": 171}
{"text": "During software architecture, designers spend a great deal of time devising: architectural solutions that provide the necessary components and interfaces \nto achieve system requirements. At the architectural level, common pat-\nterns have emerged that describe elements of the system together with their \ninterrelationships and quality characteristics. These patterns allow designers \nto quickly and systematically identify structural characteristics of systems \n(or\u00a0subsystems\u00ad\n) and provide the means for examining interactions and the \nproposed quality of the system. During the past decade, many styles and pat-\nterns for software architecture have been researched and published. Many of \nthese patterns have been identified in pattern catalogue books; some of these \nare common design patterns in enterprise-level systems, while \u00ad\nothers address \nspecific needs such as distributed systems. This chapter explores several \nwell-established architectural patterns and examines the problems they are \ndesigned to address, together with their exhibited quality attributes. Identify\u00ad\ning and designing using architectural patterns can improve the \u00ad\nefficiency of \nthe development process and the quality of the final system.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 131", "position": 131, "chunk_type": "semantic", "token_estimate": 169}
{"text": "As seen in Chapter 3, software systems need to be carefully architected and evaluated from: various perspectives to properly address multiple concerns that affect the quality of the \nend product. Modeling systems from each view requires addressing design problems of \ndifferent natures, such as problems that deal with the logical system structure or problems \nthat deal with dynamic, concurrency system issues. In all cases, it is essential to identify \nthe necessary components and interfaces (at the right granularity) and the responsibility \nof each component and to model behavioral interactions among them before moving on to \ndetailed design. Of particular interest is the logical architecture of software systems, since \nit includes system decomposition into logical components that are refined throughout the \ndesign phase and ultimately implemented during construction. From this perspective, it\u00a0is \nimportant to use past experience with logical decompositions together with their inter-\nfaces when designing today\u2019s software systems. To this end, the concepts of \u00ad\narchitectural \nstyles and architectural patterns have emerged as mainstream approach for achieving \n(mostly logical design) reuse at the architectural level. These concepts are fundamental to \nthe efficient creation of software architectures by providing an overall strategy for design-\ning families of software systems. They provide generic, reusable architectural solutions, \ndocumented in a way that can be easily understood and applied to new problems requiring \nsimilar architectural features. Decisions based on architectural styles and patterns benefit \nfrom years of documented experience that highlights the solution approach to given prob-\nlems, the benefits of these approaches, and the consequences of designing the system with \na particular style. Today, the terms architectural styles and architectural patterns are used loosely to refer \nto similar concept. The fuzzy line that may exist among them can be a source of confu-\nsion, which shifts the focus away from the true importance and role of both concepts in \ndesigning today\u2019s complex software. Since numerous architectural styles and patterns are \ndocumented today, a brief history of the concepts is required to consolidate the terms and \nprovide a consistent approach for applying them throughout the rest of the chapter. History of Architectural Styles and Patterns\nIn 1977, Christopher Alexander presented a language intended to help individuals, or \nteams of individuals, design quality structures of different sizes, shapes, and complexities \n(Ishikawa, Silverstein, Jacobson, Fiksdahl-King, and Angel 1977, p. x). This language\u2014born \nout of experience\u2014had at its core entities called patterns. According to Alexander et al.", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 132", "position": 132, "chunk_type": "semantic", "token_estimate": 402}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 109: included a picture of the pattern, the context of the pattern, the problem that it attempts \nto solve, evidence for its validity, solution for the problem, and related patterns among \n\u00ad\nothers (Alexander et al. 1977). Together, these patterns formed a language for use dur-\ning the design and construction process. Although Alexander\u2019s work on patterns appears \n\u00ad\nrelevant and appropriate for the software engineering profession, it actually referred to \npatterns found in the design of buildings and towns. Alexander\u2019s work significantly impacted the field of software engineering. Even though \nhis patterns dealt with design quality in buildings and towns, it inspired computer scien-\ntists to answer the same types of questions about quality in object-oriented designs. In the \nearly 1990s, the software engineering community began researching and finding recur-\nring high-level problem solutions in terms of specific elements and their relationships; \nthese were originally referred to as architectural styles (Clements, Kazman, and Klein \n2001). Architectural styles provided the means for software architects to reuse architectural \ndesign solutions in different projects. In 1995, Gamma, Helm, Johnson, and Vlissides\u2014bet-\nter known as the Gang of Four (or GoF)\u2014embarked on a similar quest to find and docu-\nment detailed object-oriented solutions successfully applied more than once in different \nsystems. Their influential work focused on a finer-grained set of detailed design patterns \nand resulted in the creation of a catalogue of 23 patterns, commonly known as design pat-\nterns. In 1996, the work of Buschmann, Meunier, Rohnert, Sommerland, and Stal (1996) \nmeshed the work of styles and patterns by providing a set of well-known architectural styles \ndocumented using a pattern-like approach (Clements et al. 2001). In their original work, \nBushman and \u00ad\ncolleagues indicate that patterns and styles are essentially the same thing by \nstating (Buschman et al. 1996, p. 395):\nEvery architectural style can be described as an architectural pattern. Today, the terms architectural styles and architectural patterns are used to convey funda-\nmental structural and architectural organization for software systems. Other authors, such \nas Bass, Clements, and Kazman (2003) and Qian, Tao, Xu, and Diaz-Herrera (2009), con-\nsider both concepts to be the same thing. Throughout this chapter (and the rest of the book), \nthe terms architectural patterns and architectural styles are used interchangeably to denote \narchitectural solutions for software systems that occur at the highest level of abstraction in the \ndesign process.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 133", "position": 133, "chunk_type": "semantic", "token_estimate": 400}
{"text": "110\u2002 \u2022\u2002 Software Engineering Design\ufeff: characteristics help guide the choice of selecting one particular pattern over another. In\u00a0some cases, several recognized patterns can all meet the identified characteristics of the \nsystem, therefore leaving the design team with the decision of choosing the most appro-\npriate pattern for the design. In other cases, various architectural patterns can be used in \ncombination to collectively provide the appropriate architectural solution that best fits the \nidentified system type, requirements, and quality attributes. Since architectural patterns are \nfound at the highest level of system decomposition, they are too abstract to yield a concrete \nsystem design; therefore, they are not tied to a particular system implementation but can \nbe associated with types (or families) of systems so that their solution can be reused across \nsystems of the same type. For example, a data-centered type of system can employ architec-\ntural patterns that provide the logical design that reflects various components interacting \nwith a main component where data are hosted. The architectural pattern for such a system \nwould include the structural entity that manages the data, components that perform work \non the data, their data-centered interrelationships, and the quality of those components \nfor providing the application-specific structure for the data-centered software system. As \nanother example, consider the design of a distributed software system with components \nthat communicate and collaborate across the network. In such cases, architectural patterns \nthat support these components and their interrelationships in a distributed manner can be \nemployed to define the overall strategy of the distributed systems. A list of common types of \nsystems appropriate for classifying architectural patterns is presented in Table\u00a04.1. For large-scale systems, a single architectural pattern is inadequate for describing all the \ninteractions of the complete system. In these cases, several patterns may be required to aid \nin the composition of architectural designs of the system and subsystems. That is, at the \nhighest level, the logical design of a distributed system can incorporate an architectural \npattern fitting of such system; however, at finer levels of abstraction, the system can include \nin its logical architecture other patterns that address other nondistributed system issues. Consider, for example, both distributed and data-centered systems already discussed. The \noverall architectural logical composition may include an architectural pattern that includes \nclient and server components collaborating in distributed fashion.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 134", "position": 134, "chunk_type": "semantic", "token_estimate": 384}
{"text": "110\u2002 \u2022\u2002 Software Engineering Design\ufeff: Consider, for example, both distributed and data-centered systems already discussed. The \noverall architectural logical composition may include an architectural pattern that includes \nclient and server components collaborating in distributed fashion. When further refined, \nthe architectural design of the server\u2019s logical composition may employ an architectural \npattern appropriate for data-centered systems, while the design of the client\u2019s architectural \nTABLE\u00a04.1\nType of Software Systems for Classifying Architectural Patterns\nType\nDescription\nData-centered\nSystems that serve as a centralized repository for data, while allowing clients to access and \nperform work on the data\nData flow\nSystems oriented around the transport and transformation of a stream of data\nDistributed\nSystems that primarily involve interaction between several independent processing units \nconnected via a network\nInteractive\nSystems that serve users or user-centric systems\nHierarchical\nSystems where components can be structured as a hierarchy (vertically and horizontally) to \nreflect different levels of abstraction and responsibility", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 134", "position": 134, "chunk_type": "semantic", "token_estimate": 153}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 111: composition may employ an architectural pattern appropriate for data-flow systems. All \nof these issues are architectural, and different design elements addressing these concerns \nthroughout the system are required to form the software architecture. This way, architec-\ntural patterns are combined to describe the complete layout of a system. In the rest of the \nchapter, common architectural patterns for each of these major system types are presented \nand examined. The central features of the pattern and the problems addressed are shown \nalong with a summary of the benefits and limitations of each pattern. DATA-CENTERED SYSTEMS\nData-centered systems are systems primarily decomposed around a main central reposi-\ntory of data. Therefore, typical responsibilities found in components of data-centered \nsystem include a centralized data manager and various worker components. The data \nmanager component controls, provides, and manages access to system data, while worker \ncomponents execute operations and perform work based on the data. The communica-\ntion in data-centered systems is characterized by a one-to-one bidirectional communica-\ntion between workers and data manager components. That is, worker components do not \ninteract with each other directly; all communication goes through the data manager. Some \nconsiderations for these systems are data manipulation, communications protocols, trans-\nactions and recovery (also known as roll-back), and security. Examples of data-centered \nsystems include expert systems, which interact with a database management system for \nstoring and retrieving knowledge information. An example of an architectural pattern for \ndata-centered systems includes the blackboard architectural pattern. Blackboard Pattern\nThe blackboard architectural pattern decomposes software systems into components that \nwork around a central data component to provide solutions to complex problems. These \ncomponents work independently of each other to provide partial solutions to problems \nusing an opportunistic problem-solving approach. That is, there are no predetermined, \nor\u00a0correct, sequences of operations for reaching the problem\u2019s solution. Each component \nprovides solutions that build upon the problem\u2019s current state, which is defined by the \n\u00ad\ncollective set of solutions provided by the blackboard\u2019s components. The access to the \ncentral data component can be made through direct memory reference, procedure calls, \nor database query (Taylor, Medvidovic, and Dashofy 2009). Other forms of access to the \ndata central store may require complex and distributed remote method invocations, which \nmay prompt designing blackboard systems as part of a broader architectural pattern. Nevertheless, this data-driven and opportunistic problem-solving approach is typical in \nthe development of expert systems (Buschmann et al. 1996).", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 135", "position": 135, "chunk_type": "semantic", "token_estimate": 407}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 111: Nevertheless, this data-driven and opportunistic problem-solving approach is typical in \nthe development of expert systems (Buschmann et al. 1996). Using the blackboard architectural pattern, systems can be broken down to include \na common repository where data and solutions to particular problems reside (i.e., the", "domains": ["Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 135", "position": 135, "chunk_type": "semantic", "token_estimate": 52}
{"text": "112\u2002 \u2022\u2002 Software Engineering Design\ufeff: blackboard), a controller, and various agents that work to refine and further solutions \nto arrive at an acceptable solution. The blackboard architectural pattern resembles the \napproach a group of scientists would employ to solve a complex problem. Consider a group \nof scientists at one location using a blackboard (chalkboard, whiteboard, or electronic \nblackboard) to solve a complex problem. Assume that to manage the problem-solving pro-\ncess among scientists, a mediator controls access to the blackboard. Once the controller \nassigns control to the blackboard, a scientist evaluates the current problem\u2019s state as pre-\nsented in the blackboard and, if possible, advances its solution before releasing control of \nthe blackboard. With new knowledge obtained from the previous solution attempt, control \nis assigned to the next scientist who can further improve the problem\u2019s state. This pro-\ncess continues until no more progress can be made, at which point the blackboard system \nreaches a solution. Similar to this example, the blackboard architectural pattern identifies \nspecialized agents that independently contribute to a problem\u2019s solution. Together, one or \nmore agent components, the controller component, the blackboard component, and their \ninterrelationships form the essence of the blackboard architectural pattern, as presented in \nthe box-and-line diagram in Figure\u00a04.1. Consider the application of the blackboard architectural pattern for the design of a \nuniversity software system that manages student registrations. Registrations are man-\naged based on course availability, students\u2019 course history, and students\u2019 work schedule. Controller\nAgent 2\nAgent n\nBox-and-Line Diagram\nUML Component Diagram\n<<component>>\nScheduleManager\n<<component>>\nScheduleBlackboard\n<<component>>\nScheduleHistory\nISchedule\nIStudentHistory\nIWorkSchedule\nISchedule\nISchedule\nISchedule\nICourseO\ufb00erings\n<<component>>\nWorkSchedule\n<<component>>\nCourseO\ufb00erings\nAgent 1\nBlackboard\nFIGURE 4.1\nThe blackboard architectural pattern.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 136", "position": 136, "chunk_type": "semantic", "token_estimate": 277}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 113: Acquiring each independent piece of information may require the system to interface with \nother systems with, for example, particular messaging protocols and interfaces. The cur-\nrent state of students\u2019 schedule is managed in a central component, housed with a data-\nbase system containing the schedule details. To update schedules, the student scheduling \nsystem needs to interface with these external systems to retrieve information pertinent to \ncreate an optimized student schedule. In addition, future implementations of the schedul-\ning system may include other information pertinent to the problem; therefore, the logical \narchitecture needs to provide flexibility for incorporating new specialized agents capable \nof \u00ad\nfurther improving the scheduling generation capabilities. Using the blackboard archi-\ntectural \u00ad\npattern, the following components are identified in Table\u00a04.2 and presented in \nFigure\u00a04.1 using the Unified Modeling Language (UML) component diagram. The ScheduleManager corresponds to the controller component of the blackboard \narchitectural pattern seen in the box-and-line diagram of Figure\u00a04.1. The StudentHistory, \nWorkSchedule, and CourseOfferings components correspond to the worker agents pre-\nscribed in the blackboard architectural pattern, which work independently to contribute \nto the problem solution by addressing a particular part of the problem and injecting their \nresults back into the main data repository component. Finally, the ScheduleBlackboard \ncorresponds to the prescribed blackboard component from the blackboard architectural \npattern, which manages and controls access to the current state of students\u2019 schedules. Assuming the design configuration presented in Figure\u00a04.1, the solution approach to gen-\nerate a schedule that maximizes both the number of courses taken and work hours (\u00ad\nsubject \nto some constraints) can be devised as follows. First, the ScheduleManager \u00ad\ncomponent \ninitializes all other components, including agents and ScheduleBlackboard components. Once components in the blackboard system are initialized, the StudentHistory component \nis activated to search for a particular student\u2019s course history and retrieves information \nregarding courses left to complete a particular degree, the student\u2019s preference between \nday and night courses, and their preference between face-to-face and online courses. This \ninformation is stored in the ScheduleBlackboard component and is used to generate the first \nversion of the student\u2019s schedule. Next, the ScheduleManager activates the CourseOffering \ncomponent to search for the particular semester\u2019s course offering, including courses offered \nonline, within the university system, from local and remote branch campuses. This may \nrequire the CourseOfferings component to have the capability of interfacing with different \ndistributed information systems.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 137", "position": 137, "chunk_type": "semantic", "token_estimate": 402}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 113: Next, the ScheduleManager activates the CourseOffering \ncomponent to search for the particular semester\u2019s course offering, including courses offered \nonline, within the university system, from local and remote branch campuses. This may \nrequire the CourseOfferings component to have the capability of interfacing with different \ndistributed information systems. The course offering information is used to modify the \noriginal schedule to include a schedule that reflects the student\u2019s preference fused with the \nTABLE\u00a04.2\nArchitectural Components for Students Scheduling System\nComponent\nDescription\nScheduleManager\nManages access to the ScheduleBlackboard and controls the problem-solving process\nStudentHistory\nKnowledge source for students\u2019 history, including course and other preferences\nWorkSchedule\nKnowledge source for students\u2019 work schedule\nCourseOfferings\nKnowledge source for university\u2019s course offerings\nScheduleBlackboard\nCentral data store where elements of the solution space are stored", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 137", "position": 137, "chunk_type": "semantic", "token_estimate": 135}
{"text": "114\u2002 \u2022\u2002 Software Engineering Design\ufeff: course offerings. That is, if the student prefers face-to-face night courses, the CourseOffering \ncomponent will combine this information to propose the schedule most appropriate for \nmeeting these preferences. After the CourseOfferings component releases control of the \nScheduleBlackboard component, the ScheduleManager activates the WorkScheduler com-\nponent to determine the student\u2019s federal work-study schedule, which is accessible through \nthe university system. Assuming the student\u2019s work schedule includes alternatives for var-\nious shifts, the WorkScheduler component evaluates the current state of the scheduling \nproblem stored in the ScheduleBlackboard and determines the best shift based on the cur-\nrent schedule. When doing this, the WorkSchedule component may modify the schedule \nby removing classes that conflict with the most desirable and proposed work schedule. After releasing control of the ScheduleBlackboard, future iterations of the problem-solving \nprocess may include the CourseOffering component filling the gaps in the master schedule \nby selecting different classes that may or may not be of the student\u2019s preference but result in \nthe schedule that maximizes both the number of courses taken and work hours. This pro-\ncess, as presented in Figure\u00a04.2, can be repeated many times until the process is complete \nClient\nScheduleManager\n1 : sch := generateSchedule()\n2 : nextScheduler()\n3 : workOnSchedule()\n6 : <<return>>\n11 <<return>>\n18 <<return>>\n16 : <<return>>\n12 : nextScheduler()\n13 : workOnSchedule()\n7 : nextScheduler()\n17 : sch := getSchedule()\n14 : sch := getSchedule()\n9 : sch := getSchedule()\n15 : setSchedule(sch)\n10 : setSchedule(sch)\n8 : workOnSchedule()\n4 : sch := getSchedule()\n5 : setSchedule(sch)\nStudentHistory\nCourseO\ufb00erings\nWorkSchedule\nScheduleBlackboard\n19 <<return>>\nModify\nSchedule\nFIGURE 4.2\nInteractions among components in the blackboard architectural pattern.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 138", "position": 138, "chunk_type": "semantic", "token_estimate": 278}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 115: and the schedule provides the best possible solution. Because the number of agents can \nvary, the solutions provided by blackboard systems are (typically) nondeterministic and \nvary depending on the number of agents and the available information. As seen, each component in the system abstracts the process and capabilities for acquir-\ning information necessary for carrying out work to improve the solution from their \nparticular standpoint. By abstracting each agent\u2019s work, the details employed inside the \ncomponent, such as interprocess communication with external or distributed sources of \ndata, protocols, messaging interfaces, and others, can be separated from the overall sys-\ntem design. Also, as seen, interactions between workers and the blackboard are limited to \nretrieving and injecting new knowledge to the blackboard. This way, changes to one agent \ncomponent do not affect other agents or the blackboard components. The major benefits of using the blackboard architectural pattern include its modifiability, \nreusability, and maintainability. These quality properties come as a result of compartmen-\ntalizing knowledge sources and establishing a standard method for using the blackboard. Since each agent needs to know only how to communicate with the blackboard, new agents \ncan be introduced without much effort to improve the system\u2019s capabilities. Also, by com-\npartmentalizing knowledge sources, changes to the system are also compartmentalized; \ntherefore, changes to one agent do not affect other agents in the system. Finally, compart-\nmentalization of agents supports easy reuse in future systems. The list of quality properties \nassociated with the blackboard architectural pattern is presented in Table\u00a04.3. An important element to consider when applying any architectural pattern, including \nthe blackboard, is their deployment aspect. Going back to the example with the scientists, \nit was explicitly stated that they were located in the same room, in front of the blackboard. However, scientists can be distributed all over the world, collaborating via electronic \n\u00ad\navenues. Similarly, blackboard systems and other systems based on architectural patterns \ndiscussed in this chapter may be distributed through the network, in which case describ-\ning the nature of their connectors becomes important. This would be presented using an \narchitectural design element from a deployment perspective. Skill Development 4.1: The Blackboard Architectural Pattern\nConsider the existence of the new HolidaySchedule software component that can \nretrieve information regarding the university system\u2019s holiday schedule. This includes \ninformation regarding operation hours during, for example, holidays and spring break.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 139", "position": 139, "chunk_type": "semantic", "token_estimate": 400}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 115: Skill Development 4.1: The Blackboard Architectural Pattern\nConsider the existence of the new HolidaySchedule software component that can \nretrieve information regarding the university system\u2019s holiday schedule. This includes \ninformation regarding operation hours during, for example, holidays and spring break. TABLE\u00a04.3\nQuality Properties of the Blackboard Architectural Pattern\nQuality\nDescription\nModifiability\nAgents are compartmentalized and independent from each other; therefore, it is easy to \nadd or remove agents to fit new systems. Reusability\nSpecialized components can be reused easily in other applications. Maintainability\nAllows for separation of concerns and independence of the knowledge-based agents; \ntherefore, maintaining existing components becomes easier.", "domains": ["Design Principles", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 139", "position": 139, "chunk_type": "semantic", "token_estimate": 108}
{"text": "116\u2002 \u2022\u2002 Software Engineering Design\ufeff: Using pencil and paper, redraw Figure\u00a04.1 to include this component. How can such a \ncomponent be used in the student\u2019s schedule blackboard system to further increase the \nnumber of hours worked? Using Figure\u00a04.2 as context, how much effort and how many \narchitectural changes would be required to add this new component to the system? Discuss this problem with a peer.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 140", "position": 140, "chunk_type": "semantic", "token_estimate": 67}
{"text": "Data-flow systems are primarily decomposed around the central theme of transporting: data (or data streams) and transforming the data along the way to meet application-specific \nrequirements. Therefore, typical responsibilities found in components of data-flow systems \ninclude worker components\u2014those who perform work on data\u2014and transport compo-\nnents, which transmit data among worker components. The worker components abstract \ndata transformations that need to take place before passing data streams forward in the \nsystem, such as encryption, decryption, compression, decompression, and changing data \nformat form binary to Extensible Markup Language (XML). The transport components \nabstract the management and control of the data transport mechanisms, which could \ninclude interprocess communication, socket-based communication, and serial interfaces. Together, these components combine to form architectural elements of data-flow systems. The data transformation and transport in data-flow systems can entail transporting and \ntransforming data among different components within a single node or between nodes \nin distributed fashion. Data-flow systems provide the means for data transformation to \ntake place in series or in parallel fashion, which helps the system improve performance by \nadding concurrency to the system. Other considerations for these system include modi-\nfiability, security, and reusability of worker components capable of performing complex \noperations. An example of an architectural pattern for data-flow systems is the pipe and \nfilter architectural pattern. Pipe and Filter Pattern\nThe pipe and filter architectural pattern decomposes software systems into components \nthat carry out two major functions: processing and transforming data and transferring \ndata between components. Components responsible for processing and transforming data \nare referred as filters, while components that transfer data between components are referred \nas pipes. Together, these components are combined in various ways to create families of \nrelated systems that process streams of data (Buschmann et al. 1996). The pipes and filters \narchitectural pattern is commonly seen in data-flow systems, where data inputs need to be \ntransformed into data output through a series of computational or manipulative compo-\nnents (Pressman 2010). The structure of the pipe and filter architectural pattern is often \npresented using a box-and-line diagram, such as the one in Figure\u00a04.3. As seen, systems", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 140", "position": 140, "chunk_type": "semantic", "token_estimate": 347}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 117: based on the pipe and filter architectural pattern require a data source, one or more filter \ncomponents, and a data sink, all connected via filters. Using the box-and-line diagram presented in Figure\u00a04.3, the flow of operations of pipe \nand filter systems can be described as follows. Initially, the DataSource component produces \ndata and sends it to the Filter 1 component through a Pipe, denoted by an arrow flowing out \nof the DataSource component and into Filter 1. The Filter 1 component processes the data, \ntransforms it, and outputs the transformed data to three other filters for further processing. At this point, three independent and concurrent data transformations occur and their results \nsent to Filter 5. This process continues until the final formatted output is sent to the DataSink. Filter 2\nFilter 3\nFilter 5\nBox-and-Line Diagram\nUML Component Diagram\nUML Deployment Diagram\nISecurityFilter\n<<component>>\nLocalPipe\n<<component>>\nDataSource\n<<TCP/IP>>\n<<component>>\nSecurityFilter\n<<manifests>>\n<<manifests>>\n<<manifests>>\n<<manifests>>\n<<component>>\nDistributedPipe\n<<component>>\nDataSource\n<<component>>\nDataSink\n<<component>>\nDistributedPipe\n<<component>>\nDistributedPipe\n<<artifact>>\ndata_collector.exe\n<<artifact>>\ndata_processor.exe\nNode A\nNode B\n<<component>>\nDataSink\nIDistributedPipe\nIDistributedPipe\nPipes\nData Sink\nFilter 1\nILocalPipe\nData\nSource\nFilter 4\nFIGURE 4.3\nThe pipe and filter architectural pattern.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 141", "position": 141, "chunk_type": "semantic", "token_estimate": 203}
{"text": "118\u2002 \u2022\u2002 Software Engineering Design\ufeff: When using the pipe and filter architectural pattern, the software system consumes and \nprocesses input data incrementally, in separate filters, instead of consuming and process-\ning all of its input data at once. This allows the system to become more efficient, mainly \nby achieving low latency, which can be achieved through parallel processing (Buschmann \net\u00a0al. 1996). Also, by segregating the processing components and abstracting the data trans-\nferring process, processing and computations can be performed across process boundaries \nor across node boundaries. In these cases, the pipe and filter architectural pattern can exist \nwithin another architectural pattern for distributed systems. That is, several computers, \nexecuting different processes, can work together to process input data, transform the data, \nand generate the desired output data. Consider the design of a signal processing system that operates on real-time video or \naudio streams and is designed to collect data, encrypt it, and forward it for further process-\ning. This process can be repeated for various steps of data processing; however, for simplic-\nity, the number of pipes and filters is limited to present the concept in a concise manner. Using the pipe and filter architectural pattern, the components in Table\u00a04.4 are identified. Together, these components work to collect video and audio data streams, to encrypt \nthem, and to transmit them to a remote location, where data can be further processed and \ndistributed. The pipe and filter logical architecture for the real-time collection system is \npresented using the component notation in Figure\u00a04.3. As seen, the component notation is \nused to model and abstract the major functions identified for the system; however, it may \nstill be difficult to envision the actual system simply by viewing the logical distribution \nof components. Consider the following flow of operations. Once data become available \nat the DataSource component, they are transferred locally to the SecurityFilter compo-\nnent using the LocalPipe component. At the SecurityFilter component, the data stream is \ntransformed using encryption and is transferred to the DataSink component using mecha-\nnisms provided by the DistributedPipe component. In this case, the DistributedPipe com-\nponent abstracts the details of transferring data across the network, since the DataSource \nand DataSink are hosted on different nodes; therefore, a deployment view is necessary to \nproperly characterize the system.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 142", "position": 142, "chunk_type": "semantic", "token_estimate": 382}
{"text": "118\u2002 \u2022\u2002 Software Engineering Design\ufeff: At the SecurityFilter component, the data stream is \ntransformed using encryption and is transferred to the DataSink component using mecha-\nnisms provided by the DistributedPipe component. In this case, the DistributedPipe com-\nponent abstracts the details of transferring data across the network, since the DataSource \nand DataSink are hosted on different nodes; therefore, a deployment view is necessary to \nproperly characterize the system. As seen in the deployment diagram in Figure\u00a04.3, the \nDataSource and DistributedPipe components are manifested in Node A, while the DataSink \nand (another) DistributedPipe components are manifested in Node B. The manifestation of \nTABLE\u00a04.4\nArchitectural Components for Distributed Signal Processing System\nComponent\nDescription\nData source\nProduces real-time video or audio streams\nLocal pipe\nMechanism for transferring video or audio data streams locally from data source to \nsecurity filter\nSecurity filter\nTransforms data streams by encrypting flow of data\nDistributed pipe\nMechanism for transferring encrypted data streams wirelessly (e.g., Satellite \nCommunications [SATCOM]) from local site to remote site; provides the logical \nconnection between data source and data sink\nData sink\nDestination component where data streams are stored for later review", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 142", "position": 142, "chunk_type": "semantic", "token_estimate": 189}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 119: the LocalPipe and SecurityFilter components is omitted for simplicity; however, they would \nbe presented in Node A. This example shows how using different architectural views can \nenhance the understanding of the true architecture of a system. The presentation of the pipe and filter system using component diagrams is appropriate \nsince the piping mechanisms entail more advanced mechanisms than a simple method \ncall to another component. However, the same knowledge can be conveyed using a \nbox-and-line diagram or other non-UML diagram approach. The problem with using a \nsimple box-and-line diagram is that it becomes difficult to capture or abstract the work \nrequired to realize the work required by the pipe (or connector). When components are \nidentified during the software architecture activity, they are slated for refinement during \ndetailed design work, therefore providing an explicit and manageable unit of design work. By modeling complex pipes as components, the details of their work are abstracted, and \nfuture planned work for providing the details of such abstraction can be integrated into the \ndesigns and construction schedule, similar to any other component in the system. The pipe and filter architectural pattern can be applied to a problem of smaller scope \nwhere both pipe and filter components reside within a single node and communicate using \nsimple method calls or using simple mechanisms provided by the operating systems, such \nas \u00ad\nmessage queues. In other cases, creating a customized pipe, such as the DistributedPipe \npresented earlier, may require additional work. Filters can be designed as multiple com-\nponents manifested by as single process or by multiple independent processes executing \nwithin a node and communicating through common inter-process pipe mechanisms. Typically, once the pipe and filter framework is in place, numerous filters can be added \n(serially or in parallel) to provide additional capabilities. The major quality properties \nassociated with pipes and filter systems are presented in Table\u00a04.5. Skill Development 4.2: Designing with the Pipes and Filter Architectural Pattern\nUsing pencil and paper, complete the design for Node B required to distribute the \naudio and video feed. Once the data reach the data sink, all data need to be decrypted, \nTABLE\u00a04.5\nQualities of the Pipes and Filter Architectural Pattern\nQuality\nDescription\nExtensibility\nProcessing filters can be added easily for more capabilities. Efficiency\nBy connecting filters in parallel, concurrency can be achieved to reduce latency in the \nsystem.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 143", "position": 143, "chunk_type": "semantic", "token_estimate": 398}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 119: Once the data reach the data sink, all data need to be decrypted, \nTABLE\u00a04.5\nQualities of the Pipes and Filter Architectural Pattern\nQuality\nDescription\nExtensibility\nProcessing filters can be added easily for more capabilities. Efficiency\nBy connecting filters in parallel, concurrency can be achieved to reduce latency in the \nsystem. Reusability\nBy compartmentalizing pipes and filters, they can both be reused as is in other systems. Modifiability\nFilters are compartmentalized and independent from each other; therefore, it is easy to add \nor remove filters to enhance the system\nSecurity\nAt any point during data flow, security components can be injected to the work flow to \nprovide different types of security mechanisms to the data. Maintainability\nAllows for separation of concerns and independence of the filters and pipes; therefore, \nmaintaining existing components becomes easier.", "domains": ["Design Principles", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 143", "position": 143, "chunk_type": "semantic", "token_estimate": 142}
{"text": "Distributed systems are commonly known as systems decomposed into multiple processes: that collaborate through the network. These systems are ubiquitous in today\u2019s modern \n\u00ad\nsystems thanks to wireless, mobile, and Internet technology. In some distributed systems, \none or more distributed processes perform work on behalf of client users and provide a \nbridge to some server computer, typically located remotely and performing work delegated \nto it by the client part of the system. Once complete, results are typically returned back to \nclients for viewing and further processing. Other distributed systems may be composed of \npeer nodes, each with similar capabilities and collaborating together to provide enhanced \n\u00ad\nservices, such as music-sharing distributed applications. These forms of distributed systems \nare well-known in the sense that their deployment architecture typically entails multiple \nnodes. However, with the advent of multiple CPU architectures, distributed architectures \nare also relevant to software that executes on a single node with multiprocessor capability. The main concerns for distributed systems may include performance, reliability\u00ad\n, availability\u00ad\n, \nsecurity, and interoperability. Some examples are Internet systems with web services and \nhigh-performance scientific computing projects such as the Search for Extraterrestrial \nIntelligence (SETI) program or the Large Hadron Collider (LHC) at CERN. In such \u00ad\nsystems, \nmultiple processors that may reside on different physical machines or in different concurrent \nprocesses on a single machine cooperate to solve the tasks required of the system. Common \narchitectural patterns for these systems include\n\u2022\t Client\u2013server\n\u2022\t Broker\nClient\u2013Server Pattern\nThe client\u2013server architecture is a popular architectural pattern present in today\u2019s modern \nsystems. It decomposes software systems into two main components: the client and the \nserver. These components are manifested as individual processes that can be distributed \nover the network or within a single node. Client\u2013server systems are not determined merely \nby separating processes or by distributing processes across the network but by having one", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 144", "position": 144, "chunk_type": "semantic", "token_estimate": 309}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 121: process, the client, depend on the services provided by another process, the server. The \nmost pervasive example of a client\u2013server system today includes the web browser client \nand the web server. When searching for a particular site using the web browser client, \na\u00a0connection is made to the server, a request is sent and received by the server, and the \nserver processes the requests and sends a response back to the client. Note that this is also \ntrue regardless of the location\u2014which can be on the same node as the server\u2014 of the web \nclient, as long as it can connect to the server. In addition, web browser clients are not very \nuseful without the services provided by the server; therefore, they are dependent on the \nserver. Figure\u00a04.4 presents the client\u2013server architectural pattern. Client\u2013server systems are particularly useful for distributed systems with a large \u00ad\nclient \nbase, since they provide localization of data in one central place. Therefore, making updates \nor adding new information in once central place is all that it is needed for a multitude \nof clients to receive this information. The quality attributes associated with client\u2013server \n\u00ad\nsystems are identified in Table\u00a04.6. TABLE\u00a04.6\nQualities of the Client\u2013Server Architectural Pattern\nQuality\nDescription\nInteroperability\nAllows clients on different platforms to interoperate with servers of different platforms\nModifiability\nAllows for centralized changes in the server and quick distribution among many clients\nAvailability\nBy separating server data, multiple server nodes can be connected as backup to increase \nthe server data or services\u2019 availability\nReusability\nBy separating server from clients, services or data provided by the server can be reused in \ndifferent applications\nClient\n<<artifact>>\npc_browser.exe\n<<Request>>\n<<Response>>\n<<HTTP>>\n<<HTTP>>\nBox-and-LineDiagram\nUML Deployment Diagram\nPC Node\nServer Node\nServer\n<<artifact>>\nmp_browser.exe\nMobile Phone Node\n<<artifact>>\npc_browser.exe\n<<artifact>>\nweb_server.exe\nFIGURE 4.4\nThe client\u2013server architectural pattern.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 145", "position": 145, "chunk_type": "semantic", "token_estimate": 313}
{"text": "122\u2002 \u2022\u2002 Software Engineering Design\ufeff: Servers can abstract the services\u2014and the details of providing those services\u2014provided \nby the host platform, therefore creating a window for clients to interoperate with the host \nplatform. When done properly, this allows interoperation between systems of different \nplatforms. Client\u2013server systems can also lead to highly modifiable systems. Consider a \ncorporate web-based intranet system, where modifying or adding completely new system \ncapabilities may require creating the necessary server code, including a new hyperlink to \nthe existing corporate portal, and deploying the modified code to the production server. Once deployed, everyone in the corporate network would have instant access to the modi-\nfied system. Also, by separating the client application from the server data, client\u2013server \nsystems allow designers to render multiple views of the same data; clients can be improved \nor replaced independently of the resources needed to perform computations on the data; \nmultiple clients can share the resources of a server allowing for increased efficiency; or \nthe user interface can be replaced completely, allowing specialized clients to consume and \nperform additional processing on the data for further processing. Broker Pattern\nThe broker architectural pattern provides mechanisms for achieving better flexibil-\nity between clients and servers in a distributed environment. Consider the client\u2013server \nexample presented in Figure\u00a04.4. In the typical client\u2013server architectural pattern, clients \ndirectly access services of servers, which may require them to establish direct connection \n(e.g.,\u00a0Transmission Control Protocol/Internet Protocol [TCP/IP]) or employ other inter-\nprocess communication mechanisms for communicating with the server. This result in a \nhigher degree of coupling between clients and servers, which leads to complexity for \u00ad\nsystems \nexpected to evolve by providing services from different servers hosted at different locations. In some cases, client terminals need to be able to access services from multiple servers with-\nout knowing their actual locations or particular details of communication for accessing \nthose services. This leads to systems with increased interoperability and flexibility. The broker architectural pattern decreases coupling between clients and servers by \nmediating between them so that one client can transparently access the services of multiple \nservers. Instead of accessing servers directly, clients access their functionality via a bro-\nker component, which locates appropriate servers, forwards requests, and relays responses \n(including exceptions) back to clients (Buschmann et al. 1996).", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 146", "position": 146, "chunk_type": "semantic", "token_estimate": 378}
{"text": "122\u2002 \u2022\u2002 Software Engineering Design\ufeff: Instead of accessing servers directly, clients access their functionality via a bro-\nker component, which locates appropriate servers, forwards requests, and relays responses \n(including exceptions) back to clients (Buschmann et al. 1996). With this mechanism in \nplace, clients can request services as if they were provided locally on the same node as the \nserver, when they are in fact being provided in distributed fashion over the network by \ndifferent nodes. The main participants in the broker architectural pattern are presented \nin Table\u00a04.7, and examples of modeling broker systems are presented in Figure\u00a04.5 using \nbox-and-line, UML components, and UML deployment diagrams. In the box-and-line diagram presented in Figure\u00a04.5, it can be seen that broker compo-\nnents can interoperate with other brokers, so that if a service requested by a client is acces-\nsible through a separate broker this communication can be established to provide clients \nadditional services. For example, Client 1 may forward a request to Broker 1 for a particular \nservice. Broker 1, after determining that Server 2 provides the service requested, forwards", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 146", "position": 146, "chunk_type": "semantic", "token_estimate": 181}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 123: TABLE\u00a04.7\nComponents of the Broker Architectural Pattern\nComponent\nDescription\nClient\nApplications that use the services provided by one or more servers\nClientProxy\nComponent that provides transparency (at client) between remote and local components so \nthat remote components appear as local ones\nBroker\nComponent that mediates between client and server components\nServerProxy\nComponent that provides transparency (at server) between remote and local components so \nthat remote components appear as local ones\nServer\nProvide services to clients; may also act as client to the broker\nBridge\nOptional component for encapsulating interoperation among brokers\nBroker 1\nClient\nBroker 2\nServer 1\nBox-and-Line Diagram\nUML Component Diagram\nServer 2\n<<component>>\nUserInterface\n<<component>>\nDvrClient\nIDvrStatus\nIDvrRemoteControl\nIBroker\nIDvrControl\n<<component>>\nDvrClientProxy\n<<delegate>>\n<<artifact>>\niexplore.exe\nO\ufb03cePC\n<<delegate>>\n<<component>>\nDvrBroker\n<<component>>\nDvrClient\n<<manifests>>\n<<HTTP>>\n<<HTTP>>\n<<component>>\nUserInterface\n<<component>>\nDvrServer\nIDvrStatus\nIDvrStatus\nIDvrRemoteControl\nIDvrRemoteControl\nIDvrControl\nIDvrControl\nUML Deployment Diagram\n<<component>>\nDvrSystem\n<<component>>\nDvrServerProxy\n<<artifact>>\ndvr_server.exe\nFamilyRoomDvr\n<<component>>\nDvrServer\n<<manifests>>\n<<artifact>>\ndvr_server.exe\nBedroomDvr\n<<component>>\nDvrServer\n<<manifests>>\nFIGURE 4.5\nThe broker architectural pattern.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 147", "position": 147, "chunk_type": "semantic", "token_estimate": 171}
{"text": "124\u2002 \u2022\u2002 Software Engineering Design\ufeff: the requests to Broker 2, which in turn forwards the requests to Server 2. Once the opera-\ntions required for the particular service are executed, Server 2 establishes a connection \nwith Broker 2 and supplies it with a response, which is forwarded to Broker 1 and subse-\nquently to the Client. This sequence highlights a major difference between client\u2013server \nand broker architectural patterns: in the broker architectural pattern servers may also act \nas clients to the broker, whereas in client\u2013server architectures roles are exclusive so that \nservers are never clients (Buschmann et al. 1996). Consider the architectural design of the distributed digital video recording (DVR) sys-\ntem presented in the UML component diagram in Figure\u00a04.5. In this example, two proxies \nare created to provide transparency at both client and server side. The DvrClientProxy \ncomponent realizes the IDvrStatus and IDvrControl in a remote environment, while the \nDvrServerProxy realizes these interfaces in a local environment providing direct connec-\ntion to the DVR computer. Therefore, both user interfaces at the client and server locations \ncan be interchangeable, since they both interface with the DvrSystem component through \nwell-defined methods provided by these interfaces. With these mechanisms in place, the \nbroker system begins by initializing the DVR system to find appropriate servers and iden-\ntify their provided services, as seen in Figure\u00a04.6. Notice that in this example the optional \nbridge component identified in Table\u00a04.7 is not used. UserInterface\nDvrClientProxy\nDvrServerProxy\nDvrBroker\n2 : aMsg := intBrokerMsg()\n1 : int()\n4 : \ufb01ndServer()\n5 : callService(aMsg)\n6 : recv()\n3 : forwardRequest(aMg)\naResponse contains a\nlist of services supported\nby the server. At this point, the\nborker has knowledge\nof all services\nsupported by the\nserver. 7 : callService(aResponse)\n8 : registerServices(aResponse)\nFIGURE 4.6\nThe broker architectural pattern\u2014initialization.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 148", "position": 148, "chunk_type": "semantic", "token_estimate": 300}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 125: As seen, once the system begins initialization an initialization message containing a \nrequest for services and client information is created and forwarded to the DvrBroker \ncomponent, which finds appropriate servers and transmits the message for processing. At\u00a0this point, the DvrBroker waits for a response, which contains the services provided \nby the particular server; these services are registered and become available to the client \nduring\u00ad\n system operation. Once the system is initialized, services from remote severs can \nbe accessed through the broker, as seen in Figure\u00a04.7. In this example, the client requests \ninformation about the DVR\u2019s available disk space. Notice that the client\u2019s UserInterface \ncomponent, the getDiskSpace() interface method, can be called as if the DVR system were \nlocal to the client. An important architectural design element for this system involves the deployment \naspect of the DVR system. The logical view for architectural design does not convey enough \ninformation to fully provide the context for the operations that take place in the DVR \nsystem\u00ad\n. Figure\u00a04.5 provides a UML deployment diagram to add this context to the archi-\ntectural effort. As seen, the system employs two DVR nodes, which manifest the DvrServer \ncomponent identified in the UML component diagram. This means that the \u00ad\ngetDiskSpace() \noperation can be mapped to either FamilyroomDvr or BedroomDvr systems, all performed \ntransparently from clients. That is, the call made to the DvrServerProxy to get service \n(i.e.,\u00a0callService(aMsg)) can be made to either node (i.e., FamilyroomDvr or BedroomDvr) \nUserInterface\nDvrClientProxy\nDvrServerProxy\nDvrBroker\n2 : aMsg := pack()\n1 : getDiskSpace()\n4 : \ufb01ndServer()\n5 : callService(aMsg)\n6 : recv()\n3 : forwardRequest(aMsg)\n8 <<return>>\n10 <<return>>\n7 : callService(aResponse)\n9 : unpack(aResponse)\naMsg contains information\nabout the server\u2019s s\ndestination (e.g., IP address)\nand service requested. At this point, the\nBroker waits for a response. Once received, aResponse\nwill contain the information\nrequested. In this case,\nthe amount of disk\nspace available. FIGURE 4.7\nThe broker architectural pattern\u2014client operation.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 149", "position": 149, "chunk_type": "semantic", "token_estimate": 334}
{"text": "126\u2002 \u2022\u2002 Software Engineering Design\ufeff: transparently from clients, and the response is processed identically by the client. In similar\u00ad\n \nfashion, many other nodes can be added to the system without affecting the client applica-\ntion. This provides additional flexibility when modifying the system to add more nodes. On the server side, messages received are processed as presented in Figure\u00a04.8. As seen, the DvrServerProxy interfaces directly with the DvrSystem to relay requests from \nclients and prepare responses for transmission back to one or more clients. In this case, \nonce the DvrServerProxy receives a message, interprets it, and makes the getDiskSpace() \noperation call to the DvrSystem component, the getDiskSpace() operation encapsulates the \ndetails of the protocols required for the direct communication between the server compo-\nnent and the actual DVR computer. Once a response is received from the DVR computer, \nthe getDiskSpace() returns with results from the disk space availability; these are packaged \ninto a message and sent back to the broker as response for the client\u2019s requests. This process \nis repeated for all other services requested by clients. In practice, there are numerous variations of architectural designs based on the broker \narchitectural pattern. Some broker systems may have the broker component deployed \non separate nodes from the client; others allow clients to communicate directly with \n\u00ad\nservers in special cases; some rely on remote procedure calls (vs. the messaging approach \npresented here); and others rely on reactive models, where callback methods from reg-\nistered components are invoked by the broker whenever an event is triggered. However, \nall broker systems typically benefit mainly from the flexibility provided by decoupling \nclients and servers. The quality attributes associated with broker systems are identified \nin Table\u00a04.8. DvrSystem\nDvrServerProxy\nDvrBroker\n1 : waitForRequests()\n3 : unpack(aMsg)\n4 : getDiskSpace()\n2 : callService(aMsg)\n7 : callService(aResponse)\n6 : aResponse := pack()\n5 <<return>>\nAt this point, a Broker has\nbeen intialized on the client\nside and a request to retrieve\nthe available disk space has\nbeen sent. FIGURE 4.8\nThe broker architectural pattern\u2014server operation.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 150", "position": 150, "chunk_type": "semantic", "token_estimate": 339}
{"text": "Interactive systems are systems that support user interactions, typically through user: interfaces. When designing interactive systems, design alternatives concentrate on two \nmain quality attributes: usability and modifiability. As stated before, usability refers to \nthe quality goal that seeks to minimize the degree of complexity involved when learning \nor using the system. Usable systems are designed in such way that operators can quickly \nbecome proficient with the system; they also respond to user requests rapidly to support \nhigh interactivity\u00ad\n requirements. A large portion of usability design takes place during the \nuser interface design activity. Whereas usability is achieved mostly through user interface \ndesign, modifiability and interactive performance are mainly functions of the architec-\ntural logical design. To maximize modifiability and performance in interactive systems, \nthe graphic user interface that represents the system data needs to be efficiently decoupled \nfrom the functional system core. By doing this, the functional core\u2014which is typically \nstable since it is largely based on functional requirements\u2014is separated from user displays, \nwhich are largely based on quality requirements. Since user interfaces are more likely to \nchange and adapted to future versions of software systems, segregating them from the sys-\ntem core increases the modifiability of interactive systems. Examples of interactive systems \ninclude gaming \u00ad\nsystems, simulations, and Internet applications, where such systems need \nto respond to user requests rapidly and update the display so the user can interact appro-\npriately. The mainstream architectural pattern employed in most interactive systems is the \nmodel\u2013view\u2013controller (MVC). Model\u2013View\u2013Controller Pattern\nThe MVC architectural pattern is used in interactive applications that require flexible \nincorporation of human\u2013computer interfaces. With the MVC, systems are decomposed \ninto three main components that handle independently the system\u2019s input, processing, and \noutput. By separating the system\u2019s output from its core processing functions, different rep-\nresentations of the system core can be easily supported. The main components present in \nthe MVC architectural pattern are presented in Table\u00a04.9.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 151", "position": 151, "chunk_type": "semantic", "token_estimate": 317}
{"text": "Interactive systems are systems that support user interactions, typically through user: By separating the system\u2019s output from its core processing functions, different rep-\nresentations of the system core can be easily supported. The main components present in \nthe MVC architectural pattern are presented in Table\u00a04.9. TABLE\u00a04.8\nQualities of the Broker Architectural Pattern\nQuality\nDescription\nInteroperability\nAllows clients on different platforms to interoperate with servers of different platforms; \nalso allows clients to interoperate (transparently) with multiple servers\nModifiability\nAllows for centralized changes in the server and quick distribution among many clients\nPortability\nBy porting the broker to different platforms, services provided by the system can be easily \nacquired by new clients in different platforms\nReusability\nBrokers abstract many system calls required for providing communication between nodes; \nwhen using brokers, many complex services can be reused in other applications that \nrequire similar distributed operations", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 151", "position": 151, "chunk_type": "semantic", "token_estimate": 144}
{"text": "128\u2002 \u2022\u2002 Software Engineering Design\ufeff: View and controller components work together as part of the user interface to accept \nuser input and transform this input into format compatible with the model component. In some variants of the MVC, the responsibility of controllers and views are fused into \none component. The relationship among the model, view, and controller components can \nvary depending on the application; however, at minimum, MVC designs provide relation-\nships that allow changes in the model to be propagated to its view and, when necessary, to \ncontrollers. This way, MVC systems provide a systematic, flexible, and controlled approach \nfor accepting system inputs and providing system outputs. As an architectural pattern, MVC defines the interfaces required for the change propa-\ngation mechanisms among the model, view, and controller components. However, it does \nnot (and should not) specify the details of how the change propagation mechanism is actu-\nally implemented. Details of such mechanisms are left to the detailed design activity, which \ncan provide design patterns, such as the observer, to realize the intent of the MCV. As an \narchitectural pattern, MVC designs should specify the components, their interfaces, and \nthe nature of those interfaces to support system development. This fundamental difference \nprovides a clear delineation between MVC and other detailed design patterns. Figure\u00a04.9 \npresents a generic box-and-line design of the MVC architectural pattern. This diagram \npresents\u00ad\n the MVC in its most connected form, in which bidirectional relationships exist \namong all components. However, many variants exist that customize relationships among \ncomponents depending on the application. Figure\u00a04.9 also presents a UML component diagram for a hypothetical real estate hous-\ning market system\u00ad\n that allows users to find properties for sale. The real estate system is \nbased on the MVC architectural pattern and is composed of two views, each with their \nown controller and a model that contains all real estate information. The two views are \ndesigned uniquely for usability on a standard PC and large SMART board environment. Since the form factor\u00ad\n of PC monitors and SMART Boards differ significantly, two differ-\nent views are created for the system. Since the PC monitor is significantly smaller than the \nSMART board, the user interface created by the PCView component will cover the whole \nmonitor screen and rely on speech recognition technology for its input mechanism.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 152", "position": 152, "chunk_type": "semantic", "token_estimate": 385}
{"text": "128\u2002 \u2022\u2002 Software Engineering Design\ufeff: Since the form factor\u00ad\n of PC monitors and SMART Boards differ significantly, two differ-\nent views are created for the system. Since the PC monitor is significantly smaller than the \nSMART board, the user interface created by the PCView component will cover the whole \nmonitor screen and rely on speech recognition technology for its input mechanism. Since \nthe SMART board provides larger space for viewing the software, the SmartboardView \ncomponent provides more informative buttons and menu options to use the software. The \nSMART board \u00ad\nversion of the software relies on direct human touch interface or hand ges-\nture recognition. For this reason, two different controller components\u2014one that performs \nspeech processing and the other for hand touch or hand gesture recognition\u2014are designed. TABLE\u00a04.9\nComponents of the MVC Architectural Pattern\nComponent\nDescription\nModel\nComponent that represents the system\u2019s core, including its major processing capabilities \nand\u00a0data\nView\nComponent that represents the output representation of the system (e.g., graphical output or \nconsole based)\nController\nComponent (associated with a view) that handles user inputs", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 152", "position": 152, "chunk_type": "semantic", "token_estimate": 177}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 129: When using the system on a PC, users can command the system using speech, such as \n\u201cFind single family homes in Lakeland, Florida.\u201d Once this input is received through the \nPC\u2019s microphone, the speech controller transforms it into a command that is passed on \nthe model using the provided IModel interface. Once the request is processed by the model \ncomponent, it uses the IObserver interface to employ the change propagation mechanisms \nto let the PCView \u00ad\ncomponent\u2014or any other view associated with the model\u2014know that \nthe request has been processed. At this point, the PCView component retrieves the data \nusing the model\u2019s IModel interface and displays them to users. A\u00a0similar approach is con-\nducted in the SMART board version of the system. These sequences of operations for the \nMVC system are presented in Figure\u00a04.10. From this trivial example, the major advantage in the flexibility that MVC systems \nprovide can be clearly examined. For example, consider the case where a more advanced \nspeech processor is created. In this case, neither view nor model components need to \nbe modified for this addition. This means that support for enhanced speech processing \nor new languages can be added to the real estate system without much effort. Similarly, \nother views for the same data can be incorporated easily to the system, for example, a view \nproviding graphical descriptive or inferential statistics for housing markets based on the \nmodel\u2019s data. Finally, advanced computational features can be added to the real estate sys-\ntems by adding faster search algorithms to the model component independently from both \nview and controller. This flexibility can be extended to distributed environments, such as \nView 1\nView 2\nView n\nBox-and-Line Diagram\nUML Component Diagram\nController 1\nController 2\nModel\nController n\n<<component>>\nSmartBoardView\n<<component>>\nRealEstateModel\nIModel\nIObserver\nIObserver\nIPenController\n<<component>>\nPCView\n<<component>>\nSbController\nIModel\nIObserver\nIObservable\nIObserver\nISpeechController\n<<component>>\nSpeechController\nFIGURE 4.9\nThe model\u2013view\u2013controller architectural pattern.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 153", "position": 153, "chunk_type": "semantic", "token_estimate": 325}
{"text": "130\u2002 \u2022\u2002 Software Engineering Design\ufeff: Internet systems, where MVC architectures are very popular. Systems based on the MVC \nbenefit from flexibility that allows them to evolve gracefully over time. The main quality \nattributes associated with MVC systems are presented in Table\u00a04.10. There are some variations of the MVC architectural pattern. One popular variation of \ndesigning MVC systems includes the fusion of views and controller components into one \ncomponent. This variant was very popular in the 1990s as part of Microsoft\u2019s Document-\nView architecture integrated in the Microsoft Foundation Classes (MFC) Visual C++ envi-\nronment. The Document-View architecture sacrificed exchangeability of the controller for \nsimplicity. Other, more extensive variations include the process\u2013abstraction\u2013controller \n(PAC) architectural pattern (Qian et al. 2009). The PAC is an extension of the MVC, where \nsystems are decomposed into agents, each containing a process, abstraction, and controller \ncomponents arranged in hierarchical fashion. TABLE\u00a04.10\nQualities of the MVC Architectural Pattern\nQuality\nDescription\nModifiability\nEasy to exchange, enhance, or add additional user interfaces\nUsability\nBy allowing easy exchangeability of user interfaces, systems can be configured with different \nuser interfaces to meet different usability needs of particular groups of customers\nReusability\nBy separating the concerns of the model, view, and controller components, they can all be \nreused in other systems\nPCView\nApplication\nRealEstateModel\nSpeechController\n5 : show()\n6 : show()\n9 : sendCommand(FIND_CMD,SFH,33803)\n10 : processCommand()\n12 : getResults()\n11 : update()\n4 : attach(aView)\n2 : aView := new SpeechCustomizedView()\n3 : aController := new VoiceController()\n7 : onVoiceInput(\u201c\ufb01nd single family homes in Lakeland, FL\u201d)\n8 : processSpeech()\n1 : aModel := new Model()\nOnce the view is\ndisplayed, it enables\nthe voice input mode\nto receive voice input. : User\nFIGURE 4.10\nThe sequence for searching for single-family homes in Lakeland, Florida.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 154", "position": 154, "chunk_type": "semantic", "token_estimate": 295}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 131: Skill Development 4.3: Distributed MVC Real Estate System\nConsider a distributed, Internet version of the MVC real estate system. Using pencil \nand paper, use UML ports and delegate relationships to modify the component dia-\ngram of Figure\u00a04.9 to support the development of this system under the new environ-\nment constraints. Draw also a deployment diagram that shows how the system can be \ndeployed on tablets and mobile phones. Feel free to modify the original MVC relation-\nships and diagram to account for this new problem.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 155", "position": 155, "chunk_type": "semantic", "token_estimate": 94}
{"text": "Hierarchical systems are systems in which components can be structured in hierarchical: fashion so that components exist at different levels of abstraction and each level addresses \na particular concern of the software system. For each level identified in the hierarchical \nsystem, one or more components can be identified, each possibly branching downward \nto other components necessary to carry out a particular operation. Conceptually, compo-\nnents residing at higher levels of the hierarchy structure dispatch requests and rely on the \nservices of those in lower levels of the hierarchy. In some cases, access to the services pro-\nvided at the different levels can be unified and strictly controlled, therefore compartmen-\ntalizing them and increasing the reusability of their services. In other cases, the hierarchy \nstructure is mapped conceptually to the processing of data, resulting in a set of functional \ncohesive components at appropriate levels of abstraction for creating modular systems. In\u00a0any case, designing systems in hierarchical fashion typically leads to well-structured \nand modular systems. Two common architectural patterns for hierarchical systems are\n\u2022\t Main program and subroutine\n\u2022\t Layered\nMain Program and Subroutine\nThe main program and subroutine architectural pattern is popular in systems that are \ndesigned using the structured (or functional) design strategy. In these systems, a main \ncomponent (or\u00a0program\u00ad\n) \u00ad\ncontains the main data for the program, which is shared among \ncomponents residing\u00ad\n at lower levels of the hierarchy. Each level of the hierarchy represents \nrefinements of the system, so that level n provides the main level; level n + 1 provides further \nrefinements of services; n + 2 provides even further refinements, and so on. This process \ncontinues until the system is decomposed into an appropriate set of finer-grained compo-\nnents (or \u00ad\nsubroutines). To illustrate this concept, consider creating the logical architecture \nfor a printer system, based on its data-flow diagram (DFD). When using a DFD, inputs and \noutputs are represented by boxes, data flowing through systems are represented by arrows, \nand data transformations are represented by circles, as presented in Figure\u00a04.11. As seen, a", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 155", "position": 155, "chunk_type": "semantic", "token_estimate": 342}
{"text": "Tray Output: Keypad Input\nComputer Input\nStructure Chart - Logical Architecture\nKeypad Display\nLevel 2 DFD\nTray Output\n<<component>>\nPrinter\nIComputer\nITray\nIKeypad\n<<component>>\nTray Output\n<<component>>\nComputer IF\n<<component>>\nKeypad IO\nFIGURE 4.11\nThe main program and subroutine architectural pattern.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 156", "position": 156, "chunk_type": "semantic", "token_estimate": 41}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 133: distinct transformations are required: one for transforming data from the keypad input to \nthe keypad display; and the other for transforming computer input into a printout. In the \nLevel 2 DFD, two distinct flows of data are identified: one to generate printouts in black and \nwhite; and the other to generate printouts in color. In each flow, different transformations \nare required. This refinement is iteratively done, and once all transformations are identified \nthey can be grouped into components to form the logical architecture of the system. In this \nexample, the print manager (PM), which is the main program, consists of three independent \ncomponents, which provide the subroutines identified based on the data transformations. A\u00a0more detailed coverage of this approach is represented by Pressman (2010, p. 265). The main components identified for the main program and subroutine architectural \n\u00ad\npattern include one main component, which stores all the data, and various, finer-grained, \nsubcomponents that carry out detailed system operations. Systems based on this archi-\ntectural pattern benefit mainly from its structured decomposing, such that independent, \nsingle-purpose components become easier to understand, manage, code, debug, and reuse. The main quality properties associated with the main program and subroutine architec-\ntural pattern are presented in Table\u00a04.11. Layered Pattern\nThe main program and subroutine architectural pattern leads to hierarchical structures that \nexpand vertically and horizontally, with each level of the hierarchy containing one or more \ncomponents that can interact with one or more components at lower-levels of the hierarchy. A more constrained form of hierarchical structure involves each layer having one main \ncomponent\u2014which can be composed internally of multiple components\u2014that provides a \nunified interface for communicating with components residing immediately below in the \nhierarchy structure. This form of constrained collaboration of hierarchical architectures \nis captured with the layered architectural pattern. With the layered architectural pattern, \nthe work performed to accomplish a system function is somewhat independent and more \ncompartmentalized than in the main program and subroutine. It is used when systems can \nbe decomposed into cohesive layers with a structured way of interfacing between layers. The layered architecture is widely used in systems software, such as an operating system\u2019s \ncommunication stack, where each layer is an abstraction of a major function of communi-\ncation systems.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 157", "position": 157, "chunk_type": "semantic", "token_estimate": 381}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 133: It is used when systems can \nbe decomposed into cohesive layers with a structured way of interfacing between layers. The layered architecture is widely used in systems software, such as an operating system\u2019s \ncommunication stack, where each layer is an abstraction of a major function of communi-\ncation systems. Each layer also relies on services from other layers directly below to create \ncommunication packets and to provide quality of service, routing services, node-to-node \ncommunication, and transmission using varied physical layers. This way, rules can be \nTABLE\u00a04.11\nQuality Properties of the Main Program and Subroutine Pattern\nQuality\nDescription\nModifiability\nBy decomposing the system into independent, single-purpose components, each component \nbecomes easier to understand and manage. Reusability\nIndependent, finer-grained components can be reused in other systems.", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 157", "position": 157, "chunk_type": "semantic", "token_estimate": 133}
{"text": "134\u2002 \u2022\u2002 Software Engineering Design\ufeff: imposed on the system\u2019s logical architecture to restrict access among components, therefore \ndecreasing the system\u2019s coupling and increasing its modifiability and portability. That is, by \ncompartmentalizing major system functions and controlling access to their services (via \nwell-defined and stable interfaces), system modifiability and portability can be increased. Consider the logical architecture of an environmental embedded monitor and control \nsystem capable of being remotely deployed to monitor and control other nodes in a sys-\ntem that provides environmental information. The system works by receiving a collection \nschedule that is used to activate and deactivate other nodes in the system, to control their \noperations, and to retrieve their collected data. Since the system is deployed in environmen-\ntal areas where communication infrastructure may not be present, it uses satellite commu-\nnications to receive collection schedules and to provide environmental information back \nto a central station, where it can be safely analyzed. Collection schedules are encrypted to \nprovide additional level of security, which means that upon receipt the remotely deployed \nsystem needs to decrypt the messages and perform application-dependent logic to inter-\npret and execute them. Once a collection schedule for a particular node in the system is \nexecuted, the system interfaces with the hardware to send appropriate commands to other \ncollection nodes. The logical architecture for this system is designed using the layered \narchitectural pattern, as seen in Figure\u00a04.12. The box-and-line design of Figure\u00a0 4.12 presents a generic approach to designing \n\u00ad\nlayered software. It shows each independent layer collaborating only with the services \nof the \u00ad\nlayers immediately below. This way, replacing services at one layer does not affect \nthe whole system. When applied to the environmental monitor and control system, \nthe UML component diagram results in the one presented in Figure\u00a04.12. As seen, the \nSatcomLayer component abstracts the services required to receive a monitor plan, which \nwhen received is passed down to the SecurityLayer component for decryption and further \npassed down the layered hierarchy for processing in the ApplicationLayer. Once environ\u00ad\nmental monitoring is activated, the ApplicationLayer component interfaces with the \nHardwareComponent to initiate activation of the external nodes. As seen, UML ports are \nused to show the boundaries of the remote monitor system, and the delegate label is used \nto indicate that the responsibility for fulfilling the required services is delegated to one or \nmore components in the system.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 158", "position": 158, "chunk_type": "semantic", "token_estimate": 397}
{"text": "134\u2002 \u2022\u2002 Software Engineering Design\ufeff: Once environ\u00ad\nmental monitoring is activated, the ApplicationLayer component interfaces with the \nHardwareComponent to initiate activation of the external nodes. As seen, UML ports are \nused to show the boundaries of the remote monitor system, and the delegate label is used \nto indicate that the responsibility for fulfilling the required services is delegated to one or \nmore components in the system. The main quality attributes associated with the layered \narchitectural pattern are presented in Table\u00a04.12. Skill Development 4.4: Layered Architectural Pattern\nConduct an online search for the Open Systems Interconnection (OSI) reference model \nor TCP/IP model. Select one and explain how the layered architectural pattern applies \nto the selected model. Clearly identify each layer, their services, and how they interact \nwith other layers in the system. Can you think of other system software that can be \ndesigned using the layered architectural pattern? Come up with such examples and \nthen identify the layers that you would create and the services (and interaction with \nother layers) within the system.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 158", "position": 158, "chunk_type": "semantic", "token_estimate": 173}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 135: Layer 1\nLayer 2\nBox-and-Line Diagram\nLayer 3\nLayer n\nUML Component Diagram\n<<component>>\nSatcomLayer\n<<subsystem>>\nRemoteMonitorSystem\nISatcom\nISecure\n<<component>>\nSecurityLayer\n<<delegate>>\n<<component>>\nApplicationLayer\n<<component>>\nHardwareLayer\nISecure\nIApplication\nIHardware\nIApplication\nINodeMonitor\nINodeMonitor\n<<delegate>>\nIMonitorPlan\nIMonitorPlan\nFIGURE 4.12\nThe layered architectural pattern. TABLE\u00a04.12\nQuality Attributes Associated with the Layered Architectural Pattern\nQuality\nDescription\nModifiability\nDependencies are kept local within layer components. Since components can access other \ncomponents only through a well-defined and unified interface, the system can be modified \neasily by swapping layer components with other enhanced or new layer components. Portability\nServices that deal directly with a platform\u2019s application programming interface (API) can be \nencapsulated using a system layer component. Higher-level layers rely on this component for \nproviding system services to the application; therefore, by porting the system\u2019s API layer to \nother platforms the systems become more portable. Security\nThe controlled hierarchical structure of layered systems allows for easy incorporation of \nsecurity components to encrypt or decrypt incoming or outgoing data. Reusability\nBy compartmentalizing each layer\u2019s services, they become easier to reuse.", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 159", "position": 159, "chunk_type": "semantic", "token_estimate": 181}
{"text": "During software architecture, designers spend a great deal of time devising architectural solu-: tions that provide the necessary components and interfaces to achieve systems\u2019 requirements. At the architectural level, common patterns have emerged that describe the elements of the \nsystem and the quality characteristics of those elements. These patterns, also known as archi-\ntectural styles, have emerged as the mainstream approach for achieving reuse of successful \ndesign solutions at the architectural level and are fundamental to the efficient creation of soft-\nware architectures. Architectural patterns provide generic, reusable architectural solutions, \ndocumented in a way that can be easily understood and applied to new problems requiring \nsimilar architectural features. Decisions based on architectural patterns benefit from years of \ndocumented experience that highlights the solution approach to given problems, the benefits \nof these approaches, and the consequences of designing the system with a particular style. Architectural patterns can be classified by the type of systems they support, such as \ndata-centered, data-flow, distributed, interactive, and hierarchical systems. Examples \nof architectural patterns include blackboard, pipe and filter, client\u2013server, broker, \nmodel\u2013view\u2013controller, main program and subroutine, and layered patterns. These patterns \nallow designers to efficiently conduct principled analyses of the layout of sub\u00ad\nsystems and \ncomponents that need to communicate in the operational system. During the past decade, \nmany styles and patterns for software architecture have been researched and published. Many of these patterns have been identified in pattern catalogue books; some of these are \ncommon design patterns in enterprise-level systems, while others address specific needs \nsuch as distributed systems. Identifying and designing using architectural patterns can \nimprove the efficiency of the development process and the quality of the final system.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 160", "position": 160, "chunk_type": "semantic", "token_estimate": 275}
{"text": "1.\tWhat is an architectural pattern, and how does it differ from detailed design patterns?: 2. List and explain the different types of systems discussed for which architectural \n\u00ad\npatterns can be employed. 3. Are software architectures restricted to only one architectural pattern for its \u00ad\nlogical \ndesign, or can they include more than one architectural pattern? Explain with examples. 4. Can architectural patterns lead to direct translation to code? Explain. 5. Explain the following architectural patterns, and provide an example of a system \n(different from the one discussed in this chapter) appropriate for them. Explain how \nthese patterns support particular quality attributes. a. Blackboard\n\t\nb. Pipe and filter\n\t\nc.\t MVC\n\t\nd.\t Layered", "domains": ["Architectural Patterns and Styles"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 160", "position": 160, "chunk_type": "semantic", "token_estimate": 113}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 137: 6. Compare and contrasts the following architectural patterns:\n\t\na.\t Client\u2013server vs. broker\n\t\nb.\t Layered vs. main program and subroutine\n\t\n7. How can the pipe and filter architectural pattern enhance the performance of software \nsystems? 8. How can the MVC enhance a system\u2019s modifiability, usability, and reusability? 9. How can the broker pattern enhance a system\u2019s interoperability? 10. How can the layered pattern support a system\u2019s security and portability? 11. Explain how using design elements from different architectural views can support \nthe use of architectural patterns for providing a complete picture of an architectural \ndesign element.", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 161", "position": 161, "chunk_type": "semantic", "token_estimate": 103}
{"text": "1.\tFind a computer using the Microsoft Windows operation systems and Microsoft Office: Word. Perform a Google search on how to split the window horizontally of the par-\nticular version of Word that you are executing so that you can split a document hori-\nzontally into two windows that mirror each other. Position each window on the same \ndocument location, and begin typing in the topmost window. As you type, you should \nsee the bottom window getting updated in real time to incorporate the newly entered \ntext. Explain how architectural patterns can help achieve this capability. Provide spe-\ncific examples of architectural patterns that can be used for this capability. 2. Using the UML tool of choice, create the logical design using patterns for a portable, \ninteractive, and distributed software system. State your assumptions, and accompany \nyour design with a rationale of why the particular patterns were selected and how they \nsupport the required quality attributes. Feel free to design around the patterns to pro-\nvide other views and to present a whole picture of the system design.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 161", "position": 161, "chunk_type": "semantic", "token_estimate": 178}
{"text": "\u2022\t Understand the role of detailed design within the software design phase: \u2022\t Become familiar with detailed design tasks during software design\n\u2022\t Become familiar with the detailed design process\n\u2022\t Understand fundamental concepts of object-oriented concepts and \nprinciples for component designs\n\u2022\t Understand the role of documentation in software design and how to \ncreate a software design document", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 163", "position": 163, "chunk_type": "semantic", "token_estimate": 59}
{"text": "The previous chapters presented the software architecture activity as a: macrodesign approach for transforming software requirements into design \nelements that specify the main components and interfaces of software sys-\ntems. This holistic black-box approach is essential for establishing the initial \ndesign and a framework of quality that guides and supports the detailed \ndesign and construction of software systems. During detailed design, the \ndesign process continues where software architecture leaves off for pro-\nviding a white-box approach to design, where details left undefined and \ndeferred to downstream designers are created to define the necessary details \nfor fully specifying the internal structure and behavior of components iden-\ntified during architecture. These detailed designs fill the gaps in the design \nand provide a complete picture of how the system achieves its functional \nrequirements within the quality framework established by the software \narchitecture. Detailed design decisions can significantly shape the system\u2019s \nquality properties (e.g., portability, performance, usability); therefore, they", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 163", "position": 163, "chunk_type": "semantic", "token_estimate": 155}
{"text": "140\u2002 \u2022\u2002 Software Engineering Design\ufeff: must exist within the bounds of the software architecture. In some cases, where modeling \ntools are used to generate code, detailed designs can also significantly impact the quality \nproperties of the construction phase. Upon completion of the detailed design activity, the \n\u00ad\nsystem\u2019s design is sufficiently complete so that it can be formally documented, reviewed, \nand approved by the system\u2019s stakeholders, which marks the end of the design phase. WHAT IS DETAILED DESIGN? The detailed design activity begins once the software architecture is specified, reviewed, and \napproved by all stakeholders in the project. During detailed design, logical components are \nrefined and their interactions are modeled to verify the validity of their structural compo-\nsition. The execution of the detailed design activity requires a shift from the macro\u00ad\ndesign \napproach to the microdesign approach to further decompose and refine system components \ninto one or more fine-grained elements, functions, and data variables required for support-\ning the internal structure and behavior of components that meet assigned roles during the \nsoftware architecture activity. IEEE (1990, p. 26) defines detailed design as\n\t\n1. The process of refining and expanding the preliminary design phase of a system or \ncomponent to the extent that the design is sufficiently complete to be implemented. 2. The result of the process in 1. Extending the IEEE definition, detailed design is both the process of refining the soft-\nware architecture to reach a point where construction can begin and the result of such \nprocess. The detailed design activity is the last major design effort before the software con-\nstruction phase. A fundamental difference between architectural and detailed design is \nthat whereas the former is concerned mostly with defining the major components of the \nsystem and their interfaces, the latter is concerned with how these components realize their \nassigned responsibility. This suggests that architectural designs employ a holistic approach \nto software system design, which emphasizes system quality, while detailed design focuses \non particular components within the system, which emphasizes the functional aspects of \na system. This fundamental difference is essential in determining what and how work is \nperformed during these activities. For example, whereas the component notation provides \nan appropriate mechanism for designing logical architectures, their level of abstraction \nis inappropriate for modeling detailed design elements. Therefore, in object-oriented sys-\ntems, classes and interfaces become the major unit of design work.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 164", "position": 164, "chunk_type": "semantic", "token_estimate": 395}
{"text": "140\u2002 \u2022\u2002 Software Engineering Design\ufeff: For example, whereas the component notation provides \nan appropriate mechanism for designing logical architectures, their level of abstraction \nis inappropriate for modeling detailed design elements. Therefore, in object-oriented sys-\ntems, classes and interfaces become the major unit of design work. This, in turn, influences \nthe type of analyses performed during both activities. The modeling and analyses that \noccur during architecture help answer the questions of what needs to be developed, and by \nthemselves these models and analyses cannot be used to build directly a working software \nsystem. Detailed design goes deep into each component to define its internal structure and \nbehavioral capabilities, and the resulting design leads to natural and efficient construction \nof software. Clements, Bachmann, Bass, Garlan, Ivers, Little, Nord, and Stafford (2002, p.\u00a05) \ndifferentiate between architectural and detailed design as follows:", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 164", "position": 164, "chunk_type": "semantic", "token_estimate": 139}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 141: Architecture is design, but not all design is architecture. That is, many design decisions are \nleft unbound by the architecture and are happily left to the discretion and good judgement of \ndownstream designers and implementers. The architecture establishes constraints on down-\nstream activities, and those activities must produce artifacts\u2014finer-grained design and code\u2014\nthat are compliant with the archtiecture, but architecture does not define an implementation. Detailed design is closely related to architecture and construction; therefore, successful \ndesigners (during detailed design) are required to have a full understanding of the system\u2019s \nrequirements and architecture, design strategy, programming language, and methods and \nprocesses for software quality control. Detailed designers must also work closely with stake-\nholders (e.g., hardware team, test team, quality team, management) to provide designs that \naccommodate multiple concerns appropriate to the detailed design activity. This requires \na holistic vision\u2014different from that of the software architecture designer\u2014to envision \ndetailed designs and how they relate to requirements, architecture, and construction, as \npresented in Figure\u00a05.1. The conceptual model presented in Figure\u00a0 5.1 shows interrelationships that detailed \ndesign elements have with other architectural or construction elements. In this context, \nC\nRequirements,\nArchitecture \nDetailed Design\nRequirements,\nArchitecture \nDesigner\u2019s Mental Model\nCode \nCode \nDetailed\nDesign\nFIGURE 5.1\nContext of detailed design activity.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 165", "position": 165, "chunk_type": "semantic", "token_estimate": 214}
{"text": "142\u2002 \u2022\u2002 Software Engineering Design\ufeff: detailed designs provide the essential structure that acts as bridge connecting the work \nperformed during architecture and construction. Detailed designs need to incorporate \ndesign alternatives that support the requirements and quality attributes (e.g., testability, \nmaintainability, modifiability) identified in previous phases and activities of the software \nengineering life cycle. When presented with requirements or concerns from other stake-\nholders, detailed designers are able to visualize designs that provide the required struc-\ntural and behavioral capabilities for achieving those needs. As they work to shape new \nor existing designs, they are also capable of visualizing the executing code to help them \nformalize the design. When given code, such as the case during the maintenance phase, \ndetailed designers are required to envision detailed designs or even reverse engineer the \ncode into designs and to understand how both code and designs relate to the original soft-\nware requirements. This mental model allows designers to understand the complex inter-\ndependencies that exist among these different life cycle phases and how requirements and \nquality attributes are achieved throughout the software project. Achieving such visions \nfrom designers helps in all aspects of designing high-quality, large-scale software systems.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 166", "position": 166, "chunk_type": "semantic", "token_estimate": 195}
{"text": "It can be argued that the detailed design phase is where most of the problem-solving activi-: ties occur in software projects. Consider the case where formal design processes are fol-\nlowed so that the requirements phase is followed by the architectural design activity, which \nis \u00ad\nfollowed by detailed design. In many practical applications, the architectural design \nactivity defers complex problem solving to the detailed design activity mainly through \nabstraction. In some cases, even defining the requirements is deferred to the detailed design \nphase, leaving the detailed design activity as the gatekeeper for ensuring that the system\u2019s \nspecification and design are sufficiently complete before construction begins. Deferring \nsuch problems to the construction phase is a recipe for failure, since this typically results \nin higher cost (Clements, Kazman, and Klein 2001). When done properly, detailed designs \nshould provide a ready-made solution that eases the construction process\u00ad\n. To achieve this \nduring detailed design, designers must fully understand requirements assigned to com-\nponents and architectural decisions deriving detailed design; they must design complex \ninterfaces, identify design patterns, evaluate and validate detailed designs, generate code \nfrom the models, and establish policies for ensuring design synchronicity throughout the \nconstruction phase.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 166", "position": 166, "chunk_type": "semantic", "token_estimate": 196}
{"text": "Unlike the software architecture activity, where the complete set of system requirements: are evaluated and well understood, designers during the detailed design activity focus \non requirements allocated to their specific components. In some cases, requirements can \ncross-cut several components; therefore, communication with other designers is essential \nto coordinating the design solution without duplicating work. Besides addressing require-\nments passed on from the architectural activity, it is also common during detailed design \nto derive new software requirements as knowledge of the system is enhanced throughout \nthe detailed design activity. Derived requirements are requirements based on higher-level \nspecifications created to address a finer-grained function or process during detailed design \nand construction. These requirements can help standardize operations for higher-level \nrequirements identified in previous phases and activities of the project. Consider an \nembedded real-time software system broken down into five different major subsystem \ncomponents, each executed on different target hardware and broken down further into \nnumerous other components. During requirements, the functional capability to log events \nin the system is specified. To carry out this function of the system, a detailed design activ-\nity is done to create a common event logger so that all components in the systems rely on \na standardized way for logging events in the system. Because of the resource-constrained \nenvironment of the particular embedded system, simply having one functional require-\nment to log events provides insufficient specification for the desired behavior. Consider the \ncase where the event logger is designed to log all events in the system to a file without limits \nor policies to manage how events are stored, purged, and so forth. In such a resource-\nconstrained environment, enforcing and verifying policies for such behavior is essential, \nsince a large number of events, depending on the target resources, can slow or bring the \nsystem down. In such cases, deriving requirements that specify these policies (e.g., maxi-\nmum number of events logged, event purge policy such as first-in, first-out (FIFO), last-in, \nlast-out (LIFO)) provides essential items of verification for the system. These requirements \nare imposed not by customers but by the design team to enforce a desired capability of the \nsoftware or process to develop the software. When conducting the detailed design activity,", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 167", "position": 167, "chunk_type": "semantic", "token_estimate": 366}
{"text": "After requirements and the software architecture are well understood, the detailed design: of software components can begin. The detailed design consists of structural and behav-\nioral designs required to specify components sufficiently so that they can be consistently \nconstructed by one or more programmers. This entails various design tasks, including \nrefining or \u00ad\ncreating components\u2019 interface design internal structure, and behavioral \ndesign; identifying design patterns; applying design principles; adopting naming conven-\ntions; and evaluating and documenting detailed designs. These are discussed in more \ndetail throughout the following sections. Interface Design\nInterface design refers to the design activity that deals with specification of interfaces \nbetween components in the design (Sommerville 2010). Interface design can be focused on \nspecifying the interfaces used internally within software components or externally across \nsoftware components. In both cases, interfaces provide a standardized way for specifying \nhow services are accessed and provided by software components. Interface design allows \nsubsystems to be designed independently and in parallel; therefore, it is typically done first \nwithin the detailed design step. External Interface Design\nDuring the software architecture activity, externally visible interfaces are specified. The \nrealization of these interfaces may involve much detailed design work before they can \nbe used in construction. These may include a customized binary message definition,", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 168", "position": 168, "chunk_type": "semantic", "token_estimate": 209}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 145: Extensible Markup Language (XML) schemas and messages, or other interfaces required \nfor specifying how components interact with other external components. Depending on \nthe interface design effort, a formal interface document can be created and managed inde-\npendently, similar to the requirements specification or design document. This document, \nknown as the interface control document (ICD), is an important piece of documentation \nthat serves as a written contract between components of the software system to specify how \nthey will communicate. The ICD defines the important data and protocols used for com-\nmunication between components, therefore providing developers during construction the \nrequired information needed to write the software. Internal Interface Design\nThe Internal interface definition establishes policies for subsequent development in the \nsoftware design. It provides a way for abstracting common operations so that problems \nduring detailed design can be reasoned in terms of these interfaces, which provides a \nhigher level of abstraction for specifying rules that apply to a larger set of entities that \nrely on them. In object-oriented systems, Unified Modeling Language (UML) can be used \nto create interface designs using class diagrams that include the <<interface>> \u00ad\nstereotype \nin the name section of the class, as presented in Chapter 2. These help identify the major \nclasses and functions that allow intercomponent communication and provide the rules \nof communication that must be followed by other classes that implement these interfaces \nduring the detailed design activity. Graphical User Interface Design\nVisual designs have a major role in the success or failure of software systems. Systems that \nmeet functional requirements but are not usable cannot succeed. During detailed-design, \nthe initial Human Computer Interface (HCI) design identified during the software archi-\ntecture activity is refined and the appropriate design for interfacing the Graphical User \nInterface (GUI) to the whole system is done. During detailed design, all aspects of the \nGUI\u2014such as modes, navigation, visual designs (e.g., color, icons, fonts), response time and \nfeedback, design modalities (e.g., forms, menu-driven), localization, internationalization, \nand general human\u2013computer design principles\u2014are fine-tuned. Designing Internal Structure of Components\nComponent design is not restricted to object-oriented systems; however, the discussion \nand approach presented in this section and throughout the book focus on object-oriented \nsystems\u00ad\n. Other forms of component design can be employed based on the design \u00ad\nstrategy, \nsuch as the structured design strategy.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 169", "position": 169, "chunk_type": "semantic", "token_estimate": 389}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 145: Designing Internal Structure of Components\nComponent design is not restricted to object-oriented systems; however, the discussion \nand approach presented in this section and throughout the book focus on object-oriented \nsystems\u00ad\n. Other forms of component design can be employed based on the design \u00ad\nstrategy, \nsuch as the structured design strategy. In object-oriented systems, the internal structure \nof components is typically modeled using UML through one or more class diagrams. Component design refers to the detailed design task of defining the internal logical structure \nof components. That is, the internal data structures, algorithms, interface characteristics,", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 169", "position": 169, "chunk_type": "semantic", "token_estimate": 101}
{"text": "146\u2002 \u2022\u2002 Software Engineering Design\ufeff: and communication mechanisms of all components are all defined during component \ndesign. For this reason, component design provides the most significant mechanism for \ndetermining the functional correctness of the software system and allows for evaluating \nalternative solutions before coding begins. A multitude of principles, guidelines, and patterns exist for creating quality component-\nlevel design. These principles guide engineers to make appropriate decisions when \u00ad\nrefining \ncomponents into other components and classes and defining the relationships between \nthem. The work produced during component design serves as strong indication of the \nfunctional success of the software system. Before these concepts can be understood, it is \n\u00ad\nnecessary to understand the basic concepts in component design of object-oriented \u00ad\nsystems. These include (Gamma et al. 1995):\n\u2022\t Classes and objects\n\u2022\t Interfaces, types, and subtypes\n\u2022\t Dynamic binding\n\u2022\t Polymorphism\nClasses\nThe main unit of composition in object-oriented component design is the class. Chapter 2 \nintroduced classes as modeling entities in UML class diagrams. However, before becoming \nefficient during component design, a clear distinction between classes and objects needs to \nbe made. A class is a specification that defines the data and services used and provided by \nparticular objects. There are two types of classes in object-oriented component designs, as \npresented in Table\u00a05.1. Concrete classes specify the data, services, and implementation of those services required \nfor instantiating objects. Concrete classes provide complete information that supports \ninstantiation of objects at run time that have state and behavior. On the other hand, abstract \nclasses are special types of classes that contain one or more abstract methods, which have \nno implementation. Because abstract methods contain no implementation, abstract classes \ncannot be instantiated at run time. A special type of abstract class is one where all methods \nare abstract. These are equivalent to Java interfaces and the pure virtual classes in C++. As abstract classes, interfaces and pure virtual classes cannot be instantiated at run time. At\u00a0first glance, it seems logical to think that classes that cannot be instantiated serve little to \nno purpose in software designs. However, these classes provide powerful mechanisms for \ncreating elegant and reusable designs that can lead to increased maintainability, reusability, \nTABLE\u00a05.1\nTypes of Classes in Component Designs\nType\nDescription\nConcrete\nOrdinary class for specifying object\u2019s data and behavior\nAbstract\nSpecial class that contains at least one abstract method", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 170", "position": 170, "chunk_type": "semantic", "token_estimate": 395}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 147: and efficient software evolution. Abstract classes provide the means for designers to create \ncontracts that dictate the use of interfaces throughout software designs. These contracts are \nenforced by compilers and are founded on the principles and concepts of interfaces, types, \nsubtypes, dynamic binding, and polymorphism. Interfaces, Types, Subtypes, Dynamic Binding, and Polymorphism\nIn a broad sense, an interface is the set of functions that specify the services provided by \nobjects of a particular type. An interface method is simply one method that belongs to an \nobject\u2019s interface. The concepts of types and interfaces are interrelated; that is, since an \ninterface specifies the services provided by a particular type, it follows that a particular \ntype refers to a particular interface. In popular object-oriented systems, the concept of \ntypes is used interchangeably with classes. A subtype refers to an interface that includes \nthe interface of another type, referred to as its supertype (Gamma et al. 1995). This con-\ncept is reflected in object-oriented languages as inheritance. At design time, the concepts \nof interfaces, types, and subtypes are used to create software that is extensible at run time, \nmainly through the techniques of dynamic binding and polymorphism. Consider the \nspecification of an interface using an abstract class, which, as discussed before, cannot \nbe instantiated. In such cases, abstract classes are useful for defining the common set of \nservices provided by a specific type. Through inheritance, one or more subtypes can be \nspecified at design time to provide implementations for the defined interfaces, therefore \ncreating concrete classes that share the same interface, as defined by the abstract class. By\u00a0designing classes this way, different objects can be instantiated at run time to share the \nsame interface but to provide completely different implementations (Gamma et al. 1995). Consider the type Shape with a single interface method named draw(). Now consider \ntwo other subtypes (inheriting from Shape), named Circle and Rectangle. By defi-\nnition, since Circle and Rectangle are subtypes of Shape, then they share its inter-\nface, which in this example includes the draw() interface method. This scenario is easily \ndesigned in modern programming languages by specifying Shape as pure virtual class \nin C++ or interface in Java. Both Circle and Rectangle would be designed using a \n(UML) realization relationship with the Shape type.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 171", "position": 171, "chunk_type": "semantic", "token_estimate": 385}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 147: This scenario is easily \ndesigned in modern programming languages by specifying Shape as pure virtual class \nin C++ or interface in Java. Both Circle and Rectangle would be designed using a \n(UML) realization relationship with the Shape type. Since Circle and Rectangle are \nmeant to be concrete classes, they both must provide an implementation for the draw() \ninterface method; otherwise, they would both be abstract classes that cannot be instanti-\nated. With this framework in place, portions of the software at design time can be specified \nusing the Shape interface, which both Circle and Rectangle support. At run\u00a0time, \nservices specified by the Shape interface are carried out by the particular run-time object \nattached to the request, which could be objects of either Circle or Rectangle sub-\ntypes. This way, when calling upon the object\u2019s draw interface method, the software can \nbehave differently at run time by drawing to the screen either a circle or a rectangle. The mechanism for providing the run-time association between an object and an inter-\nface method is known as dynamic binding (Gamma et al. 1995). This allows objects of the \nsame type hierarchy to behave differently at run time simply by associating the interface \nmethod call to the appropriate run-time instance. This capability is known as polymorphism.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 171", "position": 171, "chunk_type": "semantic", "token_estimate": 219}
{"text": "148\u2002 \u2022\u2002 Software Engineering Design\ufeff: Interfaces, types, subtypes, dynamic binding, and polymorphisms are essential to achieving \nefficient designs of components in object-oriented systems and are the fundamental mecha-\nnisms for achieving most object-oriented design principles and patterns. Objects\nWhereas classes are design-time entities, objects are run-time entities; that is, objects are \nthe manifestation of classes and therefore occupy space and time during software exe-\ncution. For classes to be of use in executing programs, objects have to be instantiated. Instantiation is the process of manifesting a class in the computer\u2019s memory; this manifes-\ntation is referred to as an object of that class. Therefore, one class can be manifested in the \ncomputer\u2019s memory as multiple objects, since we can instantiate a class numerous times. This concept is presented in the conceptual model presented in Figure\u00a05.2. As seen, the code in the main function of the ProgramDriver class instructs the \ncompiler to instantiate three different objects of type ListNode type. In this example, \nthe specification for objects of type ListNode is provided by the ListNode class and \ninstantiation of objects of that class is done by employing the new keyword. When the \ncompiled and built version of the code is executed, three different objects of the same \nclass\u2014together with the object of type ProgramDriver\u2014will occupy some space in the \ncomputer\u2019s memory. These three objects of type ListNode occupy specific locations in \nmemory and are addressable by their own memory address. This is possible because each \nobject has its own identity. Notice also in the figure that the ProgramDriver object has \nlinks to the three different node objects, since it has variables holding the addresses to \n\u0012\u0012\u00037KH\u0003RQH\u0003DQG\u0003RQO\\\u0003VSHFLILFDWLRQ\u0003\n\u0012\u0012\u0003RI\u0003WKH\u0003/LVW1RGH\u0003W\\SH\u0011\u0003\nFODVV\u0003/LVW1RGH\u0003^\u0003\n\u00ab\n`\u0003\nSXEOLF\u0003FODVV\u00033URJUDP'ULYHU\u0003^\u0003\nSXEOLF\u0003VWDWLF\u0003YRLG\u0003PDLQ\u000b6WULQJ>@\u0003DUJV\f\u0003^\u0003\n\u0012\u0012\u0003,QVWDQWLDWH\u0003WKUHH\u0003REMHFWV\u0003RI\u0003WKH\u0003\u0003\u0003\u0003\n\u0012\u0012\u0003/LVW1RGH\u0003W\\SH\u0011\u0003\n/LVW1RGH\u0003QRGH2QH\u0003 \u0003QHZ\u0003/LVW1RGH\u000b\f\u001e\u0003\n/LVW1RGH\u0003QRGH7ZR\u0003 \u0003QHZ\u0003/LVW1RGH\u000b\f\u001e\u0003\n/LVW1RGH\u0003QRGH7KUHH\u0003 \u0003QHZ\u0003/LVW1RGH\u000b\f\u001e\u0003\n\u0003\u0003`\u0003\n`\u0003\nCompile and Build into Executable \n\u0013\u0003\u0014\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0014\u0003\u0014\u0003\u0013\u0003\u0014\u0003\u0013\u0003\u0014\u0003\u0013\u0003\u0014\u0003\u0013\u0003\u0014\u0003\u0013\u0003\u0014\u0003\u0014\u0003\u0013\u0003\u0003\nExecute in Computer \nMemory for Executable \nComputer Memory \nWKLV\u0003 \u0003\u0013[\u0013\u0013IIDDEE\u0003", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 172", "position": 172, "chunk_type": "semantic", "token_estimate": 313}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 149: these objects; therefore, programDriver can always access these objects through these \n\u00ad\nvariables (i.e.,\u00a0nodeOne, nodeTwo, nodeThree). Unlike classes, objects exist at run time and \nhave specific characteristics such as the ones presented in Table\u00a05.2 (Douglas 1999). When designing at the component level, careful class specification is essential to allow \nobjects at run time to behave in such a way that flexibility and reusability are added to \nthe software. This in turn allows component designs to provide the means to allow the \nsoftware to evolve gracefully over time and to become more reusable. Designing efficient \ncomponent structures allows today\u2019s software to adapt to future technology or new system \nfunctionality. Therefore, when designing component-level software, careful attention has \nto be paid in the application of fundamental detailed design principles. Design Principles for Internal Component Design\nSeveral principles have been identified throughout the literature that help in making \ncomponent-level design decisions, including\n\u2022\t The open\u2013closed principle (OCP)\n\u2022\t The Liskov substitution principle (LSP)\n\u2022\t The interface segregation principle (ISP)\nOpen\u2013Closed Principle\nThe OCP is an essential principle for creating reusable detailed designs. It promotes designs \nthat allow changes to be made by extension of designs rather than by modification of exist-\ning code. The main idea behind the OCP is that code that works should remain untouched \nand that new additions incorporated to address new concerns should be extensions of the \noriginal work. The OCP was originally coined by Bertrand Meyer (1997) and states that \nsoftware designs should be open to extension but closed for modification. At first glance, \nthe OCP sounds contradictory since it promotes designs that are closed to modification. However, in the OCP context, being closed to modification does not mean that designs \ncannot be modified; it means that modifications should be made as extensions to the \ndesign, by adding new design and code instead of modifying existing working designs and \ncode (Marin 2003). This is possible in object-oriented systems through the use of abstract \nclasses and interfaces. Consider a gaming system that includes several types of terrestrial \ncharacters, which can roam freely over land, as shown in Listing 5.1.", "domains": ["Design Patterns", "Design Principles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 173", "position": 173, "chunk_type": "semantic", "token_estimate": 358}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 149: This is possible in object-oriented systems through the use of abstract \nclasses and interfaces. Consider a gaming system that includes several types of terrestrial \ncharacters, which can roam freely over land, as shown in Listing 5.1. TABLE\u00a05.2\nCharacteristics of Objects\nCharacteristic\nDescription\nAttributes\nThe object\u2019s data\nBehavior\nThe object\u2019s designed behavior, as specified by its public functions\nState\nThe current state of the object, as defined by the values of its data\nIdentity\nTheir own individual memory address\nResponsibilities\nTwo objects of the same class can be instantiated for specific purposes", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 173", "position": 173, "chunk_type": "semantic", "token_estimate": 98}
{"text": "150\u2002 \u2022\u2002 Software Engineering Design\ufeff: As seen, the GameEngine class is designed with an interface method that accepts \nreferences (i.e., pointer) to objects that share the TerrestrialCharacter \ninterface. When an object of type TerrestrialCharacter is passed into the \naddCharacter(. . .) method, the method draws it to the screen and calls the char-\nacter\u2019s run() method, which activates the character to move over land in a random \npattern. This design works fine for all kinds of terrestrial characters; however, it does \nlittle to support efficient addition of other types of characters to the game. This is true \nbecause the design of the GameEngine class relies on the interface of the concrete \nTerrestrialCharacter class. Consider the case where characters that move dif-\nferently\u2014for example, aerial characters or aquatic characters\u2014are added to the gam-\ning system design. In such cases, the \u00ad\naddCharacter method needs to be modified to \naccount for these new types of characters. Therefore, the design of the GameEngine \nclass is not closed for modification. That is, the code inside the GameEngine class \nwould have to change, which violates the OCP. To prevent this, the OCP promotes and \nrelies on an indispensable design principle in object-oriented systems, which states \nthat software designs should rely on interfaces and not on implementations (Gamma \nListing 5.1: C++ Code for the Gaming System\n// The terrestrial character. class TerrestrialCharacter {\npublic:\n\t // Draw the character on the screen. virtual void draw() { /*Code to draw the terrestrial character. */ \n}\n\t // Make the character run! virtual void run() { /* Code to make the character run. */\n};\n// The game engine responsible for managing the game. class GameEngine {\npublic:\n\t // Add the character to the screen. void add(TerrestrialCharacter* pCharacter) {\n\t \t // Display the character. pCharacter->draw();\n\t \t // Make the character move! pCharacter->run();\n\t }\n};", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 174", "position": 174, "chunk_type": "semantic", "token_estimate": 302}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 151: et\u00a0al. 1995). Consider the addition of the Character* interface to the gaming system\u2019s \ndesign, as presented in Listing 5.2. As seen, the Character class is abstract, as specified by the two pure virtual methods \ngetType() and draw(). The character interface can be used to define interface \u00ad\nmethods \nthat are common to all characters in the gaming system. With this interface in place, the \naerial character is added to the design by implementing the Character interface, as \n\u00ad\npresented in Listing 5.3. *\t For those of you interested in compiling the code, e.g., the Character code, you will need to include in your code appro-\npriate libraries and namespace. In this case, to use the string type, you will need to include <string> and namespace \nstd to compile the Character class. This approach is generally followed throughout the rest of the book. Listing 5.2: C++ Code for the Character Interface\nclass Character {\npublic:\n\t // Get the type of character. virtual string getType() = 0;\n\t // Draw the character on the screen. virtual void draw() = 0;\n};\nListing 5.3: C++ Code for the AerialCharacter Class\nclass AerialCharacter : public Character {\npublic:\n\t // Get the type of character. virtual string getType() {\n\t \t // Return the type of character. return \u201caerial\u201d;\n\t }\n\t // Draw the character on the screen. virtual void draw() {\n\t \t // Code to draw the aerial character. cout<<\u201ddrawing aerial character!\\n\u201d;\n\t }\n\t // Make the character fly! virtual void fly() {\n\t \t // Code to make the character fly. cout<<\u201dcharacter flying!\\n\u201d;\n\t }\n};", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 175", "position": 175, "chunk_type": "semantic", "token_estimate": 261}
{"text": "152\u2002 \u2022\u2002 Software Engineering Design\ufeff: As seen, the AerialCharacter class implements both getType() and draw() in \nterms of aerial characters. The AerialCharacter class also specifies the interface method \nfly() to make the character fly in random patterns during the character\u2019s activation in the \ngame. With the Character interface added to the design, the TerrestrialCharacter \nis now modified to implement the newly added interface so that anywhere in the design \nwhere objects sharing the Character interface are expected, both terrestrial- and \naerial-type objects can be used. The redesigned TerrestrialCharacter class, which \nnow implements the Character interface, is presented in Listing 5.4. With this new framework in place, consider the redesign of the GameEngine from \nListing 5.1, presented in Listing 5.5. Two major modifications have been made to the \nGameEngine design. First, the add(   ) method is modified to rely on the Character \ninterface instead of on concrete classes; second, the code inside the add(   ) method now \naccounts for different types of characters. To\u00a0support this new behavior, the getType(   ) \nmethod has been added to retrieve the type of the character at run time so that the code \ninside the add() method can determine whether to make characters run or fly, depending \non their type. This fixes the problem of not being able to handle various types of characters \nwith different movements. This is an improvement from the first design version; however, \nthe design still violates the OCP. Anytime that a new character is added to the game, the \nListing 5.4: C++ Code for Redesigned TerrestrialCharacter Class\nclass TerrestrialCharacter : public Character {\npublic:\n\t // Get the type of character. virtual string getType() {\n\t \t // Return the type of character. return \u201cterrestrial\u201d;\n\t }\n\t // Draw the character on the screen. virtual void draw() {\n\t \t // Code to draw the terrestrial character. cout<<\u201ddrawing terrestrial character!\\n\u201d;\n\t }\n\t // Make the character run! virtual void run() {\n\t \t // Code to make the character run. cout<<\u201dcharacter running!\\n\u201d;\n\t }\n};", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 176", "position": 176, "chunk_type": "semantic", "token_estimate": 325}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 153: add(   ) method needs to be modified to add another conditional statement to test for \nthe new character and call the appropriate method to make the new character move. This \nis a direct effect of designs that violate the OCP. The gaming system\u2019s design is redesigned \none last time to make it conform to the OCP, as presented in Listing 5.6. As seen, to make \nthe design OCP-compliant, better abstractions are introduced to the Character interface, \nwhich now includes the move(   ) interface method. A major design decision made in the redesign of the gaming system includes the addi-\ntion of the move() interface method to the Character interface. This provides a higher \nlevel of abstraction that allows the design to appropriately abstract moving behavior for all \ncharacters in the system. By introducing a higher level of abstraction that is appropriate \nfor characterizing the behavior required by characters (e.g., walk, run, swim, or fly), the \ndesign now allows the GameEngine class to rely on this abstraction to support multiple \nexisting and future characters in the game, as seen in Listing 5.7. Listing 5.5: C++ Code for the GameEngine Class\nclass GameEngine {\npublic:\n\t // Add a character to the game. void add( Character* pCharacter ) {\n\t \t // Draw the character on the screen. pCharacter->draw();\n\t \t // If aerial, make it fly, otherwise, make it run. if( pCharacter->getType() == \u201caerial\u201d ) {\n\t \t \t // Downcast the pointer to an aerial character. AerialCharacter* pAerial = dynamic_cast<AerialCharacter*>\n\t \t \t\n(pCharacter);\n\t \t \t // Assume a valid pointer and make the character fly! pAerial->fly();\n\t \t }\n\t \t else {\n\t \t \t // Downcast the pointer to a terrestrial character. TerrestrialCharacter* pTerrestrial =\n\t \t \t\ndynamic_cast<TerrestrialCharacter*>(pCharacter);\n\t \t \t // Make the character run! pTerrestrial->run();\n\t \t } // end if statement.\n\t } // end add function. };", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 177", "position": 177, "chunk_type": "semantic", "token_estimate": 292}
{"text": "154\u2002 \u2022\u2002 Software Engineering Design\ufeff: With the redesign in place, the GameEngine can be used throughout to draw and \n\u00ad\nactivate all types of characters that share the Character interface, as seen in Listing 5.8. Consider the addition of an aquatic character under this new gaming system\u2019s design. In the OCP-compliant case, the new character is added with new code, by implementing \nthe Character interface. At run time, objects that share the Character interface can \nbe passed into the GameEngine, which draws and activates the new character using the \ninterface methods specified by the Character interface. The OCP-compliant design of \nthe gaming system with all three supported characters is presented in Figure\u00a05.3. An important caveat to the OCP is that no design is 100% closed for modification. At \nsome point, some code has to be readily available for modifications. The main idea of the \nOCP is to locate the areas of the software that are likely to vary and encapsulate them, so \nListing 5.6: C++ Code for the OCP-Compliant Gaming System\u2019s Design\nclass Character {\npublic:\n\t // Draw the character on the screen. virtual void draw() = 0;\n\t // Make the character move. virtual void move() = 0;\n};\n// The aerial character. class AerialCharacter : public Character {\npublic:\n\t // Draw the character on the screen. virtual void draw() { /* Code to draw the aerial character. */ }\n\t // Make the character fly. virtual void move() { /* Code to make the character fly! */ }\n};\n// The terrestrial character. class TerrestialCharacter : public Character {\npublic:\n\t // Draw the character on the screen. virtual void draw() { /* Code to draw the terrestrial character. */ }\n\t // Make the character run. virtual void move() { /* Code to make the character run! */ }\n};", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 178", "position": 178, "chunk_type": "semantic", "token_estimate": 300}
{"text": "156\u2002 \u2022\u2002 Software Engineering Design\ufeff: Liskov Substitution Principle\nThe OCP from the previous section provides guidance to design extensible systems by \nmaking designs open to extension but closed to modification. In some cases, it can be seen \nthat adhering to the OCP alone does not guarantee correct designs or designs that lead to \nreusability throughout the system. To maintain the integrity of designs that adhere to the \nOCP, designs must honor any implied contract between base classes and the components \nthat use them (Pressman 2010). This concept is captured by the LSP, which was originally \nproposed by Barbara Liskov. The LSP serves as basis for creating designs that allow clients \nthat use derived classes to behave just as they would if they used the corresponding base \nclasses (Liskov and Guttag 2000). The LSP requires not only that signatures between base \nand derived classes are maintained but also that the subtype specification supports reason-\ning based on the supertype specification (Liskov and Guttag 2000). Consider the following implementation for a new EntryLevelTerrestrial\u00ad\nCharacter \nin the gaming system. The new entry-level character inherits from the terrestrial character \nclass, which provides the interface method move() and information about the semantics \nof the operation through pre- and postcondition specification, as presented in Listing 5.9. As seen, EntryLevelTerrestrialCharacter implements the move method to \nmake terrestrial characters fly, therefore providing a design that can adhere to the OCP but \nthat violates the LSP, since the semantics of the TerrestrialCharacter are not main-\ntained. Anywhere in the design where objects of type TerrestrialCharacter are \ncalled upon to move, the postconditions defined for this type specify that terrestrial char-\nacters will walk or run. Upon extending this design with its entry-level subtype, characters \nTerrestrialCharacter\nAdheres to OCP\nViolates OCP\nGameEngine\n<<interface>>\nCharacter\n+draw(): void\n+run(): void\n+draw(): void\n+move(): void\n+add(pCharacter : TerrestrialCharacter*): void\nGameEngine\nAerialCharacter\n+add(pCharacter : Character*): void\n+draw(): void\n+move(): void\nTerrestrialCharacter\n+draw(): void\n+move(): void\nAquaticCharacter\n+draw(): void\n+move(): void\nFIGURE 5.3\nUML class diagrams for the OCP examples of the gaming system\u2019s design.", "domains": ["Design Principles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 180", "position": 180, "chunk_type": "semantic", "token_estimate": 340}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 157: no longer walk but fly. When designing systems that adhere to the LSP, subtypes must \nconform both syntactically and semantically to their base types, so they can be replaceable \nat run time throughout the software execution. Interface Segregation Principle\nWell-designed classes should have one (and only one) reason to change. When this concept \nis violated, there is a strong indication that the interfaces provided by these classes are pro-\nviding more information than they should, which makes designs harder to maintain and \nreuse. The SIP states that \u201cclients should not be forced to depend on methods that they do \nnot use\u201d (Marin 2003). As example, consider incorporating into the gaming system a set of \ndifferent types of enemy characters, each with specific capabilities for moving over land, \nunder water, or over the air. In addition, a fourth type of enemy character is added to the \nsystem, which incorporates moving capabilities from all other enemy characters into the \n\u00ad\nsystem (e.g.,\u00a0run, swim, and fly). To allow characters to be interchangeable at run time, these \ncharacters are designed initially with a common EnemyCharacter base class, as seen in \nsm : ScheduleManager\ns : Schedule\nHeatSensor : Sensor\nVibrationSensor : Sensor\n2 : getMsg()\n1 : timer expires\n4 : msgId = interpretMsg()\n[msgId == HEAT_MSG_ID]\nalt\n[msgId == VIBRATE_MSG_ID]\n<<return>>\n5 : activate()\n6 : activate()\nsd Activate Sensors\nFIGURE 5.4\nSequence diagram during detailed design.", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 181", "position": 181, "chunk_type": "semantic", "token_estimate": 241}
{"text": "158\u2002 \u2022\u2002 Software Engineering Design\ufeff: the top part of Figure\u00a05.5. Notice that since the SuperCharacter class requires behavior \nfrom all other enemy characters, the EnemyCharacter base class is designed to con-\ntain the implementations for all enemy characters in the system. This way, through inheri-\ntance, the SuperCharacter can reuse all behaviors. What is wrong with this design? For starters\u00ad\n, the design violates the LSP, since only the SuperCharacter conforms both \nsyntactically and semantically to the base type. However, of more interest is the fact that \nthe interface for all other characters in the system has now been polluted with unnecessary \nmethods. As enemy characters and capabilities continue to increase, so will the complexity \nof the EnemyCharacter interface, which in turn passes this complexity on to its derived \ntypes. Designs such as this, where clients or subtypes are forced to depend and maintain \nmethods that they do not use, leads to designs that are hard to reuse and maintain. The SIP implies that many client-specific interfaces are better than one general purpose \ninterface. For example, consider the redesign presented in the lower part of Figure\u00a05.5. As \n+\ufb02y(): void\n+run(): void\n+swin(): void\nAerialCharacterClient\nTerrestrialCharacterClient\nAquaticCharacterClient\nAerialCharacter\nTerrestrialCharacter\nEnemyCharacter\n+\ufb02y(): void\n+run(): void\n+swim(): void\n<<interface>>\nSuperCharacter\nSuperCharacterClient\n+\ufb02y(): void\n+run(): void\n+swim(): void\nAquaticCharacter\nSuperCharacter\nViolates ISP\nAdheres to ISP\n<<interface>>\nAerialCharacter\n<<interface>>\nTerrestrialCharacter\n<<interface>>\nAquaticCharacter\nFIGURE 5.5\nThe interface segregation principle for the enemy character design.", "domains": ["Design Principles", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 182", "position": 182, "chunk_type": "semantic", "token_estimate": 240}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 159: seen, the bloated EnemyCharacter interface has been dissolved and many client-specific \ninterfaces have been created. These interfaces are easier to maintain and reuse and lead to \neasier adherence to both OCP and LSP. Programming Styles in Detailed Design\nDuring detailed design, styles are used to provide a consistent approach for structuring code \nby specifying a standard for code elements, such as code formatting, naming conventions, \ndocumentation, and many other programming language-specific conventions. The appli-\ncation of styles is typically an activity that is emphasized during construction; \u00ad\nhowever, \ndue to the capabilities of today\u2019s modeling tools the application of styles is prevalent during \nthe detailed design phase. For example, when modeling tools are used in software proj-\nects, the detailed design activity is where, for example, classes, variables, functions, func-\ntion parameters, and return types are specified. When modeling tools are used to generate \ncode, other construction styles such as formatting styles (e.g., spaces, bracket positioning) \ncan also be specified. In all of these cases, styles are used to specify the way these elements \nappear in code in such way that it is consistent, readable, and therefore more maintainable. Programming styles provide the means for ensuring consistency in code when designs are \ntransformed to code by different engineers. Listing 5.9: C++ Implementation for EntryLevelTerrestrialCharacter\nclass TerrestrialCharacter : public Character {\n\t // Pre-Condition: Character is drawn on screen. // Post-Condition: Character roams around randomly over land, either\n\t // walking or running. virtual void move() {\n\t \t //code to make the character walk or run.\n\t } // code here to implement all other interfaces. };\nclass EntryLevelTerrestrialCharacter : public TerrestrialCharacter {\npublic:\n\t // Override move to make the character fly! virtual void move() {\n\t \t // code to make the character fly.\n\t } // Code here to implement all other interfaces. };", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 183", "position": 183, "chunk_type": "semantic", "token_estimate": 304}
{"text": "160\u2002 \u2022\u2002 Software Engineering Design\ufeff: Since programming styles are mostly programming language-specific, styles for one \nparticular programming language may not apply to another programming language. However, some styles can be applied in a general fashion to a wide variety of modern pro-\ngramming languages, in particular those that share similar language characteristics, such \nas C++, Java, and C#. When creating detailed designs, the focus of programming styles can \nbe placed on the following:\n\u2022\t Type names\n\u2022\t Function names\n\u2022\t Variable names\nType names are names selected for defining types in a programming language. Examples \ninclude classes, interfaces, structs, and enumeration. Type names are commonly specified \nusing nouns and the PascalCase style. Type names that refer to collections can be pluralized \nto explicitly convey this information. Styles for interface names vary from most other type \nnames. Popular styles for interface names include the use of nouns, adjectives, the \u00ad\nletter \u201cI\u201d \nbefore the interface name, and a combination of all of these. Both the Java \u00ad\nlanguage and C# \nuse nouns and adjectives when specifying interface names. In addition, the C# language \nemploys the style of applying \u201cI\u201d before interface names. For custom-defined interfaces, \nVermeulen, Ambler, Bumgardner, Metz, Misfeldt, Shur et al. (2000) recommend using \nnouns for interfaces that act as service declarations (e.g., Java\u2019s ActionListener) and adjec-\ntives for interfaces that act as description of capabilities (e.g., Java\u2019s Runnable). Examples of \ntype name conventions are presented in\u00a0Listing 5.10. Function Names\nWhereas type names typically use the PascalCase style in the naming convention, func-\ntion names vary significantly between PascalCase and lowerCamelCase styles. Naming \nconventions for function names also vary among the software engineering community, \nwith camps strongly supporting each side. This is largely due to the way in which differ-\nent programming languages use styles for function names. For example, it is not uncom-\nmon for C++ programmers to support lowerCamelCase style, since every function name \nin the standard template library uses this style. The same is true about Java programmers. However, the C# programming language employs the PascalCase style for function names; \ntherefore, programmers coming from Java or C++ background may tend to disagree with \nthe C# convention. Consider, for example, the function calls for displaying text to the con-\nsole in both Java and C#, as seen in Listing 5.11. Notice how pintnln and WriteLine use different styles built into the Java and .NET \nframeworks, respectively.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 184", "position": 184, "chunk_type": "semantic", "token_estimate": 400}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 161: accurately to the main intention of the function and its return type. Function names \nthat accurately describe the function\u2019s intent can be referred as action-conforming func-\ntions. Alternatively, function names that do not are referred as action-contradictive; \nthese are function names that do not accurately relate to the function\u2019s main intent. Examples of action-contradictive and action-conforming function names are presented \nin Listing\u00a05.12. Listing 5.10: Example of Type Name Conventions\n// Class name for a single node. class MobileNode {\n};\n// Class name for a collection of nodes, therefore name is \npluralized. class MobileNodes {\n\t public:\n\t \t void addNode( int nodeId );\n\t \t void removeNode( int nodeId );\n\t \t MobileNode* getNode( int nodeId );\n};\n// Another example of a collection name in C++. list<MobileNode*> mobileNodes;\n// Custom-defined interface name in Java. interface SampleInterface {\n}\n// Custom-defined interface name in C#. interface ISampleInterface {\n}\n// Built-in interface name in Java\njava.util.Observable\n// Built-in interface name in C#\nSystem.ICloneable;\nListing 5.11: Example of Both PascalCase and \nlowerCamelCase for Function Names\n// Displaying text to the console in Java. System.out.println(\u201cconsole message...\u201d);\n// Displaying text to the console in C#. System.Console.WriteLine(\u201cconsole message...\u201d);", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 185", "position": 185, "chunk_type": "semantic", "token_estimate": 195}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 165: In\u00a0addition, Listing 5.15 presents a common style for identifying member variables, such \nas the\u00a0_message variable. Identifying member variables can improve readability of code \nwhere function parameters use the same name as member variables. In such cases, a pre-\nfix or suffix can be used to clearly identify the member variable, especially in large mem-\nber functions. Modeling Internal Behavior of Components\nModeling interactions among entities designed during component design provides an \nefficient approach for visualizing complex interactions required for achieving a particu-\nlar system function. This helps verify the component designs before construction begins. Sequence or communication diagrams can be employed to model objects representing \ninstances of classes, or roles representing prototypical instances of other entities, such as \nclasses (Booch, Rumbaugh, and Jacobson 2005). Both objects and roles can be connected \nto model the exchange of messages using links or connectors, respectively, to carry out a \nparticular function of the design, typically as part of the system\u2019s functional requirements. During detailed designs, the majority of behavioral models include objects, since analyses \nare made with detailed information that is already been designed. In many cases, class dia-\ngrams are accompanied by one or more behavioral diagrams to provide a complete picture \nof the detailed design; both of these are reviewed and documented as part of the software \ndesign document. An example of a detailed sequence diagram is presented in Figure\u00a05.5. The sequence diagram from Figure\u00a0 5.5 presents the behavioral modeling of objects \nbelonging to three classes, namely, the ScheduleManager, Schedule, and Sensor classes. The \nsequence diagram\u2014identified by the sd keyword and name Activate Sensors\u2014uses the \nFrame notation, which provides the means to model combined fragments of interactions \nthroughout sequence diagrams. Each interaction frame inside the sequence diagram can \nbe classified using the operators presented in Table\u00a05.3 (UML 2.3 Superstructure 2010). The alt operator is used to denote a conditional statement, where more than one case \nis examined. The opt operator is employed when a single optional fragment exists in a \nsequence. When this occurs, the operations inside the fragment are either executed or \nnot. This differs from the alt operator, which includes additional conditional statements. The loop operator specifies a repetition structure.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 189", "position": 189, "chunk_type": "semantic", "token_estimate": 371}
{"text": "166\u2002 \u2022\u2002 Software Engineering Design\ufeff: \u00ad\nfollows: loop (min, max), where min specifies the minimum bound of the loop and \nmax represents the maximum bound of the loop. When these are omitted, then it implies \nthat min = 0 and max = infinity. In these cases, the loop typically includes a separate inter-\naction constraint, called a Guard, which evaluates to true or false. The loop will continue \nonly if the guard evaluates to true during execution regardless of the minimum number \nof iterations specified in the loop. The Guard interaction constraint is in the format of \n[<<constraint>>]. Guards can also be used in other interactions throughout sequence dia-\ngrams. For example, in Figure\u00a05.5, a Guard is used to explicitly specify the condition used \nto determine alternate paths in the alt combined fragment. Design Components Using Design Patterns\nIn Chapters 3 and 4, the concept of patterns was introduced with an emphasis on software \narchitecture. During detailed design, a wide variety of design patterns exists for providing \nsolutions to recurring problems in the form of structural designs for components. Design \npatterns are recurring solutions to object-oriented design problems in a particular context. When used effectively, they can help improve efficiency in the detailed design effort by pro-\nviding high-quality reusable solutions that can be applied in many practical applications. To properly and consistently capture design patterns, detailed descriptions are required to \nidentify the patterns, the problem that they solve, and their solution approach. Designing high-quality object-oriented software is hard. Typically, designers of systems \nthat evolve gracefully have time to develop their skills through years of experience. This \nexperience gives designers the ability to identify classes with the right granularity, appro-\npriate relationships among the classes, and inheritance hierarchies that are reusable\u00ad\n and \nmaintainable. Experience also allows designers to evaluate the effects of their design deci-\nsion in the overall development of a working software system. The more we experience \nthe design of systems, the more knowledge and skill we acquire to design better systems. Unfortunately, for novice designers, this experience can take years to acquire. Because \ndetailed design entails a great deal of problem-solving skills, novice designers can spend \nmuch time trying to determine how to efficiently structure their designs in a way that the \nsystem can exhibit a certain level of quality.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 190", "position": 190, "chunk_type": "semantic", "token_estimate": 384}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 167: up to speed quicker in these environments and enable them to quickly apply them to par-\nticular problems. In the work reported by Walter Tichy (2010), strong empirical evidence \nsuggested that merely documenting design patterns can already lead to an increase in pro-\ngrammer productivity and reduce errors during maintenance tasks. Design patterns also \nhelp enhance communication during the problem-solving process by providing \u00ad\nabstractions \nof problem-solving techniques. Tichy\u2019s work also shows evidence of improvements in \n\u00ad\ncommunication when team members shared design patterns knowledge. In his work, it was \nnoticed that weaker designers catch up with more experienced ones when using patterns. Design patterns also serve as starting point for the design (or redesign) effort of software \ncomponents; therefore, they help reduce the time to design new systems. Finally, design \n\u00ad\npatterns provide examples of the application of many object-oriented design principles; \ntherefore, they can serve as practical methods for learning object-oriented design techniques. Architectural versus Design Pattern\nBefore diving deeply into the topic of design patterns in the next chapters, it is impor-\ntant to make a clear distinction between (detailed) design patterns\u2014the topic of the next \ntwo chapters\u2014and architectural (design) patterns, which were covered in Chapter\u00a0 4. As\u00a0mentioned\u00ad\n in Chapters 3 and 4, architectural patterns serve mostly at higher levels \nof abstraction to identify the major components and interfaces of the software system. Therefore, their application is too abstract to be translated directly to code. In contrast, \ndesign patterns are detailed solutions to particular problems that can be directly trans-\nlated to code. Architectural patterns have a direct effect on the architecture of a software \nsystem and are associated to particular application domains (e.g., interactive systems), \nwhereas design patterns are independent of a particular application domain (Buschmann \net al.\u00a01996). These differences should become evident in Chapters 6 and 7. Classification of Design Patterns\nWhen first studying design patterns, it is important to understand what each pattern \ndoes and how it does it. In the influential work presented by Gamma, Helm, Johnson, \nand Vlissides (1995), design patterns are classified based on purpose and scope. The pur-\npose of a design pattern identifies the functional essence of the pattern; therefore, it serves \nas fundamental differentiation criteria between design patterns. Three different purposes \nare identified by the Gang of Four (GoF), including creational, structural, and behavioral.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 191", "position": 191, "chunk_type": "semantic", "token_estimate": 394}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 167: The pur-\npose of a design pattern identifies the functional essence of the pattern; therefore, it serves \nas fundamental differentiation criteria between design patterns. Three different purposes \nare identified by the Gang of Four (GoF), including creational, structural, and behavioral. Creational design patterns are the ones that attempt to efficiently manage the creation \nor creational process of objects in a software system. A common characteristic of cre-\national pattern is the presence of creational classes and product classes. In some cases, \nthe creational and product classes are combined into one class. Creational patterns are \noverall known for abstracting the instantiation process of one or more objects. Structural \ndesign patterns are the ones that attempt to create larger structures from the composition \nof existing classes, objects, or other structures. Finally, behavioral design patterns are con-\ncerned with how classes and object interact, the variation of behavior, and the assignment", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 191", "position": 191, "chunk_type": "semantic", "token_estimate": 154}
{"text": "168\u2002 \u2022\u2002 Software Engineering Design\ufeff: of responsibility between objects. The purpose criteria apply to a large number of patterns; \ntherefore, it serves well for classifying a large variety of design solutions. While the purpose criteria of design patterns captures the overview of what the pattern \ndoes, the scope of a design pattern captures whether the design pattern primarily applies \nto classes or objects. Class patterns apply primarily to classes by defining the relationship \nbetween classes and subclasses, at compile time, via inheritance. Object patterns apply \nprimarily to objects by defining the pattern\u2019s relationship between objects, at run time, \nvia object composition. Since the relationships in object patterns are defined via object \ncomposition, they result in more dynamic designs and flexible designs. Since the large \nmajority of design patterns rely on inheritance, it can be difficult to draw the line to dif-\nferentiate between class patterns and object patterns. Furthermore, some design patterns \ncan be applied in different ways, so that the same pattern can be classified as class \u00ad\npattern \nor object pattern, depending on the design implementation. Typically, the distinction \nbetween class patterns and object patterns becomes clearer after having experience with \npatterns for some time. When it comes to scope classification, the most efficient differen-\ntiation criteria lies in the focus that the design pattern puts on inheritance versus object \ncomposition. Design patterns that place focus on inheritance as key relationship for the \npattern are \u00ad\nclassified as class patterns, whereas design patterns that place focus on object \ncomposition are classified as object patterns. Purpose and scope can be used in combination to fully classify design patterns. For \nexample, design patterns can be classified as class creational or object creational, class \nstructural or object structural, or class behavioral or object behavioral. In addition to \npurpose, scope, and their combination, many other types of classification and domains \nhave been identified throughout the years. Example of these include design patterns \nin real-time programming (Douglass 2002), patterns in web applications (Vora 2009), \nand patterns for parallel software (Ortega-Arjona 2010). Documenting Design Patterns\nDocumenting design patterns in a consistent format is important to the dissemination of \npattern knowledge. Although design patterns can be documented in many ways, the GoF \nidentified 13 categories that can be used as standard for fully documenting design pat-\nterns. Together, these categories provide detailed information of existing design patterns \nand provide direction for documenting future patterns.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 192", "position": 192, "chunk_type": "semantic", "token_estimate": 399}
{"text": "Documentation of a project\u2019s software design is captured in the software design docu-: The body section of the SDD contains architectural and \ndetailed design elements, presented in a format specified by design viewpoints. Design \nviewpoints dictate the way design views are presented within an SDD, and each design \nview has exactly one design viewpoint to go along with it. The IEEE (2009) recommends \neach design viewpoint specification to contain (among others) the following information:\nTABLE\u00a05.4\nCategories and Descriptions for Documenting Design Patterns\nCategory\nDescription\nName and classification\nThe unique pattern name that reflects the essence of the patterns and its classification\nIntent\nDescribes the purpose of the pattern in such way that it is clear what types of design \nproblems the pattern solves, what the pattern does, its rationale and intent\nAlso Known As\nA list of alternate well-known names for the pattern\nMotivation\nAn example scenario that serves as motivation for the application of the pattern\nApplicability\nDescribes the situations, or design problems, that lend themselves for the \napplication of the design pattern; provides examples of poor designs that can \nbenefit from the pattern and ways for identifying these situations\nStructure\nProvides a structural (e.g., UML class diagram) view of the design pattern\nParticipants\nList the classes and objects required in the design pattern and their responsibilities\nCollaborations\nProvides information about how the participants work together to carry out \ntheir\u00a0responsibilities\nConsequences\nDescribes the effects of the design pattern, good or bad, on the software solution\nImplementation\nProvides information and techniques for successfully implementing the design pattern\nSample Code\nProvides sample code that demonstrates how to implement the design pattern in \ndifferent programming languages\nKnown Uses\nProvides examples of real systems that employ the design pattern\nRelated Patterns\nProvides information about other design patterns that are related or that can be \nused in combination with the design pattern", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 193", "position": 193, "chunk_type": "semantic", "token_estimate": 310}
{"text": "170\u2002 \u2022\u2002 Software Engineering Design\ufeff: \u2022\t Viewpoint name\n\u2022\t Relevant design concerns\n\u2022\t Design elements (e.g., elements of design language)\n\u2022\t Analytical methods or other operations for supporting the view\n\u2022\t Viewpoint authorship or citation\n\u2022\t Patterns, heuristics, or other guidelines used in the creation of the viewpoint\nThe specification of design viewpoints can be done fully in the SDD or incorporated \nby reference (IEEE 2009). Once specified, viewpoints can be used throughout the SDD \nto document software designs. The SDD should also present the rationale for selecting \nthe specific design viewpoint. Long after the design phase is complete, the SDD will be \nreferred to several times during the software life cycle. Therefore, it is useful if the rationale \nfor making certain design decisions is included in the SDD so developers can gain addi-\ntional insight into why decisions were made for certain parts of the software design. Design \nrationale includes justification for choosing a particular design approach and can be found \nin commentary throughout the SDD. Examples of design rationale include design issues \nraised in response to design concerns of stakeholders, trade-offs evaluated, criteria used \nto make decisions, and design options considered (IEEE 2009). With this information, \na\u00a0sample table of contents for the SDD is provided in Table\u00a05.6. TABLE\u00a05.5\nSections of the Software Design Document\nSection\nDescription\nDate of issue and status\nDate of issue is the day on which the SDD has been formally released. Every time \nthe SDD is updated and formally released, there should be a new date of issue. Scope\nScope provides a high-level overview of the intended purpose of the software. It\u00a0sets a limit as to what the SDD will describe and defines the objectives of \nthe\u00a0software. Issuing organization\nIssuing organization is the company that produced the SDD. Authorship\nAuthorship pertains to who wrote the SDD and certain copyright information. References\nReferences provide a list of all applicable documents that are referred to within the \nSDD. If there is a certain technology that is used within the design, it is important \nto refer to the corresponding documentation on that technology, so it may be \nreferenced. When reading the referenced documents, stakeholders may uncover \ninconsistencies in how the technology should be used and how it is used in the \nsoftware design. Context\nDescription of the context of the SDD. Body\nBody is the main section of the SDD where the design is documented.", "domains": ["Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 194", "position": 194, "chunk_type": "semantic", "token_estimate": 403}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 171: Interface Control Document\nThe interface control document (ICD) is an important piece of documentation that serves as \na written contract between components of the system software as to how they communicate. This document is usually intended to cover only the software components that are internal \nto the software development effort. Many times in software engineering, there exists a sys-\ntem in which two pieces of software need to communicate to share information or possibly \nto invoke function calls. For developers to write software, they need to know what to expect \nwhen asking for certain data or how to perform a particular action on another piece of soft-\nware. A classic example of this is a client\u2013server based system\u00ad\n. The\u00a0server may contain and \nmanage certain data, or it may provide a set of actions that a client may invoke. An ICD is \nmuch like documentation on how to speak a particular language. If\u00a0two pieces of software \ncannot speak the same language, they will not be able to communicate and a software sys-\ntem will not be able to work. ICDs can also be an important part of communication within \na single component of a software system. For instance, the example in Figure\u00a05.6 has two \nTABLE\u00a05.6\nSample Table of Contents for the Software Design Document\n1. Introduction\n\t\n1.1\t Date of Issue\n\t\n1.2\t Context\n\t\n1.3\t Scope\n\t\n1.4\t Authorship\n\t\n1.5\t Change history\n\t\n1.6\t Summary\n2. Software Architecture\n\t\n2.1\t Overview\n\t\n2.2\t Stakeholders\n\t\n2.3\t System Design Concerns\n\t\n2.4\t Architectural Viewpoint 1\n\t\n\t\n2.4.1\t Design View 1\n\t\n2.5\t Architectural Viewpoint 2\n\t\n\t\n2.5.1\t Design View 2\n\t\n2.6\t Architectural Viewpoint n\n\t\n\t\n2.6.1\t Design View n\n3. Detailed Design\n\t\n3.1\t Overview\n\t\n3.2\t Component Design Viewpoint 1\n\t\n\t\n3.2.1\t Design View 1\n\t\n3.3\t Component Design Viewpoint 2\n\t\n\t\n3.3.1\t Design View 2\n\t\n3.4\t Component Design Viewpoint n\n\t\n\t\n3.4.1\t Design View n\n4. Glossary\n5. References", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 195", "position": 195, "chunk_type": "semantic", "token_estimate": 312}
{"text": "172\u2002 \u2022\u2002 Software Engineering Design\ufeff: different kinds of interfaces. There is one interface between the client and server, and then \nthere are several interfaces that are just internal to the server. The server may be running three different processes, but it could be thought of as one \ncohesive component in the entire software system. These two different kinds of interfaces \ndo not have to use the same kind of technology either. The interfaces described in an ICD \ncan be either proprietary, such as a company-developed protocol using Extensible Markup \nLanguage (XML), or something standard such as Simple Network Management Protocol \n(SNMP) or Common Object Request Broker Architecture (CORBA). However, the descrip-\ntions of the data contents or what actions to take will surely be proprietary. To make an \nICD effective, it must describe all the interfaces in as much detail as possible. ICDs can \ndetail, for example, which data item on a server corresponds with what screen element on a \nGUI. Messages can also be formed in an ICD to detail all items coming back from a server \nto a client. It is much of this content that makes the bulk of an ICD. However, other docu-\nments may be referenced so that developers can get a better understanding of the commu-\nnication process. For example, if a system uses SNMP, the ICD may reference the\u00a0Request \nfor Comments (RFCs) related to SNMP. This could further help a reader to understand \ncertain parts of the software as related to communications. Software Version Document\nThe software version description (SVD) is a document containing information about \nwhat is included in a software release, including different files, scripts, and executables. It also contains information about how to build the code, how to set up a computer that \nwill host the software, and the software requirements for the host computer. The SVD is \nalso an important document that tracks what changes have been made between different \nreleases of software. It also details what problems might be encountered with a specific \nrelease of software and what problems have been fixed. Not every release of software is \ngoing to be perfect. Software can sometimes contain unfixed problems that go unidenti-\nfied even after testing. These problems are then often noticed by the end users who report \nthem to the software developers.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 196", "position": 196, "chunk_type": "semantic", "token_estimate": 385}
{"text": "Detailed design synchronicity is concerned with the degree of how well detailed designs: adhere to the software architecture and how well software code adheres to the detailed \ndesign. Detailed designs provide a design structure carefully crafted to ensure desired \ncharacteristics of the software, such as reusability or maintainability. Typically, soft-\nware engineers are good at respecting detailed design decisions early on in a project life \ncycle; however, as the development process continues, detailed designs are more prompt \nto deviations during construction. For any software architecture and detailed design \nto result in a successful system implementation, the construction phase must be syn-\nchronized with the software products resulting from both efforts. Therefore, the engi-\nneering team must ensure that detailed design decisions are enforced throughout the \nconstruction phase. Particular attention needs to be paid to design synchronicity when \nprojects enter the maintenance phase or when new engineers are brought into the project. Similarly to achieving architectural design synchronicity, processes must be in place and \nenforced to ensure that overall design synchronicity is high.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 197", "position": 197, "chunk_type": "semantic", "token_estimate": 172}
{"text": "174\u2002 \u2022\u2002 Software Engineering Design\ufeff: component to the extent that the design is sufficiently complete to be implemented.\u201d That \nis, the process of refining the software architecture to reach a point where construction can \nbegin. It is important to note that most of the detailed design activities deal directly with \naddressing functional requirements of the system. The detailed design process requires \ndesigners to understand the architecture and requirements before creation of detailed \ndesigns. Detailed design decisions can significantly shape the system\u2019s quality properties; \ntherefore, they must exist within the bounds of the software architecture. In some cases, \nwhere modeling tools are used to generate code, detailed designs can also have significant \nimpact on the quality properties of the construction phase. Once created, detailed designs \ncan be documented together with architectural design to form the software design docu-\nment, which is reviewed and approved before construction begins. The design document \nestablishes the general framework of reference for all construction work; therefore, policies \nmust be in place to maintain synchronicity between the design document and construc-\ntion work. Upon completion of the detailed design activity, the system\u2019s design is suffi-\nciently complete so that it can be formally documented, reviewed, and approved by the \nsystem\u2019s stakeholders, which marks the end of the design phase.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 198", "position": 198, "chunk_type": "semantic", "token_estimate": 212}
{"text": "1.\tWhat is detailed design, and how does it differ from architectural design?: 2. Explain the relationship among requirements, architecture, detailed design, and \nconstruction. 3. What key tasks are performed during detailed design? Explain. 4. What steps are involved in the detailed design process? 5. What are derived requirements, and how do they play a role during detailed design? 6. What is the role of software architecture during detailed design? Can detailed \ndesign succeed without architecture? Explain. 7. Explain the concept of interface design during detailed design. 8. In object-oriented systems, what is the difference between a class and an object? 9. What is the difference between concrete and abstract classes? 10. Explain the following concepts:\n\t\na.\t Interfaces\n\t\nb. Types and subtypes\n\t\nc.\t Dynamic binding\n\t\nd.\t Polymorphism\n\t 11. Compare and contrast the OCP, LSP, and ISP. 12. Why are programming styles important during detailed design? Give examples of \nsome styles used during detailed design. 13. Explain the concepts of combined fragments, operators, and guards in interaction \n\u00ad\ndiagrams. Give an example of each. 14. What is the difference between architectural patterns and detailed design patterns?", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 198", "position": 198, "chunk_type": "semantic", "token_estimate": 185}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 175: 15. What are the sections of the software design document? Explain each. 16. What is the interface control document, and why is it necessary in practical develop-\nment efforts? 17. What is the version control document, and how does it relate to the software design?", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 199", "position": 199, "chunk_type": "semantic", "token_estimate": 51}
{"text": "176\u2002 \u2022\u2002 Software Engineering Design\ufeff: Liskov, Barbara, and John Guttag. Program Development in Java: Abstraction, Specification, and Object-Oriented \nDesign. Boston: Addison-Wesley, 2000. Marin, Robert C. Agile Software Development: Principles, Patterns, and Practices. Upper Saddle River, NJ: \nPrentice Hall, 2003. Meyer, Bertrand. Object-Oriented Software Construction, 2d ed. Upper Saddle River, NJ: Prentice Hall, 1997. Ortega-Arjona, Jorge L. Patterns for Parallel Software Design. West Sussex, UK: Wiley, 2010. Pressman, Roger S. Software Engineering: A Practitioner\u2019s Approach, 7th ed. Chicago: McGraw-Hill, 2010. Sommerville, Ian. Software Engineering, 9th ed. Boston: Addison Wesley, 2010. Tichy, Walter. Making Software: What Really Works, and Why We Believe It. Sebastopol, CA: O\u2019Reilly Media, \n2010. \u201cUML 2.3 Superstructure.\u201d Vers. 2.3. Object Management Group. May 2010. Available at: http://www.omg.org\nVermeulen, Allan, Felix Bachmann, Len Bass, David Garlan, James Ivers, Reed Little, Robert Nord, and \nJudith\u00a0Stafford. The Elements of Java Styles. Cambridge, UK: Cambridge University Press, 2000. Vora, Pawan. Web Application Design Patterns. Burlington, MA: Morgan Kaufmann, 2009.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 200", "position": 200, "chunk_type": "semantic", "token_estimate": 158}
{"text": "177: 6\nCreational Design Patterns \nin Detailed Design", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 201", "position": 201, "chunk_type": "semantic", "token_estimate": 8}
{"text": "\u2022\t Understand the importance and role of creational design patterns in: detailed design\n\u2022\t Identify, understand, and model common creational design patterns\n\u2022\t Become proficient in implementing models of creational design patterns\n\u2022\t Understand the benefits of creational patterns when implementing \nsoftware systems", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 201", "position": 201, "chunk_type": "semantic", "token_estimate": 43}
{"text": "During detailed design, software engineers spend a great deal of time devis-: ing component design solutions that fill in the gaps in architectural designs \nand provide the necessary internal design of components and their inter-\nfaces to achieve system functionality. At the detailed design level, common \npatterns in object-oriented designs have emerged that provide detailed \ndesign solutions to problems that recur many times over in different systems\u00ad\n. A\u00a0 particular problem in these systems involves the efficient creation\u00ad\n of \nobjects so that concepts highlighted in previous chapters (i.e.,\u00a0interfaces, \ntypes, dynamic binding, and polymorphism) can be used effectively to \ngenerate reusable and maintainable software. Creational design patterns \nhelp identify problems that deal with creating quality detailed designs \nthat are efficient in the creation of object in the system. They prescribe the \nclasses required for their design solution and interrelationships required \nto support object creation. These patterns allow designers to quickly and", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 201", "position": 201, "chunk_type": "semantic", "token_estimate": 151}
{"text": "178\u2002 \u2022\u2002 Software Engineering Design\ufeff: systematically identify structural layouts of systems (or subsystems) and provide avenues \nfor examining system interactions and quality evaluation within the operational system. This chapter explores several well-established creational design patterns and examines the \nproblems they are designed to address, together with their exhibited quality attributes. Identifying and designing using creational design patterns can improve the efficiency of \nthe development process and the quality of the final system.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 202", "position": 202, "chunk_type": "semantic", "token_estimate": 72}
{"text": "Creational design patterns are patterns for abstracting and controlling the way objects are: created in software applications. They play a key role in the design of systems by making \nthem independent of how objects in the system are created, composed, and represented \n(Gamma, Helm, Johnson, and Vlissides 1995). Therefore, parts of the system responsible \nfor creating (or instantiating) objects do so through a common creational interface without \nknowledge of how the actual object or group of objects are created. In addition, by control-\nling the creational process with a common interface, enforcing creational policies becomes \neasier, therefore giving the system the ability to create product objects that share a com-\nmon interface but vary widely in structure and behavior. Examples of creational patterns \ninclude the abstract factory, factory method, builder, prototype, and singleton.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 202", "position": 202, "chunk_type": "semantic", "token_estimate": 133}
{"text": "The abstract factory is an object creational design pattern intended to manage and encap-: sulate the creation of a set of objects that conceptually belong together and that represent a \nspecific family of products. According to the Gang of Four (Gamma et al. 1995, p. 87), the \nintent of the abstract factory is to\nProvide an interface for creating families of related or dependent objects without specifying \ntheir concrete classes. In the abstract factory pattern, the terms family of products or family of objects are used \nto denote a group of objects that belong together and therefore must be created together. When designing software that uses a group of objects that need to be created and used \ntogether, problems can arise when there is no consistent way for managing the creation \nof these objects. For example, consider two distinct families of computers: one represent-\ning standard computers made up of standard computer parts; and another representing \nadvanced computers made up of advanced computer parts. Assume that the family of \nstandard computers can be composed only of standard computer parts, such as a stan-\ndard monitor, standard keyboard, and standard CPU, and that the family of advanced", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 202", "position": 202, "chunk_type": "semantic", "token_estimate": 196}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 179: computers can consist only of advanced computer parts, such as an advanced monitor, \nadvanced keyboard, and advanced CPU. When left unmanaged, designing software that \ninstantiates both standard and advanced computers can be prone to various problems. First, there is the possibility that advanced computer objects can be created using standard \nproducts or vice versa, that is, standard computer objects created using advanced com-\nputer parts products. Moreover, without a standardized common interface identified for \nthe different computer parts, the code inside the computer classes would be required to \nknow about the correct computer parts type to use; therefore, the addition of new prod-\nucts or new product types would require changing the code inside the computer classes, a \nclear violation of the open\u2013closed principle discussed in Chapter 5. These problems result \nin code that is hard to maintain and reuse. The abstract factory design pattern addresses \nthese problems by encapsulating the creation of these families of products in such a way \nthat they can be interchangeable at run time and by ensuring that products that belong to \na specific group, or family, are instantiated together. Problem\nA computer store needs stand-alone software that keeps track of computer inventory, which \nincludes computers and different computer parts made by different hardware manufactur-\ners. The software for the computer store needs capabilities for displaying information about \ncomputer parts, including information from the manufacturer\u2019s site and various other sites \nthat contain customer satisfaction reviews and other relevant information. Therefore, each \ncomputer part object needs to be capable of extracting information in real time from a list \nof predefined remote locations, of aggregating the information, and of providing this infor-\nmation upon request. Upon requesting the information for a particular computer, all com-\nputer part objects communicate over the network and find out the latest comments and \nstatistics about a component from all predefined sources and make this information avail-\nable to the requesting object. Initially, the store supports only two types of computers: stan-\ndard computers and advanced computers, composed of standard and advanced computer \nparts (i.e., CPU, monitor, and mouse), respectively. Due to store policy, standard computers \ncannot be composed of advanced computer parts and advanced computers cannot be com-\nposed of standard computer parts.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 203", "position": 203, "chunk_type": "semantic", "token_estimate": 380}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 179: Initially, the store supports only two types of computers: stan-\ndard computers and advanced computers, composed of standard and advanced computer \nparts (i.e., CPU, monitor, and mouse), respectively. Due to store policy, standard computers \ncannot be composed of advanced computer parts and advanced computers cannot be com-\nposed of standard computer parts. The software solution needs to provide a maintainable \nand modifiable design for creating these families of objects, to support easy addition of new \nfamilies of computers, and to promote consistency with computer products. Structure\nThe general and applied structure for the abstract factory design pattern is presented in \nFigure\u00a06.1. As seen, the abstract factory is presented in general and applied form, and for \nsimplicity the details of both abstract and concrete computer part classes are omitted \nin the applied form. The general structure of the abstract factory design pattern serves \nas a \u00ad\nblueprint that depicts the participants and relationships required to design abstract \n\u00ad\nfactories; it presents the essence of the pattern, which needs to be fitted for the particular", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 203", "position": 203, "chunk_type": "semantic", "token_estimate": 182}
{"text": "180\u2002 \u2022\u2002 Software Engineering Design\ufeff: problem at hand. The applied view of Figure\u00a06.1 presents an instantiation of the general \nstructure for depicting the solution for the particular computer store problem, which \nconsists of abstract products (e.g., monitor), concrete products (e.g., standard monitor), \nabstract creators (e.g.,\u00a0computer parts factory), and concrete creators (e.g., standard com-\nputer parts factory). These participants are interrelated via realization and association rela-\ntionships. From this example, it should be evident how a new family of computer parts can \nbe added to the design by adding the required pattern classes that make up the new family \nof computers. Implementing the abstract factory design pattern can be confusing because of the num-\nber of classes required. However, when looking closely at the Unified Modeling Language \n(UML) diagram for the application view, it is evident that regardless of the number of \ncomputer factories or computer products, the structural relationship among these classes \n<<interface>>\nAbstractFactory\n<<interface>>\nComputerPartsFactory\n+createProductA()\n+createProductB()\n+createProductA()\n+createProductB()\n<<interface>>\nAbstractProductA\n<<interface>>", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 204", "position": 204, "chunk_type": "semantic", "token_estimate": 165}
{"text": "ConcreteProductA1: ConcreteFactory1\n+createMonitor(): Monitor*\n+createCPU(): CPU*\n+createKeyboard(): Keyboard*\n+createMonitor(): Monitor*\n+createCPU(): CPU*\n+createKeyboard(): Keyboard*\n+createProductA()\n+createProductB()\nConcreteFactory2\nConcreteProductB1\nConcreteProductA2\n<<interface>>\nMonitor\nComputer\n<<interface>>\nKeyboard\nConcreteProductB2\nAdvancedKeyboard\nAdvancedMonitor\nAdvancedCPU\nStandardKeyboard\nStandardMonitor\nStandardCPU\nAdvancedComputerPartsFactory\n+createMonitor(): Monitor*\n+createCPU(): CPU*\n+createKeyboard(): Keyboard*\nStandardComputerPartsFactory\nClient\n<<interface>>\nAbstractProductB\nGeneral View\nApplied View\nFIGURE 6.1\nAbstract factory design pattern.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 204", "position": 204, "chunk_type": "semantic", "token_estimate": 52}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 181: is always the same. This is true for all other patterns studied throughout this and other \nchapters. Therefore, a step-by-step approach can be taken to design abstract factories:\n\t\n1. Design the product interfaces (e.g., CPU, monitor, keyboard). 2. Identify the different families or groups required for the problem (e.g., standard and \nadvanced computers). 3. For each group identified, design concrete products that realize the respective prod-\nuct interface (e.g., standard monitor vs. advanced monitor) identified in Step 1. 4. Create the factory interface (e.g., ComputerPartsFactory). The factory interface \ncontains n interface methods, where n is the number interfaces created in Step 1. 5. For each group identified in Step 2, create concrete factories that realize the factory \ninterface created in Step 4. 6. Create the factory client (e.g., Computer) which is associated with both products \nand factory interfaces created in Steps 1 and 4, respectively. Abstract factory designs contain two fundamental sets of class designs: products and \n\u00ad\nfactories. Once both products and factories portions of the design are complete, dynamic \nbinding can be used at run time to allow the computer client to create different computer \nobjects (e.g., standard vs. advanced computers) and use them throughout programs without \nactually knowing the specific type of the object. This way, adding other computer types to \nthe system can be done by extending the design and not by modifying already working code. Implementation\nWhen studying the abstract factory (and all other design patterns), it is important that \nUML models are translated to code, compiled, and executed. When necessary, it is also \nhelpful to step through the code with a debugger to keep track of dynamic binding \nthroughout the software\u2019s execution. This provides additional insight and helps further \nthe understanding of both concepts and benefits of using a particular design pattern. Once \nthe structural design of the abstract factory is created, its translation to code is straight-\nforward. Listing\u00a06.1 presents the C++ implementation for the ComputerPartsFactory class. As seen, the ComputerPartsFactory abstract class simply defines interface methods \nrequired for creating each computer part designed for the system. Therefore, there is a \none-to-one relationship between interface methods and product interfaces. Since the \ncode for the abstract factory interface is presented in C++, each interface method is \ndefined as pure virtual, which includes the virtual keyword and is set to 0.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 205", "position": 205, "chunk_type": "semantic", "token_estimate": 395}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 181: Therefore, there is a \none-to-one relationship between interface methods and product interfaces. Since the \ncode for the abstract factory interface is presented in C++, each interface method is \ndefined as pure virtual, which includes the virtual keyword and is set to 0. In the \nJava programming language, the ComputerPartsFactory would be defined as a \nJava interface, using the interface keyword. Once the interface for the computer \nparts factory is established, all other concrete factories can be implemented to create \nproducts of specific computer types upon request. Consider the implementation for \ncreating advanced computer parts, where the advanced computer part factory instan-\ntiates advanced computer products. The header file for the advanced computer parts \ncomputer factory is presented in Listing 6.2.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 205", "position": 205, "chunk_type": "semantic", "token_estimate": 128}
{"text": "182\u2002 \u2022\u2002 Software Engineering Design\ufeff: As seen, the AdvancedComputerPartsFactory realizes the ComputerParts-\nFactory interface by inheriting from it and defining concrete methods for each of its \ndefined interface methods. Each interface method is implemented in terms of advanced \ncomputer parts, such that the createMonitor() method returns an instance of \ntype AdvancedMonitor, the createKeyboard() returns an instance of type \nAdvancedKeyboard, and so on. This behavior is presented in the source file for the \nAdvancedComputerParts factory, as presented in Listing 6.3. Listing 6.2: C++ Header File for the Advanced\u00a0Computer Parts Concrete Factory\n// Forward references\nclass Monitor;\nclass Keyboard;\nclass Cpu;\n// Concrete advanced computer parts factory. class AdvancedComputerPartsFactory : public ComputerPartsFactory {\npublic:\n\t // Create and return an advanced monitor. Monitor* createMonitor();\n\t // Create and return an advanced keyboard. Keyboard* createKeyboard();\n\t // Create and return an advanced cpu. Cpu* createCpu();\n};\nListing 6.1: C++ Code for the Computer Parts Factory Interface\n// Computer parts factory interface. class ComputerPartsFactory {\npublic:\n\t // Define the interface to create a monitor object. virtual Monitor* createMonitor(void) = 0;\n\t // Define the interface to create a keyboard object. virtual Keyboard* createKeyboard = 0;\n\t // Define the interface to create a CPU object. virtual Cpu* createCpu = 0;\n};", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 206", "position": 206, "chunk_type": "semantic", "token_estimate": 203}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 183: In Listing 6.3, it is assumed that the concrete products for the advanced computer parts \nfactory have been defined. In fact, before any concrete computer parts factory code can \nbe compiled, its parts need to be defined. Using this pattern, the implementation for the \nstandard computer parts factory is similar to the advanced one, but instead of creating \nadvanced concrete products it implements the creational methods in terms of standard \ncomputer parts products. Listings 6.4 and 6.5 present the generated code for the UML \nmodel of the standard computer parts factory together with its implementation. In a simi-\nlar fashion, the creation of all other required computer parts factories in the system can be \ndesigned and implemented the same way. The final piece of the abstract factory design pattern includes the factory client object. In this example, the client is a computer object that is composed of different computer \npart products. The concept employed in this example is that computers are composed of \ndifferent computer parts; therefore, by configuring computer objects with computer parts \nfactories they can delegate the creation of computer parts to run-time objects mapped \nusing dynamic binding. This allows the creational code for computer objects to be open to \nextension but closed for modification. The header and source code for the Computer class \nare presented in Listings 6.6 and 6.7. Listing 6.3: C++ Source File for the Advanced\u00a0Computer\u00a0Parts Concrete Factory\n#include \u201cAdvancedComputerPartsFactory.h\u201d\n#include \u201cAdvancedMonitor.h\u201d\n#include \u201cAdvancedKeyboard.h\u201d\n#include \u201cAdvancedCpu.h\u201d\n// Create and return an advanced monitor. Monitor* AdvancedComputerPartsFactory::createMonitor() {\n\t // Caller is responsible for cleaning up the memory. return new AdvancedMonitor;\n}\n// Create and return an advanced keyboard. Keyboard* AdvancedComputerPartsFactory::createKeyboard() {\n\t // Caller is responsible for cleaning up the memory. return new AdvancedKeyboard;\n}\n// Create and return an advanced cpu. Cpu* AdvancedComputerPartsFactory::createCpu() {\n\t // Caller is responsible for cleaning up the memory. return new AdvancedCpu;\n}", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 207", "position": 207, "chunk_type": "semantic", "token_estimate": 320}
{"text": "184\u2002 \u2022\u2002 Software Engineering Design\ufeff: Listing 6.4: C++ Header File for the Standard\u00a0Computer\u00a0Parts Concrete Factory\n// Forward references\nclass Monitor;\nclass Keyboard;\nclass Cpu;\n// Concrete standard computer parts factory. class StandardComputerPartsFactory : public ComputerPartsFactory {\npublic:\n\t // Create and return a standard monitor. Monitor* createMonitor();\n\t // Create and return a standard keyboard. Keyboard* createKeyboard();\n\t // Create and return a standard CPU. Cpu* createCpu();\n};\nListing 6.5: C++ Source File for the Standard Computer Parts Concrete Factory\n#include \u201cStandardComputerPartsFactory.h\u201d\n#include \u201cStandardMonitor.h\u201d\n#include \u201cStandardKeyboard.h\u201d\n#include \u201cStandardCpu.h\u201d\n// Create and return a standard monitor. Monitor* StandardComputerPartsFactory::createMonitor() {\n\t // Caller is responsible for cleaning up the memory. return new StandardMonitor;\n}\n// Create and return a standard keyboard. Keyboard* StandardComputerPartsFactory::createKeyboard() {\n\t // Caller is responsible for cleaning up the memory. return new StandardKeyboard;\n}\n// Create and return a standard CPU. Cpu* StandardComputerPartsFactory::createCpu() {\n\t // Caller is responsible for cleaning up the memory. return new StandardCpu;\n}", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 208", "position": 208, "chunk_type": "semantic", "token_estimate": 156}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 185: The key concept presented in Listing 6.6 is the reliance of the Computer class on four \ninterfaces, namely, the ComputerPartsFactory, Monitor, Cpu, and Keyboard \ninterfaces. This highlights a desirable attribute of component designs, which is to rely \non interfaces instead of on concrete implementations. Together, these interface refer-\nences (i.e., pointers) will hold the addresses of run-time objects that adhere to the par-\nticular interface. Therefore, upon creation, objects of the computer type will use these \ninterface references to save the addresses of concrete products created by a particular \ncomputer parts factory object. The implementation code for this behavior is presented \nin Listing 6.7. Once a concrete factory is passed into the constructor of the Computer class, the respon-\nsibility for creating each product is delegated to the factory object. This way, a Computer \nobject can be created the same way for all computer types, simply by changing the factory \nListing 6.6: C++ Header File for the Computer Client\n// Forward references. class ComputerPartsFactory;\nclass Monitor;\nclass Cpu;\nclass Keyboard;\nclass Computer {\npublic:\n\t // Constructor parameterized with a computer parts factory. Computer(ComputerPartsFactory* computerPartsFactory);\n\t // Display detailed information about the monitor. void displayMonitorInfo();\n\t // Display detailed information about the CPU. void displayCpuInfo();\n\t // Display detailed information about the keyboard. void displayKeyboardInfo();\n\t // Display computer cost. void displayCost();\n\t // All other computer methods. // Destructor needs to clean up memory. private:\n\t Monitor* _monitor; // Pointer to the monitor interface. Cpu* _cpu; // Pointer to the Cpu interface. Keyboard* _keyboard; // Pointer to the Keyboard interface. };", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 209", "position": 209, "chunk_type": "semantic", "token_estimate": 263}
{"text": "186\u2002 \u2022\u2002 Software Engineering Design\ufeff: Listing 6.7: C++ Source File for the Computer Client\n#include \u201cComputer.h\u201d\n#include \u201cComputerPartsFactory.h\u201d\n#include \u201cMonitor.h\u201d\n#include \u201cCpu.h\u201d\n#include \u201cKeyboard.h\u201d\n// Constructor\nComputer::Computer(ComputerPartsFactory* computerPartsFactory) {\n\t // Delegate the creation of the monitor object to the Factory. _monitor = computerPartsFactory->createMonitor();\n\t // Delegate the creation of the keyboard object to the Factory. _keyboard = computerPartsFactory->createKeyboard();\n\t // Delegate the creation of the Cpu object to the Factory. _cpu = computerPartsFactory->createCpu();\n}\n// Display detailed information about the monitor. void Computer::displayMonitorInfo() {\n\t // Display monitor\u2019s info. _monitor->displayInformation();\n}\n// Display detailed information about the CPU. void Computer::displayCpuInfo() {\n\t // Display Cpu\u2019s info. _cpu->displayInformation();\n}\n// Display detailed information about the keyboard. void Computer::displayKeyboardInfo() {\n\t // Display keyboard\u2019s info. _keyboard->displayInformation();\n}\n// Display computer cost. void Computer::displayCost() {\n\t // Use all computer products to compute total cost and display it.\n}", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 210", "position": 210, "chunk_type": "semantic", "token_estimate": 140}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 187: that creates the products. Consider the code the computer store software that provides \nand manages inventory information using the ComputerStore class. Using the abstract \nfactory design pattern, the implementation code for displaying computer information is \npresented in Listing\u00a06.8. As seen, the display computer method is passed in a string to \ndetermine the type of computer to be displayed. Once the type is identified, the appropri-\nate computer parts factory object is instantiated and passed into the constructor of the \ncomputer object. From this point forward, all operations called on the computer object are \nimplemented in terms of the factory used to create its parts. Similarly, many different com-\nputer types can be supported by creating additional factories to parameterize computer \nobjects with newly supported computer types. Listing 6.8: C++ Implementation of the Computer Store\n// Assume that the ComputerStore class has been defined and contains\n// the method displayComputer and the member attributes used below. // Method to display a computer\u2019s information. void ComputerStore::displayComputer(string type) {\n\t // Determine which computer needs to be created. if( type.compare(\u201cstandard\u201d) == 0 ) {\n\t \t // Create the standard computer factory object. computerPartsFactory = new StandardComputerPartsFactory;\n\t }\n\t else {\n\t \t // Create the advanced computer factory object. computerPartsFactory = new AdvancedComputerPartsFactory;\n\t }\n\t // Create the computer object using the appropriate factory. _computer = new Computer(computerPartsFactory);\n\t // Display the computer information, including its cost. This\n\t // information varies according to the factory object used to create\n\t // the computer. _computer->displayMonitorInfo();\n\t _computer->displayCpuInfo();\n\t _computer->displayKeyboardInfo();\n\t _computer->displayCost();\n\t // Do more stuff with the computer object here. // Clean up the all memory allocated when done.\n}", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 211", "position": 211, "chunk_type": "semantic", "token_estimate": 274}
{"text": "188\u2002 \u2022\u2002 Software Engineering Design\ufeff: When applying the abstract factory design pattern, depending on the problem, a large \nnumber of classes may be required, causing confusion to those who are new to the pattern. However, it is important to keep in mind that the core classes and relationships identified in \nthe general structure of the pattern remain the same, regardless of the problem. That is, an \nabstract factory has one or more factory objects defined by an abstract factory interface and \none or more products defined by one or more product interfaces. Benefits\n\u2022\t Isolates concrete product classes so that reusing them becomes easier\n\u2022\t Promotes consistency within specific product families\n\u2022\t Adding new families of products, which requires no modification of existing code\nSkill Development 6.1: Abstract Factory Design Pattern\nUsing the UML tool of choice, replicate the UML model presented in Figure\u00a06.1 and \ngenerate code from the model. Using the Integrated Development Environment (IDE) \nof choice, fill in the gaps in the code generated using Listings 6.1 through 6.8 and com-\npile and execute the software. Once the software executes, go back to the UML model \nand add a third factory\u00ad\n, named SpecialComputerFactory, together with special \ncomputer products (e.g.,\u00a0SpecialMonitor, SpecialKeyboard, SpecialCpu). Repeat the code generation process, fill in the gaps of the new generated code, compile, \nand execute. When complete, explain the steps required to make this new modification \nand how the abstract factory design pattern made this change easy or hard.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 212", "position": 212, "chunk_type": "semantic", "token_estimate": 247}
{"text": "The factory method design pattern is a class creational pattern used to encapsulate and: defer object instantiation to derived classes. Structurally, the factory method can be mod-\neled as a simplified version of the abstract factory design pattern, since both patterns \nrequire \u00ad\ncreator and product interfaces. However, unlike the abstract factory design pat-\ntern, in which the creator objects (i.e., factories) are responsible for instantiating a plural-\nity of products that belong to a specific family type, creator objects in the factory method \ndesign pattern are responsible for the creation of a single product of specific type. Therefore, \nthe creator interface for the factory method design pattern provides only one creational \nmethod, whereas the creator interface for the abstract factory design pattern provides two \nor more creational methods. In addition, unlike the abstract factory design pattern, the \nfactory method design pattern defers object creation to subtypes that realize the creational \ninterface; a relationship specified by inheritance, therefore, the factory method design pat-\ntern is classified as a class creational design pattern as opposed to an object creational", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 212", "position": 212, "chunk_type": "semantic", "token_estimate": 178}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 189: design pattern. These fundamental differences are essential for understanding the differ-\nence between both \u00ad\npatterns. According to the Gang of Four (Gamma et al. 1995, p. 107), \nthe intent of the factory method is to\nDefine an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. The factory method design pattern provides the ability for designers to model and imple-\nment code in terms of the factory method and product interfaces. The factory method \ndesign pattern is mainly characterized by one creational method, which is used to instan-\ntiate and return objects of a specified product interface. This creational method is made \nabstract at the factory base class so that objects of the factory base class cannot be directly \ninstantiated. This is done to create a framework that allows the factory base class to define \na series of operations that rely on the product interface; however, before executing opera-\ntions, object creation is delegated to derived classes that are required to implement the \nfactory (creational) method. This way, new derived factories can override the method to \ninstantiate and return the appropriate product for the particular situation that is then used \nto carry out the operations specified in the factory base class. This way, through inheri-\ntance, new factories can be added to the design of the system to extend the factory base \nclass without modifying its code. With the factory method in place, reasoning about appli-\ncation logic can be made in terms of the product interface and not on concrete products, \ntherefore resulting in code that can be extended easily. Problem\nThe computer store from the previous example has expanded its operations to have three \ndifferent stores at different locations. Because of demographics at each location, particu-\nlar types of computers are offered at specific locations. The computer store in Location 1 \n\u00ad\nsupports standard computers only, the computer store at Location 2 supports advanced \ncomputers, and the computer store at Location 3 supports a new type of special computer. The software system is now required to display information about computers carried at \nspecific stores. Therefore, the software design requires modification so that the display of \ncomputer information is site-specific.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 213", "position": 213, "chunk_type": "semantic", "token_estimate": 383}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 189: The software system is now required to display information about computers carried at \nspecific stores. Therefore, the software design requires modification so that the display of \ncomputer information is site-specific. A desired feature for the redesigned software is the \nability to keep the logic code separate from specific types of computer stores so that future \nstores, carrying different computers, can be added to the system with minimal effort. Structure\nThe generic and applied structure of the factory method design pattern is presented in \nFigure\u00a06.2. As seen, the pattern requires both creational and product classes, similar to \nthe abstract factory design pattern. However, unlike the abstract factory design pattern, \ncreator classes in the factory method design pattern require only one creational interface", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 213", "position": 213, "chunk_type": "semantic", "token_estimate": 130}
{"text": "190\u2002 \u2022\u2002 Software Engineering Design\ufeff: method for creating products that share the same interface. Therefore, for each product in \nthe system, the design incorporates concrete product and concrete creator classes. A step-by-step approach to designing the factory method design patterns includes \nthe\u00a0following:\n\t\n1. Identify and design the product interface (e.g., computer). 2. Identify and design the concrete products that realize the interface from Step 1 \n(e.g.,\u00a0StandardComputer, AdvancedComputer). +createProduct()\n+someOperator()\nCreator\n+createComputer(type: string): Computer*\n+displayComputer(type: string): void\nComputerStore\nStandardComputerStore\n+createComputer(type: string): Computer*\nAdvancedComputerStore\n+createComputer(type: string): Computer*\n+displayMonitorInfo(): void\n+displayCpuInfo(): void\n+displayKeyboardInfo(): void\n+displayCost(): void\n+createProduct()\nConcreteCreator\n+productOperation1()\n+createOperation2()\n<interface>>\nProduct\nGeneral View\nApplied View\n<<interface>>\nComputer\n+displayMonitorInfo(): void\n+displayCpuInfo(): void\n+displayKeyboardInfo(): void\n+displayCost(): void\nStandardComputer\n+displayMonitorInfo(): void\n+displayCpuInfo(): void\n+displayKeyboardInfo(): void\n+displayCost(): void\nAdvancedComputer\n+displayMonitorInfo(): void\n+displayCpuInfo(): void\n+displayKeyboardInfo(): void\n+displayCost(): void\nNullComputer\n+productOperation1()\n+productOperation2()\nConcreteProduct\nFIGURE 6.2\nUML class diagram for the factory method design pattern.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 214", "position": 214, "chunk_type": "semantic", "token_estimate": 148}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 191: 3. Design the factory base class (e.g., ComputerStore), which contains one abstract \nfactory\u00ad\n interface method for delegating product creation to derived classes. Product \ncreation must conform to the interface defined in Step 1. 4. Design one or more concrete factories for each product identified in Step 2. As seen in the applied version, a standard computer store capable of displaying computer \ninformation is added to the design. Displaying computer information is performed with \nthe displayComputer() method that performs operations and requests services using the \ncomputer interface. Two creator classes have been added to the design: one for the standard \ncomputer store and another for the advanced computer store. As seen, each computer store \nis associated with the specific product that it supports. In addition, a NullComputer class is \nadded to ensure that computer stores do not return null pointers to clients in the case that \na requested computer is not supported by a particular computer store. Implementation\nOnce the structural design is complete, translating it to code is straightforward. Listings\u00a06.9 \nand 6.10 present the C++ implementation for the ComputerStore class. As seen in Listing 6.10, the computer store displays a computer\u2019s information by relying \non the computer product interface; therefore, once derived computer stores override the \nfactory method to instantiate and return objects of the computer types supported in par-\nticular stores, the displayComputer() method will display the computer information \naccording to the object bound to it at run time. Listing 6.11 presents the factory method \ncode for a standard computer store. Listing 6.9: Header File for the ComputerStore Class\n#include <string>\n// Forward reference. class Computer;\n// The computer store creator class. This is an abstract class,\n// therefore to instantiate computer stores, specific derived\n// computer store classes are required. class ComputerStore {\npublic:\n\t // The standard factory method for creating computer products. virtual Computer* createComputer(std::string type) = 0;\n\t // Method to display a computer\u2019s information. void displayComputer(std::string type);\n};", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 215", "position": 215, "chunk_type": "semantic", "token_estimate": 331}
{"text": "192\u2002 \u2022\u2002 Software Engineering Design\ufeff: As seen, the implementation for the factory method for standard computer stores \nsupports only standard computers. Internally, objects of type StandardComputer \ncan use the abstract factory design pattern from Listings 6.4 and 6.5 to create the stan-\ndard computer, which is common in many practical applications. To remain concise, \nthis part of the problem is not presented in this example; however, to accomplish this, \nthe design of the StandardComputer class would require an association with the \nStandardComputerPartsFactory from the previous section. With this association, \nthe standard computer parts factory is used inside the StandardComputer object to \ncreate standard products, such as standard monitor, keyboard, and CPU. In many prac-\ntical applications, both factory method and abstract factory design patterns are used in \nconjunction for providing extensible and reusable code. To support new products at the \nstandard computer store, the factory method can be modified with different conditional \nstatements for creating the new product; therefore, changes to support new products at a \nspecific \u00ad\ncomputer store are compartmentalized and do not affect all other computer stores. Benefits\n\u2022\t Separates code from product-specific classes; therefore, the same code can work with \nvarious existing or newly created product classes. \u2022\t By separating the code, development becomes efficient, since different developers can \nwork on the different parts of the project at the same time. \u2022\t By separating the code, it becomes easier to reuse and maintain specific parts of the code. Listing 6.10: Source File for the ComputerStore Class\n#include \u201cComputer.h\u201d\n// Method to display a computer\u2019s information. void ComputerStore::displayComputer(string type) {\n\t // Delegate the responsibility of creating a computer object to\n\t // derived classes using the factory method. Computer* computer = createComputer(type);\n\t // Display the computer information, including its cost. This\n\t // information varies according to the factory object used to create\n\t // the computer. computer->displayMonitorInfo();\n\t computer->displayCpuInfo();\n\t computer->displayKeyboardInfo();\n\t computer->displayCost();\n\t // Do more stuff with the computer object here. // Clean up the pComputer and pFactory objects when done.\n}", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 216", "position": 216, "chunk_type": "semantic", "token_estimate": 331}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 193: Skill Development 6.2: Factory Method Design Pattern\nUsing the UML tool of choice, replicate the UML model presented in Figure\u00a0 6.2 \nand generate code from the model. Using the IDE of choice, fill in the gaps in the \ncode generated using Listings 6.9 and 6.11 and compile and execute the software. Once the software \u00ad\nexecutes, go back to the UML model and add a third factory, \nSpecialComputerStore, that carries SpecialComputers. Repeat the code \ngeneration process, fill in the gaps of the new generated code, compile, and execute. When complete, explain the steps required to make this new modification and how the \nfactory method design pattern made this change easy or hard.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 217", "position": 217, "chunk_type": "semantic", "token_estimate": 120}
{"text": "The builder design pattern is an object creational pattern that encapsulates both the: \u00ad\ncreational process and the representation of product objects. Unlike the abstract factory \nListing 6.11: Implementation of the Factory Method \nfor the Standard Computer Store\n// Implement the factory method. Computer* StandardComputerStore::createComputer(string type) {\n\t // Pointer to a computer object. Computer* computer;\n\t // Determine which computer needs to be created. if( type.compare(\u201cstandard\u201d) == 0 {\n\t \t // Create the StandardComputer. Clients are responsible for\n\t \t // cleaning up the memory for the computer object. Internally,\n\t \t // StandardComputer uses StandardComputerPartsFactory to create\n\t \t // a standard computer. computer = new StandardComputer;\n\t }\n\t else {\n\t \t // Create and return a null computer. computer = new NullComputer;\n\t }\n\t // Return the newly created computer object. Clients are responsible\n\t // for cleaning up the computer object. return computer;\n}", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 217", "position": 217, "chunk_type": "semantic", "token_estimate": 135}
{"text": "194\u2002 \u2022\u2002 Software Engineering Design\ufeff: design pattern, in which various product objects are created all at once, the builder design \npattern allows clients to control the (multistep) creational process of a single product object, \nallowing them to dictate the creation of individual parts of the object at discrete points \nthroughout software operations. To accomplish this, the builder design pattern introduces \na creator class (i.e., the builder) that species the (abstract) interface methods required to \nbuild a particular product. These methods are used to build parts of a product, and once \nall parts of the product are created (using the builder interface) clients can request the \nbuilder to return the created object as a whole. Since the creation of the product object is \ndelegated to the concrete builder objects, the product\u2019s representation can vary accord-\ning to the specific concrete builder creating the object. This provides added flexibility for \nmanaging the creational process and representation of products that is not present in other \ncreational patterns. According to the Gang of Four (Gamma et al. 1995, p. 97), the intent \nof the builder is to\nSeparate the construction of a complex object from its representation so that the same con-\nstruction process can create different representations. The idea of separating the process of constructing objects from their representations \nis essential when considering using the builder design pattern. Consider a client\u2013server \nsystem consisting of three clients that work in a distributed fashion and report to a central-\nized server. The server can request status from all three clients, compile the status received \ninto an object of the Message type, and forward it for further processing within the server \nsystem. In this scenario, the creational process of the Message object depends on receiving \ninformation from three different clients. Once information from the first client is received, \nthe part of the Message object that contains information about this client can be created. Similarly, once information from the second and third clients is received, the parts of the \nMessage object that require this information can be built. Once all parts of the Message \nobject are built, the Message object can be forwarded to the rest of the system. In this \nexample, two important characteristics should be noted.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 218", "position": 218, "chunk_type": "semantic", "token_estimate": 371}
{"text": "194\u2002 \u2022\u2002 Software Engineering Design\ufeff: Once all parts of the Message \nobject are built, the Message object can be forwarded to the rest of the system. In this \nexample, two important characteristics should be noted. First, the Message object cannot \nbe instantiated all at once; therefore, a finer-grained method of Message construction is \nrequired so that events occurring at discrete points in time can be used to build individual \nparts of the Message object. The second important, and perhaps more important, charac-\nteristic is the fact that the multistep process that allows for the construction of the Message \nobject is the same, regardless of the representation of the Message object. In this exam-\nple, the Message object can be forwarded within the server system using a binary format\u00ad\n, \nExtensible Markup Language (XML), or any other custom-defined format. A major prac-\ntical benefit can be gained by separating the construction process of objects from their \nrepresentation. Since objects using the builder design pattern can be constructed one step \nat a time, complex algorithms necessary to create these objects can be separated from the \nactual construction of objects so that the same algorithms can be used to build different \nrepresentations of an object. This results in code that can evolve to provide new representa-\ntion of objects by adding new builder classes without modifying the code for the algorithm \nused for creating objects.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 218", "position": 218, "chunk_type": "semantic", "token_estimate": 232}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 195: Problem\nA company develops software to monitor and control custom-built hardware developed \nby a separate vendor. The equipment supports 100 different messages, defined using a \ncustom-defined interface control document (ICD). Every time the messaging specifica-\ntion changes, the code that represents all 100 messages has to be changed manually. The \ncompany has decided to develop a message generator that reads the message specifica-\ntion document, finds the appropriate information for each message, and generates code \nto represent them. This way, once the ICD changes all the company has to do is regen-\nerate the messages. Currently, the software for monitoring and control is developed \nin C++ so the message generator generates C++ code. However, the need for creating \n\u00ad\nmessage libraries for both Java, C#, and other languages is being evaluated. This means \nthat changes to the ICD will require message regeneration for all supported languages. The software company wants a design for the message generator that separates the algo-\nrithm for parsing the messaging specification from the code that generates classes for \nthe messages in specific programming languages (e.g., C++, Java). This way, changes \nto the messaging specification will not affect the code that generates the messages in \nspecific programming languages and vice versa; changes or addition to support new \nprogramming language generation will not affect the code that parses the messaging \nspecification. To keep track of changes in the ICD and messaging libraries, the company \nalso wants to keep history and statistics of code generation, such as build number, build \ndate, number of methods generated, and number of classes generated. Structure\nThe general and applied structural view of the builder design pattern for the message \nbuilder problem is presented in Figure\u00a06.3. In the general view of the pattern\u2019s structure, \nnotice that the association with the Product class and the method for returning the \nproduct are specified in the ConcreteBuilder class. In many practical situations, the \nproducts being built can have dissimilar interfaces, therefore making it difficult to add \nthe interface method that returns the product in the AbstractBuilder base class and \nreducing flexibility in code.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 219", "position": 219, "chunk_type": "semantic", "token_estimate": 356}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 195: In the general view of the pattern\u2019s structure, \nnotice that the association with the Product class and the method for returning the \nproduct are specified in the ConcreteBuilder class. In many practical situations, the \nproducts being built can have dissimilar interfaces, therefore making it difficult to add \nthe interface method that returns the product in the AbstractBuilder base class and \nreducing flexibility in code. In the message builder example, since the products gener-\nated can be represented using the same interface, the method that returns the product \n(i.e.,\u00a0getGeneratedProduct\n()\n) is moved to the base class so that client code can rea-\nson about builders in terms of the AbstractBuilder interface and not based on con-\ncrete builders. The creational process is represented using the builder base class, which \ndelineates the creational process using abstract interface methods. For each identified rep-\nresentation of the product, a class is created that inherits from the builder base class. These \nclasses provide the specific creational details for their particular representation. Finally, \nbuilders are associated with the product class to generate the information required to build \nthe product as a whole. There are two main driving forces behind the application of the builder design pattern \nto the message builder problem. First, since messages are generated from a document, the", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 219", "position": 219, "chunk_type": "semantic", "token_estimate": 224}
{"text": "196\u2002 \u2022\u2002 Software Engineering Design\ufeff: sections in the document that specify the parts of a particular message may be scattered \nthroughout the document; therefore, the message object may not be able to be created all at \nonce. Second, the processing of the ICD file is the same, regardless of the target program-\nming language used for generating messaging code. This means that the same parsing \nalgorithm can be used to identify the key document elements used for code generation, \nregardless of the target language. Once these characteristics are identified, a step-by-step \napproach can be used to design the builder design pattern. The steps for applying the \nbuilder design pattern are as follows:\n\t\n1. Identify and design the product class (e.g., GeneratedProduct). 2. Identify the product\u2019s creational process and algorithm, and design a class for its exe-\ncution (e.g., CodeGenerator). Each creational step (when necessary) must be made in \nterms of a standard product builder interface (instead of concrete product interface). 3. Using the knowledge acquired from Steps 1 and 2, design the builder interface, which \nspecifies the parts that need to be created for the whole object to exist. These are captured \nas abstract interface methods that need to be implemented by derived concrete builders. <<interface>>\nAbstractBuilder\n+buildProductPartA()\n+buildProductPartB()\n+buildProductPartC()\nConcreteBuilder\n+buildProductPartA()\n+buildProductPartB()\n+buildProductPartC()\n+getProduct()\nDirector\n+construct()\nCodeGenerator\n+generateCode(): void\nMessageBuilder\n+buildNewClass(name: stiring): void\n+buildClassAttributes(attributes: string): void\n+buildClassOperations(operations: string): void\n+closeClass(): void\n+getFileExtension(): string\n+getGeneratedProduct(): GeneratedProduct*\n+buildNewClass(name: string): void\n+buildClassAttributes(attributes: string): void\n+buildClassOperations(operations: string): void\n+closeClass(): void\n+getFileExtension(): string\n+buildNewClass(name: string): void\n+buildClassAttributes(attributes: string): void\n+buildClassOperations(operations: string): void\n+closeClass(): void\n+getFileExtension(): string\nJavaMessageBuilder\nCppMessageBuilder\nGeneratedProduct\n+addCode(code : string)\n+getCode(): string\n+getStats(): string\n+getdate() string\n+getBuild(): string\n+getAttributes(): string\n+getClasses() : string\n\u2013stats: string\nProduct\nGeneral View\nApplication View\nFIGURE 6.3\nUML class diagram for the builder design pattern.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 220", "position": 220, "chunk_type": "semantic", "token_estimate": 298}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 197: 4. Identify and design classes for the different representations of the product \n(e.g.,\u00a0CppMessageBuilder and JavaMessageBuilder). These classes realize the inter-\nface from Step 3 in terms of the particular representations. When using the builder design pattern, the representation of each object is encapsulated \nin one or more concrete builder classes; therefore, adding new representation can be done \neasily by extending the design and not modifying existing working code. Implementation\nUsing the structural design from Figure\u00a06.3, the implementation for the MesageBuilder \nclass is presented in Listing 6.12. As seen, the purpose of this class is to specify the creational\u00ad\n \nsteps required for the generation of each message. Since messages in the ICD are generated \nas classes, the MessageBuilder has methods for creating new classes, adding attributes, \nadding methods, and generating code for closing classes (e.g., \u201c};\u201d in C++ and \u201c}\u201d in Java) \nand retrieving the extension used for the generated file. These interface methods serve as \nindication of the parts required to create a whole GeneratedProduct object. By sepa-\nrating these parts into multiple interface methods, the creational process can call upon \nthem individually to create the product object at discrete points during software execution, \nwhen information becomes available. Once the creational parts are identified and incorporated into the MessageBuilder \nbase class, different derived classes can be implemented to provide the required object \nrepresentation. Since this behavior is incorporated into the design using inheritance, \nthe number of representations can be extended easily in future versions of the software. Listing\u00a06.13 presents the code for the concrete message builder that generates C++ code for \nthe messages. For each creational method in the CppMessageBuilder class, the parameters passed \nin are processed and transformed to C++ code before adding it to the product being gener-\nated. The same process is used for any other language that needs to be supported, such as \nJava or C#. Finally, the algorithm for product creation is created and encapsulated using \nthe CodeGenerator class. As seen, by varying the builder object passed to the code \ngenerator\u2019s\u00ad\n constructor, message generation can occur in different languages, as presented \nin Listing 6.14. Benefits\n\u2022\t The builder separates an object\u2019s construction process with its representation; \ntherefore\u00ad\n, future representations can be added easily to the software. \u2022\t Changes to the existing representation can be made without modifying the code for \nthe creational process.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 221", "position": 221, "chunk_type": "semantic", "token_estimate": 400}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 197: Benefits\n\u2022\t The builder separates an object\u2019s construction process with its representation; \ntherefore\u00ad\n, future representations can be added easily to the software. \u2022\t Changes to the existing representation can be made without modifying the code for \nthe creational process. \u2022\t The builder provides finer control over the construction process so that objects can be \ncreated at discrete points in time.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 221", "position": 221, "chunk_type": "semantic", "token_estimate": 69}
{"text": "198\u2002 \u2022\u2002 Software Engineering Design\ufeff: Skill Development 6.3: Builder Design Pattern\nUsing pencil and paper, modify the UML class diagram for the message builder prob-\nlem to include message generation using the C# programming language. Explain the \nsteps taken and how the addition of the new program feature impacts the existing \ndesign. List the pros and cons of using the builder design pattern for this problem. Listing 6.12: C++ Implementation of the MessageBuilder Class\n#include <string>\n// Forward reference. class GeneratedProduct;\nclass MessageBuilder {\npublic:\n\t // The interface method for building a new class. virtual void buildNewClass(string name) = 0;\n\t // The interface method for building class attributes. virtual void buildClassAttributes(string attributeList) = 0;\n\t // The interface method for building class operations. virtual void buildClassOperations(string operationList) = 0;\n\t // The interface method for closing a new class. virtual void closeClass() = 0;\n\t // The file extension for the target programming language. virtual string getFileExtension() = 0;\n\t // Return the generated product. GeneratedProduct* getGeneratedProduct() {\n\t \t return _codeProduct;\n\t }\nprivate:\n\t // The product containing generated code and stats about code\n\t // generated. GeneratedProduct* _codeProduct;\n};", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 222", "position": 222, "chunk_type": "semantic", "token_estimate": 183}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 199: Listing 6.13: C++ Implementation for the Message Builder that Generates C++\nclass CppMessageBuilder : public MessageBuilder {\npublic:\n\t // The interface method for building a new class. virtual void buildNewClass(string name) {\n\t \t // Generate code for creating a class using CPP style and the\n\t \t // name argument. // Once code is generated, add it to the product. getGeneratedProduct()->addCode(/*new C++ class code*/);\n\t }\n\t // The interface method for building class attributes. virtual void buildClassAttributes(string attributeList) {\n\t \t // For all items in attributeList, generate attributes using CPP\n\t \t // style and add them to the generated code. // Once code is generated, add it to the product. getGeneratedProduct()->addCode(/*C++ attributes*/);\n\t }\n\t // The interface method for building class operations. virtual void buildClassOperations(string operationList) {\n\t \t // For all items in operationList, generate operations using CPP\n\t \t // style and add them to the generated code. // Once code is generated, add it to the product. getGeneratedProduct()->addCode(/*C++ operations*/);\n\t }\n\t // The interface method for closing a new class. virtual void closeClass() {\n\t \t // Generate code to close a class in Cpp, and add it to the\n\t \t // generated code. // Once code is generated, add it to the product. getGeneratedProduct()->addCode(\u201c\\n};\\n\\n\u201d);\n};", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 223", "position": 223, "chunk_type": "semantic", "token_estimate": 202}
{"text": "200\u2002 \u2022\u2002 Software Engineering Design\ufeff: Listing 6.14: C++ Implementation for the CodeGenerator\nclass CodeGenerator {\npublic:\n\t // Constructor. CodeGenerator(MessageBuilder* pBuilder) : m_pBuilder(pBuilder) {\n\t \t // Assume a valid builder pointer. Notice that m_pBuilder is\n\t \t // initialized in the constructor\u2019s initialization list above.\n\t } // The interface method for building a new class. virtual void generateCode(string fileName) {\n\t \t // Open file for reading: fileName. while ( /* not end of file */) {\n\t \t \t // read next token in file. if( /*class name found*/) {\n\t \t \t \t // Assume that variable className holds the name. m_pBuilder->buildNewClass(className);\n\t \t \t }\telse if( /*attribute list found*/) {\n\t \t \t \t // Assume that attributeList contains the attributes\n\t \t \t \t m_pBuilder->buildClassAttributes(attributeList);\n\t \t \t }\telse if( /*operation list found*/) {\n\t \t \t \t // Assume that operationList contains the operations. m_pBuilder->buildClassOperations(operationList);\n\t \t \t \t // Close the class. m_pBuilder->closeClass();\n\t \t \t }\n\t \t } // end while( /* not end of file */)\n\t \t // Close file: fileName. // Create file using file extension from generated product object. // write(m_pBuilder->getGeneratedProduct()->getCode());\n\t \t // Close file. // logCodeGeneration(m_pBuilder->getGeneratedProduct());\n\t }\t// end generateCode(...)\nprivate:\n\t MessageBuilder* m_pBuilder;\n};", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 224", "position": 224, "chunk_type": "semantic", "token_estimate": 166}
{"text": "Section: Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 201", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 225", "position": 225, "chunk_type": "semantic", "token_estimate": 9}
{"text": "The prototype design pattern is a class creational design pattern that allows clients to \u00ad: create \nduplicates of prototype objects at run time without knowing the objects\u2019 specific type. Previous creational design patterns, such as abstract factory and builder, required two \ndistinct set of classes: one or more creational classes and one or more product classes to \nsupport the creational process. Unlike these, in which creator and product classes were \nseparate, prototype objects are both creators and products. This characteristic allows them \nto support a generic interface for object creation while having the capability to access inter-\nnal product data to create (deep) copies of prototypical objects. These copies are returned \nto clients and used independently from the original prototype object. According to the \nGang of Four (Gamma et al. 1995, p. 117), the intent of the prototype design pattern is to\nSpecify the kinds of objects to create using a prototypical instance, and create new objects by \ncopying this prototype. The prototype design pattern is typically used when clients need to duplicate products \nat run time without regarding how products are created or their specific concrete types. This allows copies from a variety of objects within the same class hierarchy to be created \nuniformly, which simplifies client code and adds flexibility to designs. Problem\nConsider the enemy component created for a gaming system. The detailed design of the \nenemy component includes a wide variety of enemy specifications defined for the game, \neach including different profiles and weapons. The game designers have identified the \nneed to have each character provide a method for creating copies of themselves so that \nat any given point during the game a character clone can be made including identical \nenergy level, weapons, and profiles. This functionality is required to develop an enemy \nregistry of different Character subtypes to create and add enemies at any point dur-\ning the game. Consider the initial proposed solution to the problem, as presented in \nListing 6.15. As seen, both TerrestrialEnemyCharacter and AerialEnemyCharacter have been \ndesigned to support an interface method for duplication of objects at run time. The prob-\nlem with the code in Listing 6.15 is that clients are required to know about the specific \nconcrete class to create a copy of each different character. Therefore, it is inefficient to \ndesign an enemy character registry that can be used throughout the game to create char-\nacters uniformly, since the creational process requires knowledge about the particular \ninterface method for duplicating a run-time object.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 225", "position": 225, "chunk_type": "semantic", "token_estimate": 415}
{"text": "The prototype design pattern is a class creational design pattern that allows clients to \u00ad: The prob-\nlem with the code in Listing 6.15 is that clients are required to know about the specific \nconcrete class to create a copy of each different character. Therefore, it is inefficient to \ndesign an enemy character registry that can be used throughout the game to create char-\nacters uniformly, since the creational process requires knowledge about the particular \ninterface method for duplicating a run-time object. This decreases the design\u2019s flexibility, \nsince it does not support object extension without code modification. That is, for every \nnew type of enemy character, the enemy registry code for creating and adding\u00ad\n \u00ad\ncharacters", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 225", "position": 225, "chunk_type": "semantic", "token_estimate": 116}
{"text": "202\u2002 \u2022\u2002 Software Engineering Design\ufeff: to the game needs to be modified for including the new character. This problem is pre-\nsented in Listing 6.16. As seen, the code required to create copies of enemy characters using the enemy regis-\ntry with only two characters is quite large. Consider the case where 100 different enemy \ncharacters are designed for the gaming system. In such a case, the size of the function \nwould increase significantly, since a conditional statement is required for each character. This problem can be solved easily by using a prototypical interface for creating copies \nthat does not require clients\u2014in this case, the function to create the enemy character\u2014to \nknow which object they are creating. Listing 6.15: C++ Implementation for the Terrestrial and Aerial Enemy Characters\n// The character interface. class Character {\npublic:\n\t virtual void attack() = 0;\n\t // Other methods such as defend, move, etc. };\nclass TerrestrialEnemyCharacter : public Character {\npublic:\n\t // Method definitions for terrestrial attack, defend, etc. // Duplicate this object. TerrestrialEnemyCharacter* duplicateTerrestrial() {\n\t \t // Use the copy constructor to create a copy of this object and\n\t \t // return it. return new TerrestrialEnemyCharacter (*this);\n\t }\n};\nclass AerialEnemyCharacter : public Character {\npublic:\n\t // Method definitions for aerial attack, defend, etc. // Duplicate this object. AerialEnemyCharacter* duplicateAerial() {\n\t \t // Use the copy constructor to create a copy of this object and\n\t \t // return it. return new AerialEnemyCharacter(*this);\n\t }\n};", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 226", "position": 226, "chunk_type": "semantic", "token_estimate": 237}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 203: Listing 6.16: C++ Implementation of the Client \nthat Creates New Enemy Character\n// Pre-Condition: A registry of 2 Enemy Characters has been created. Character* createNextEnemyCharacter() {\n\t // Randomly pick the location of the next enemy character to be\n\t // created. int nextEnemyLocation = rand() % MaxNumberOfEnemies;\n\t // Make sure that nextEnemyLocation is within proper bounds. // Retrieve the character at the nextEnemyLocation. Character* pCharacter = enemyRegistry[nextEnemyLocation];\n\t // The enemy character to be returned. Character* pNewCharacter = 0;\n\t // Determine if the character located at nextEnemyLocation is\n\t // Terrestrial. if( dynamic_cast<TerrestrialEnemyCharacter*>(pCharacter) != 0 ) {\n\t \t // Terrestrial Character, downcast it so that the\n\t \t // duplicateTerrestrial method can be used to duplicate the\n\t \t // terrestrial character. TerrestrialEnemyCharacter* pTerrestrial =\n\t \t\ndynamic_cast<TerrestrialEnemyCharacter*>(pCharacter);\n\t \t // Create the copy. Clients are responsible for cleaning up memory\n\t \t // allocated for the copy. pNewCharacter = pTerrestrial->duplicateTerrestrial();\n\t }\n\t // Determine if the character located at nextEnemyLocation is Aerial. else if( dynamic_cast<AerialEnemyCharacter*>(pCharacter) != 0 ) {\n\t \t // Aerial Character, downcast it so that the duplicateAerial\n\t \t // method can be used to duplicate the aerial character. AerialEnemyCharacter* pAerial =\n\t \t\ndynamic_cast<AerialEnemyCharacter*>(pCharacter);\n\t \t // Create the copy. Clients are responsible for cleaning up memory\n\t \t // allocated for the copy. pNewCharacter = pAerial->duplicateAerial();\n\t }\n\t else {\n\t \t // Invalid Character. pNewCharacter = new InvalidEnemyCharacter;\n\t }\n\t // Return the newly created enemy character. return pNewCharacter;\n}", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 227", "position": 227, "chunk_type": "semantic", "token_estimate": 226}
{"text": "204\u2002 \u2022\u2002 Software Engineering Design\ufeff: Structure\nThe general and applied structural view of the prototype design pattern for the gaming \nsystem problem is presented in Figure\u00a06.4. As seen, from the structural point of view the \nonly thing required to implement the prototype design pattern is the addition of the clone \ninterface method to the Character type. By adding the clone() method in the char-\nacter interface, the behavior for creating character duplicates throughout the game is stan-\ndardized and delegated to derived classes. Therefore, by deriving from this base class and \nimplementing the clone interface, derived classes can abstract the process of creating a \ncopy of themselves. The driving forces behind this design are the ability of client objects to create duplicates \nof character objects without knowing the object\u2019s internal true composition and providing \nclients the ability to reason about character objects using the character interface. Once these \ncharacteristics are identified, applying the prototype design pattern is straightforward. 1. Identify and design the common interface that needs duplication. As part of the \ninterface, the clone interface method needs to be specified. 2. Identify and design concrete products, which realize the interface created in Step 1. 3. For each concrete product created in Step 2, implement the clone method in terms of \nthat particular concrete product. <<interface>>\nPrototype\n+clone(): Prototype*\nConcretePrototypeA\n+clone(): Prototype*\nGemeEngine\n+createNextEnemyCharacter(): Character*\n+clone(): Character*\n+attack(): void\nTerrestrialEnemyCharacter\n+clone(): Character*\n+attack(): void\nAerialEnemyCharacter\n+clone(): Character*\n+attack(): void\n<<interface>>\nCharacter\nConcretePrototypeB\n+clone(): Prototype*\nClient\n+operation()\nGeneral View\nApplied View\nFIGURE 6.4\nUML class diagram for the prototype design pattern.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 228", "position": 228, "chunk_type": "semantic", "token_estimate": 261}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 205: Implementation\nFrom the structural point of view, application of the prototype design pattern is straight\u00ad\nforward. In Listing 6.17, the Character interface is specified, which includes the clone() \ninterface method. By specifying the clone method as a pure virtual method, derived classes \nare forced to provide an implementation before they can be instantiated. For simplicity \nListing 6.17: C++ Implementation of the Terrestrial\u00a0Character \nand New Character Interface\n// The character interface. class Character {\npublic:\n\t // Interface method for initiating an attack. virtual void attack() = 0;\n\t // Interface method for duplicating objects at run-time. virtual Character* clone() = 0;\n\t // Other methods such as defend, move, etc. };\nclass TerrestrialEnemyCharacter : public Character {\npublic:\n\t // Method definitions for terrestrial attack, defend, etc. void attack() {\n\t \t // Display to the console the type of attack. cout<<\u201dTerrestrialEnemyCharacter::attack()!\\n\u201d;\n\t }\n\t // Duplicate this object. TerrestrialEnemyCharacter* duplicateTerrestrial() {\n\t \t // Use the copy constructor to create a copy of this object and\n\t \t // return it. return new TerrestrialEnemyCharacter (*this);\n\t }\n\t // Implementation of the clone interface method to duplicate a\n\t // terrestrial enemy character. Character* clone(void) {\n\t \t // Delegate duplication to existing method. return duplicateTerrestrial();\n\t }\n};", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 229", "position": 229, "chunk_type": "semantic", "token_estimate": 201}
{"text": "206\u2002 \u2022\u2002 Software Engineering Design\ufeff: (and to make the point clearer), the clone() method is implemented in terms of the pre-\nviously existing duplicateTerrestrial\n() method from Listing 6.15. In a practical \ndevelopment effort, such a method is removed so that the clone method can directly create \nthe object\u2019s copy. As seen, the prototype\u2019s clone method results in a call to the copy constructor. In this \nexample, the C++ default copy constructor is called upon to create a copy of the specific \ncharacter object. However, careful attention must be in place when copying more complex \nobjects. In these cases, where the default copy constructor is insufficient to provide a deep \ncopy of the object, a specialized copy constructor must be provided. The same approach for \ncreating duplicates is repeated for the AerialEnemyCharacter, as seen in Listing 6.18. Once both TerrestrialEnemyCharacter and AerialEnemyCharacter imple-\nment the clone interface, the client code presented in Listing 6.16 is modified to randomly \ncreate enemy characters using prototypical instances that support the clone() method, \nas seen in Listing 6.19. By using the prototype design pattern, the original client function is \nreduced significantly. More importantly, the addition of new enemy characters or removal \nListing 6.18: C++ Implementation for the AerialEnemyCharacter\nclass AerialEnemyCharacter : public Character {\npublic:\n\t // Implement the attack interface method for aerial characters. void attack(void) {\n\t \t // Display to the console the type of attack. cout<<\u201dAerialEnemyCharacter::attack()!\\n\u201d;\n\t }\n\t // Duplicate this object. AerialEnemyCharacter* duplicateAerial(void) {\n\t \t // Use the copy constructor to create a copy of this object and\n\t \t // return it. return new AerialEnemyCharacter(*this);\n\t }\n\t // Implementation of the clone interface method to duplicate a\n\t // aerial enemy character. Character* clone(void) {\n\t \t // Delegate duplication to existing method. return duplicateAerial();\n\t }\n};", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 230", "position": 230, "chunk_type": "semantic", "token_estimate": 288}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 207: of existing characters will not affect the client\u2019s implementation. This provides added flex-\nibility to support change in future versions of the gaming system. Benefits\n\u2022\t Clients are shielded from knowing the internal structure of objects; therefore, adding \nproducts at run time is easier. This reduces the client\u2019s complexity. \u2022\t Reduced number of classes; instead of having two classes for object creation (i.e., creator \nand product classes), the prototype is both, therefore eliminating the need for one class \nfor each product.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 231", "position": 231, "chunk_type": "semantic", "token_estimate": 89}
{"text": "The singleton design pattern is an object creational design pattern used to prevent objects: from being instantiated more than once in a running program. It is meant to provide a \ndesign solution that enforces the conceptual representation of entities that must be sin-\ngular within the problem domain. For example, consider the simulation of an operat-\ning system. In the operating systems domain, the simulation software may contain types \n(i.e., classes) for processes, threads, and so forth that can be instantiated multiple times to \nproperly represent running programs within the simulation. In these cases, the multiple \ninstantiation of these types is conceptually consistent with the problem domain. However, \nconsider an entity type for singular items, such as the file system. In this case, for a typical \noperating system, it would be conceptually incorrect to have multiple file system object \ninstances running within the simulation. Furthermore, if the simulation were to create \ntwo file systems by mistake, the results would not be reliable. In cases such as this one, the \nsingleton design pattern can be used to enforce the policy that only one instance of the file \nListing 6.19: C++ Code for the Client that Creates \nNew\u00a0Characters Using the Prototype Interface\nCharacter* createNextEnemyCharacter() {\n\t // Randomly pick the location of the next enemy character to be\n\t // created. int nextEnemyLocation = rand() % MaxNumberOfEnemies;\n\t // Make sure that nextEnemyLocation is within proper bounds. // Retrieve the character at the nextEnemyLocation. return enemyRegistry[nextEnemyLocation]->clone();\n}", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 231", "position": 231, "chunk_type": "semantic", "token_estimate": 243}
{"text": "208\u2002 \u2022\u2002 Software Engineering Design\ufeff: system object is running at all times. According to the Gang of Four (Gamma et al. 1995, \np. 127), the intent of the singleton is to\nEnsure a class only has one instance, and provide a global point of access to it. Since the singleton limits object creation to one instance, it is important that the one \ninstance can be accessible through a standard method. Therefore, the singleton design pat-\ntern also provides a global point of access to it. Problem\nConsider an application that requires event-logging capabilities. The application consists of \nmany different objects that generate events to keep track of their actions, status of opera-\ntions, errors, or any other information of interest. A decision is made to create an event \nmanager that can be accessed by all objects and used to manage all events in the system. Upon instantiation, the event manager creates an event list that gets updated as events are \nlogged. At specific points during the software system\u2019s operation, these events are written \nto a file. To prevent conflicts, it is desirable that at any given time there is only one instance \nof the event manager executing. Structure\nThe general and applied structural view of the singleton design pattern for the event man-\nager is presented in Figure\u00a06.5. As seen, from the structural point of view the singleton is \nthe simplest design pattern, since it requires only one class. The driving force behind this \nGeneral View\nApplication View\n\u2013instance_: Singleton*\n+operation()\n\u2013Singleton()\n+getInstance(): Singleton*\nSingleton\n\u2013instance : EventManager*\n\u2013EventManager()\n+getInstance(): EventManager*\n+logEvent(eventDescription: string): void\nEventManager\nFIGURE 6.5\nUML class diagram for the singleton design pattern.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 232", "position": 232, "chunk_type": "semantic", "token_estimate": 276}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 209: design is the ability for clients to have global access to the event manager and the assurance \nthat there is only one instance of the event manager at all times. Assuming a single-threaded \napplication, these characteristics are typically a good indication for applying the singleton \ndesign pattern. To apply the singleton design pattern, a three-step approach is employed:\n\t\n1. Set the visibility of the constructor to private. 2. Define a private static member attribute that can store a reference (or pointer) to the \none instance of the singleton. 3. Create a public static getInstance method that can access the private constructor \nto instantiate objects of the singleton type and return it to clients. When designing singletons, the class constructor needs to be specified as private to pre-\nvent clients from instantiating objects of the singleton type via the direct access to the \nconstructor. Since access to the constructor is prohibited, the second step involves creating \na method that can access the private constructor to instantiate objects of the singleton\u2019s \ntype. This method needs to be a class method (i.e., static) so that it can be called at the class \nlevel without instantiating an object of the class. This is done by specifying the method as \nstatic with public visibility. Finally, a private static member attribute that can store a refer-\nence or pointer to the running instance of the singleton needs to be created to keep track \nof the one, and only one, instance of the singleton. This attribute is initially set to zero or \nnull, and once a call to the getInstance() method is made the attribute is checked to \ndetermine if the instance of the singleton has been created. If it hasn\u2019t, the method instanti-\nates it and returns it to the caller. After the first initialization process, further calls to the \ngetInstance() method will fail the condition that determines that the attribute is null, \ntherefore directly returning the existing singleton object. Implementation\nAs specified before, the implementation of the singleton consists of three main steps. First, \nthe visibility of the constructor needs to be private to prevent direct instantiation from \n\u00ad\nclients. Next, a public class (static) member function must be created to provide clients \nwith a globally accessible function for the singleton. Finally, the globally accessible func-\ntion must instantiate the singleton object while enforcing that only one instance is \u00ad\ncreated \nthroughout program.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 233", "position": 233, "chunk_type": "semantic", "token_estimate": 406}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 209: Next, a public class (static) member function must be created to provide clients \nwith a globally accessible function for the singleton. Finally, the globally accessible func-\ntion must instantiate the singleton object while enforcing that only one instance is \u00ad\ncreated \nthroughout program. The C++ implementation of the EventManager singleton class is \n\u00ad\npresented in Listings 6.19 and 6.20. Once the singleton design pattern is applied to the EventManager, client objects can \nuse it easily via the standardized and globally accessible getInstance() method, as \npresented in Listing 6.21. The singleton design pattern has been known to fail in multithreaded applications, result-\ning in the creation of more than one instance of the singleton. Therefore, its usage in these \ntypes of environments should be carefully evaluated before implementation.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 233", "position": 233, "chunk_type": "semantic", "token_estimate": 135}
{"text": "210\u2002 \u2022\u2002 Software Engineering Design\ufeff: Listing 6.19: C++ Header File for the EventManager Singleton\n#include <string>\nclass EventManager {\npublic:\n\t // The global point of access to the EventManager. static EventManager* getInstance();\n\t // The method that logs events. void logEvent(std::string eventDescription);\nprivate:\n\t // Private Constructor. EventManager();\n\t // The one and only instance of the EventManager. static EventManager* _instance;\n};\nListing 6.20: C++ Source File for the EventManager Singleton\n#include \u201cEventManager.h\u201d\n// Initialize the instance_ static member attribute. EventManager* EventManager::_instance = 0;\n// The global point of access to the EventManager. EventManager* EventManager::getInstance() {\n\t // Determine if an instance of the EventManager has been created. if( _instance == 0 ) {\n\t \t // Create the one and only instance. _instance = new EventManager;\n\t }\n\t return _instance;\n}\n// The method that logs events. void EventManager::logEvent(std::string eventDescription) {\n\t // Code to log event.\n} // Private Constructor. EventManager::EventManager() {\n\t // Intentionally left blank.\n}", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 234", "position": 234, "chunk_type": "semantic", "token_estimate": 151}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 211: Benefits\n\u2022\t The singleton provides controlled access to a single instance of a given type. \u2022\t It has reduced name space since it provides an alternative to global variables. \u2022\t It can be customized to permit variable number of instances.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 235", "position": 235, "chunk_type": "semantic", "token_estimate": 48}
{"text": "Creational design patterns are patterns for abstracting and controlling the way objects are: created in software applications. They play a key role in the design of systems by making them \nindependent of how objects in the system are created, composed, and represented. Therefore, \nparts of the system responsible for creating (or instantiating) objects do so through a common \ncreational interface without knowledge of how the actual object or group of objects are created. In addition, by controlling the creational process with a common interface, enforcing cre-\national policies becomes easier, therefore giving the system the ability to create product objects \nthat share a common interface but that vary widely in structure and behavior. Examples \nof creational patterns include the abstract factory, factory method, builder, prototype, and \nsingleton. This chapter explored several well-established creational design patterns and pre-\nsented the problems they are designed to address, together with the benefits that each of the \ndiscussed patterns provides. Identifying and designing using creational design patterns can \nimprove the efficiency of the development process and the quality of the final system.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 235", "position": 235, "chunk_type": "semantic", "token_estimate": 178}
{"text": "1.\tWhat are creational design patterns? What are they used for?: 2. Compare and contrasts the following patterns:\n\t\na.\t Abstract factory\n\t\nb. Factory method\nListing 6.21: C++ Implementation for Client Objects \nUsing the EventManager Singleton\nint main() {\n\t // Log events using the singleton event manager. EventManager::getInstance()->logEvent(\u201clog some event here\u201d);\n\t // Or store the pointer to log events later. EventManager* pEventManager = EventManager::getInstance();\n\t pEventManager->logEvent(\u201clog some event here\u201d);\n}", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 235", "position": 235, "chunk_type": "semantic", "token_estimate": 68}
{"text": "212\u2002 \u2022\u2002 Software Engineering Design\ufeff: c.\t Builder\n\t\nd.\t Prototype\n\t\n3. List and explain the benefits of applying the abstract factory design pattern. 4. What is the builder design pattern? List and explain the main features of the builder \ndesign pattern. 5. What particular problems are addressed by the builder design pattern? 6. What is the essential structural element required in the prototype design pattern? 7. Explain the steps required to implement the singleton design pattern? Are there any \nlimitations to this pattern? Explain.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 236", "position": 236, "chunk_type": "semantic", "token_estimate": 83}
{"text": "1.\tA company is designing software for monitoring and controlling a custom-built: system consisting of multiple hardware components (i.e., Equipment1, Equipment2, \nand Equipment3). Each equipment component provides unique status, unique \ncommands, and specific interface for communicating, such as a Universal Serial \nBus (USB), Serial, and Transmission Control Protocol/Internet Protocol (TCP/IP). Regardless of the communication type, each class representing an equipment must \nprovide functionality to get specific status (e.g., getEquipmentOneStatus1, getE-\nquipmentTwoStatus1) and send specific commands to the device (e.g., sendEquip-\nmentOneCmd1, sendEquipmentTwoCmd1). The software provides a graphical user \ninterface (GUI) that polls each hardware component for its status data and also pro-\nvides means for sending commands to the components. Since hardware development \nis expected to take longer than the expected GUI development, management has \ndecided to simulate the components so that GUI development and testing can move \nforward. That is, there are two streams of equipments: real equipment, composed of \nEquipment1, Equipment2, and Equipment3; and simulated equipments, composed \nof SimEquipment1, SimEquipment2, and SimEquipment3. Design this system using \nthe abstract factory design pattern so that the GUI software can work the same way \nusing real or simulated components, regardless of the type of component. 2. Your company develops software to monitor and control custom-built hardware devel-\noped by a separate vendor. The equipment supports 100 different messages, defined \nwith the format specified in the following box. Every time the messaging specifica-\ntion changes, the code for all 100 messages has to change manually. To make things \nworse, your company supports two versions of the software, one in Java and one in \nC++, so these changes must be made to both versions. In addition, there are future \nplans for providing a messaging library in C# as well, based on the messaging specifica-\ntion. Clearly, there has to be a more efficient way to manage this process. Management \nhas asked you, the design team, to come up with a design that separates the algorithm \nfor parsing the messaging specification from the code that generates classes for the", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 236", "position": 236, "chunk_type": "semantic", "token_estimate": 335}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 213: messages in a specific programming language (e.g., Java or C++). This way, changes \nto the messaging specification will not affect the code that generates the messages in \nspecific programming languages and vice versa; that is, changes or additions to support \nnew programming language generation will not affect the code that parses the messag-\ning specification. A sample of the messaging specification containing three messages is \ngiven to you so that you can propose a design that can improve the code generation pro-\ncess. Management would be thrilled if your design would support different generators \n(at run time) capable of producing the messages in different programming languages. That way, by swapping generators different programming languages can be supported. The generated code should provide get() and set() methods for all attributes. 3. Apply the builder design pattern to design this system. 4. Use the tool of your choice (e.g., rational rose, starUML, MS PowerPoint, Visio) to \ncreate the UML class diagram for the problem\n\t\n5. Write code in C++ to demonstrate the implementation of your design. Your pro-\ngram must create files containing Java or C++ code for the generated messages, \ndepending on the builder used. Messaging Specification Sample\nName:PowerOnCmd;\nAttributes:4;\nbyte:headerSize;\nbyte:msgId;\nbyte:sourceId;\nbyte:destinationId;\nOperations:0;\nName:SelfTestCmd\nAttributes:5;\nbyte:headerSize;\nbyte:msgId;\nbyte:sourceId;\nbyte:destinationId;\nbyte:testId;\nOperations:0;\nName:SetDataCmd;\nAttributes:6;\nbyte:headerSize;\nbyte:msgId;\nbyte:sourceId;\nbyte:destinationId;\nbyte:dataType;\nbyte:dataSize;\nOperations:2;\nbyte*,getData,void;\nvoid,setData,byte*;", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 237", "position": 237, "chunk_type": "semantic", "token_estimate": 231}
{"text": "214\u2002 \u2022\u2002 Software Engineering Design\ufeff: 6. Prepare a 10- to 15-minute PowerPoint presentation consisting of the following:\n\t\na. Introduction to the problem\n\t\nb. Solution approach (UML class diagram)\n\t\nc.\t Presentation of the builder code\n\t\nd.\t Demo of the program\n\t\ne.\t Be ready to state your assumptions and to justify and defend all of your design \ndecisions.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 238", "position": 238, "chunk_type": "semantic", "token_estimate": 56}
{"text": "215: 7\nStructural and Behavioral\u00a0Patterns \nin Detailed Design", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 239", "position": 239, "chunk_type": "semantic", "token_estimate": 9}
{"text": "\u2022\t Understand the importance and role of structural and behavioral: design patterns in detailed design\n\u2022\t Identify, understand, and model common structural and behavioral \ndesign patterns\n\u2022\t Become proficient in implementing models of both structural and \nbehavioral design patterns\n\u2022\t Understand the benefits of important structural and behavioral design \npatterns", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 239", "position": 239, "chunk_type": "semantic", "token_estimate": 50}
{"text": "As seen in the previous chapter, common patterns in object-oriented: designs exist to provide detailed design solutions to problems that recur \nmany times over in different systems. Beside the creational design patterns \nstudied so far, other common and popular design patterns have been iden-\ntified to address structural and behavioral problems commonly encoun-\ntered in software applications. Structural and behavioral designs patterns \nhelp identify problems that deal with the structure and behavior of software \ndesigns; they prescribe the classes required for their design solution and \ninterrelationships required to support object creation their behavior. These \npatterns allow designers to quickly and systematically identify structural \nlayouts of systems (or subsystems) and provide avenues for examining the \nsystem\u2019s interactions and quality evaluation within the operational system.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 239", "position": 239, "chunk_type": "semantic", "token_estimate": 123}
{"text": "216\u2002 \u2022\u2002 Software Engineering Design\ufeff: This chapter explores several well-established structural and behavioral design patterns \nand examines the problems they are designed to address, together with the benefits they \nprovide. Identifying and designing using these design patterns can improve the efficiency \nof the development process and the quality of the final system.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 240", "position": 240, "chunk_type": "semantic", "token_estimate": 52}
{"text": "Structural design patterns are patterns that deal with designing larger structures from: existing classes or objects at run time. They play a key role in the design and evolution of \nsystems by allowing integration of new designs with existing ones, via object \u00ad\ncomposition \n(i.e., object structural) or inheritance (i.e., class structural). Class structural design \u00ad\npatterns \nidentify the inheritance relationship necessary to create new interfaces or implementa-\ntions that may be compatible with the older design structure. Object structural patterns \nprovide the relationships required to create larger structures through object composition \nat run time, therefore providing more flexibility to extend the system at run time, which \nis impossible for class structural solutions. In both cases, by allowing designs to build on \nother existing structures, systems can be made interoperable by designing compatible \ninterfaces for otherwise incompatible systems. Structural design patterns have also signifi-\ncant impact on the reusability and modifiability of systems. Examples of structural design \npatterns include the adapter, composite, and facade.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 240", "position": 240, "chunk_type": "semantic", "token_estimate": 164}
{"text": "The adapter design pattern is a class/object structural design pattern used to adapt an exist-: ing interface to another interface that is expected in a software system. It can be designed \nas both class structural, in which the major composition relationships are defined at com-\npile time, and object structural, where structural object composition occurs at run time. In\u00a0 either case, the adapter design pattern allows systems with incompatible interfaces \nto work together, therefore increasing the reusability and evolution of software systems. According to the Gang of Four (Gamma, Elm, Johnson, and Vlissides 1995, p. 139), the \nintent of the adapter is to\nConvert the interface of a class into another interface clients expect. Adapter lets classes work \ntogether that couldn\u2019t otherwise because of incompatible interfaces. Conceptually, adapters are used everywhere. For example, electrical adapters can \nbe used to connect devices with incompatible interfaces, such as European plugs and \nAmerican sockets. In gardening, adapters are used to connect water hoses with", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 240", "position": 240, "chunk_type": "semantic", "token_estimate": 161}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 217: incompatible interfaces to extend their reach. In computer hardware, adapters are used \nto covert between many different interfaces, such as serial to Universal Serial Bus (USB). In software, the adapter concept is applied similar to adapters in the previous examples. Consider the graphical user interface (GUI) for an application to monitor and control \na satellite communication system composed of several independent hardware devices. For each hardware device, complex GUI screens are designed to monitor and con-\ntrol each device. All screens rely on a class, named HardwareDevice, that provides \nmethods\u00ad\n (e.g., string getStatusA(), string getStatusB()) designed and developed assuming \nthat commands and status for each device use the string type (in C++). When receiv-\ning the hardware devices from their manufacturers and the binary compiled library \nthat provides monitor and control capabilities for each device, it is noticed that the class \nManufacturerHardwareDevice (provided by the manufacturer) provides all func-\ntions for command and control using the char* type or other nonstring type, which \ncreates an incompatible interface between the existing GUI code and the library code. Since the code inside the library cannot be changed and changing the code for all screens \n(\u00ad\ndepending on the number of screens) may be impractical, the provided class in the binary \nlibrary can be adapted using the adapter design pattern to fit the expected interfaces in \nthe GUI software or vice versa. Problem\nConsider the completed gaming system discussed in Chapter 5, which includes the \ndesign and development for all 10 levels of a gaming system, including the design and \nimplementation of all gaming characters. At each level, the core of the gaming system \n(i.e.,\u00a0 GameEngine) uses the Character interface to add enemy characters to the game, \nmaking them move, defend, and attack using the move(), defend(), and attack() \ninterface methods, respectively. Each character in the game implements the Character \ninterface to provide specific behavior appropriate for the character and the level of the \ngame. That is, depending on the character and the game level, the behavior for moving, \ndefending, and attacking varies among characters. An online character developer has \ncreated a special character that is compatible with the game development\u2019s application \nprogramming interface (API) but not with the particular Character interface; that is, \nthe special character designed by the online developer includes the following interface \nmethods: specialMove(), \u00ad\nspecialAttack(), and specialDefend().", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 241", "position": 241, "chunk_type": "semantic", "token_estimate": 398}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 217: That is, depending on the character and the game level, the behavior for moving, \ndefending, and attacking varies among characters. An online character developer has \ncreated a special character that is compatible with the game development\u2019s application \nprogramming interface (API) but not with the particular Character interface; that is, \nthe special character designed by the online developer includes the following interface \nmethods: specialMove(), \u00ad\nspecialAttack(), and specialDefend(). The special \ncharacter is made available freely to the gaming community; however, the special charac-\nter code can be downloaded and incorporated into other gaming systems only as a binary \ncompiled library, which can be incorporated into the existing game. Since all levels of the \ngame are complete, it is impractical to change the code in all places to detect the new spe-\ncial character and make different calls for moving, attacking, and defending; therefore\u00ad\n, \nthe adapter design pattern is required to adapt the special character\u2019s interface to the \ncurrent\u00ad\n character interface.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 241", "position": 241, "chunk_type": "semantic", "token_estimate": 169}
{"text": "218\u2002 \u2022\u2002 Software Engineering Design\ufeff: Client\n+request()\nTarget\nClient\n+request()\nTarget\nGameEngine\n+attack(): void\n+defend() : void\n+move(): void\n<<interface>>\nCharacter\n+request()\nAdapter\n+speci\ufb01cRequest()\nAdaptee\n+request()\nAdapter\n+speci\ufb01cRequest()\nGeneral Class\nStructural View\nGeneral Object\nStructural View\nApplied Object\nStructural View\nAdaptee\n+attack(): void\n+defend(): void\n+move(): void\nCharacterAdapter\n+borrowedAttack(): void\n+borrowedDefend(): void\n+borrowedMove(): void\n<<interface>>\nBorrowedCharacter\n+borrowedAttack(): void\n+borrowedDefend(): void\n+borrowedMove(): void\nConcreteBorrowedCharacter\nFIGURE 7.1\nUML class diagram for the class/object structural adapter design pattern.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 242", "position": 242, "chunk_type": "semantic", "token_estimate": 75}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 219: Structure\nThe general and applied structure of the adapter design pattern is presented in Figure\u00a07.1. As seen, the adapter can be designed using multiple inheritance or object composition. In the multiple inheritance version, the pattern\u2019s relationships between classes and sub-\nclasses are defined at compile time, via inheritance; therefore, this version is classified as \nclass structural. When the adapter design pattern is designed using object composition, \nobject relationships are defined at run time; therefore, the adapter design pattern in this \ncase is classified as object structural. The object structural version of the adapter design \npattern results in a more dynamic and flexible design; therefore, it is the recommended \nand followed approach for the gaming system. The step-by-step approach for designing the \nobject structural adapter design pattern is presented as follows:\n\t\n1. Identify the source and destination interfaces that need adapting in the new system \n(e.g., target and adaptee or character and SpecialCharacter). 2. Add a new class (e.g., adapter or AdaptedCharacter) in the design that realizes the \ntarget interface and implements it in terms of the adaptee\u2019s implementation. This \nrequires a realization relationship between the adapter and target, and an association \nbetween the adapter and the adaptee. 3. In the new system, whenever objects that share the target interface are expected, \nit\u00a0can now be possible to use the adapter objects created in Step 2. The driving forces for applying the adapter design pattern are reusability and integration \nof code between two mature software structures. Under these conditions, changing the \ncode to match either of the two software entities is impractical. Furthermore, access to the \ncode for either software entity may not be possible; therefore, to reuse and integrate code \nfrom one entity to the other, the adapter is required. When this is the case, the adapter \ndesign pattern is easily applied by creating an adapter class that inherits from the target \nclass. By incorporating new adapter objects that share the Target interface, clients can use \nthem the same way they used original Target objects; however, these new adapter objects \nimplement the Target functions in terms of the Adaptee, which is the object providing the \nnew functionality under a different, incompatible interface. Implementation\nThe implementation of the object structural adapter design pattern simply requires the \ncreation of one class with two relationships\u2014realization and association.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 243", "position": 243, "chunk_type": "semantic", "token_estimate": 394}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 219: By incorporating new adapter objects that share the Target interface, clients can use \nthem the same way they used original Target objects; however, these new adapter objects \nimplement the Target functions in terms of the Adaptee, which is the object providing the \nnew functionality under a different, incompatible interface. Implementation\nThe implementation of the object structural adapter design pattern simply requires the \ncreation of one class with two relationships\u2014realization and association. In practical \napplications, the Target and Adaptee classes are typically part of larger mature and sable \nsoftware structures. In this example, the Target and Adaptee classes are represented by the \nCharacter and BorrowedCharacter classes, as seen in Listings 7.1 and 7.2.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 243", "position": 243, "chunk_type": "semantic", "token_estimate": 121}
{"text": "220\u2002 \u2022\u2002 Software Engineering Design\ufeff: As seen, the interfaces for the Character and BorrowedCharacters are different\u00ad\n; \ntherefore, client code that expects objects with the Character interface cannot accept \nobjects with the BorrowedCharacter interface even though conceptually, both objects do \nthe same operations. To allow the existing code to process objects of the borrowed charac-\nter type as if they were objects of the character type, a CharacterAdapter is required, \nas seen in Listing 7.3. Listing 7.1: C++ Code for the Character Interface\n// The Target class. class Character {\npublic:\n\t // Interface method for attack functionality. virtual void attack() = 0;\n\t // Interface method for defend functionality. virtual void defend() = 0;\n\t // Interface method for moving functionality. virtual void move() = 0;\n};\nListing 7.2: C++ Code for the BorrowedCharacter \nInterface and ConcreteBorrowedCharacter\n// Interface for the borrowed character. class BorrowedCharacter {\npublic:\n\t // Interface methods for the borrowed character. virtual void borrowedAttack() = 0;\n\t virtual void borrowedDefend() = 0;\n\t virtual void borrowedMove() = 0;\n};\n// Concrete borrowed character. class ConcreteBorrowedCharacter : public BorrowedCharacter {\npublic:\n\t // Implementations for the BorrowedCharacter interface methods. void borrowedAttack() { /* attack code here... */}\n\t void borrowedDefend() { /* defense code here... */}\n\t void borrowedMove() { /* code to move here... */}\n};", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 244", "position": 244, "chunk_type": "semantic", "token_estimate": 212}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 221: As seen, the CharacterAdapter inherits from the Character to implement the \nrealization relationship in C++. It is also associated with the BorrowedCharacter class \nvia member attribute. To finalize the object adaptation, the newly created character adapter \ntype is required to implement all interface methods defined by the character interface in \nterms of the associated borrowed character, as seen in Listing 7.4. Once the adapter design pattern is applied, it is easy to use borrowed characters in the \ngaming system. Consider the method presented in Listing 7.5 for triggering character \nbehavior in the GameEngine class. As seen, this and other methods defined in the GameEngine class can now employ the \nadapter design pattern to accept character objects that comply with the character interface \nbut provide behavior from the borrowed character. An example of client code used to acti-\nvate a borrowed character in the gaming system is presented in Listing 7.6. As seen, the \nborrowed character is created and passed into the character adapter during its initialization \nthrough the constructor. From this point forward, the adapted character is used instead of \nthe borrowed character to provide the new features to the game. Benefits\n\u2022\t Allows classes with incompatible interfaces to work together, therefore increasing \nreusability and ease of code integration\n\u2022\t Provides a standard way for integrating a plurality of different types to existing software\nListing 7.3: C++ Header File for the CharacterAdapter Class\n// Forward reference. class BorrowedCharacter;\nclass CharacterAdapter : public Character {\npublic:\n\t // Constructor. CharacterAdapter(BorrowedCharacter* pCharacter);\n\t // Adapt the attack method. void attack(void);\n\t // Adapt the defend method. void defend(void);\n\t // Adapt the move method. void move(void);\nprivate:\n\t // BorrowedCharacter that needs adapting to the Character interface. BorrowedCharacter* _borrowedCharacter;\n};", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 245", "position": 245, "chunk_type": "semantic", "token_estimate": 292}
{"text": "222\u2002 \u2022\u2002 Software Engineering Design\ufeff: Skill Development 7.1: Adapter Design Pattern\nUsing the Unified Modeling Language (UML) tool of choice, replicate the UML \nmodel presented in Figure\u00a07.1 and generate code from the model. Using the Integrated \nDevelopment Environment (IDE) of choice, fill in the gaps in the code generated using \nListings 7.1 through 7.6, and compile and execute the software. Create two additional \nclasses: one that derives from the character class in which its methods are implemented \nto simply display some output to the console; and another adapter class that adapts \nanother character with different interface methods for attacking, defending, and mov-\ning (e.g., slowAttack, slowDefend, and slowMove). Use the triggeredAction \nmethod to pass in (one at a time) objects of all the types created. Observe how the trig-\ngeredAction method accepts both objects of the original character interface and the new \nadapted objects (since they now all share the character interface). How does the adapter \ndesign pattern increase reusability, maintainability, and modifiability in such system? Listing 7.4: C++ Source File for the CharacterAdapter Class\n#include \u201cCharacterAdapter.h\u201d\n#include \u201cBorrowedCharacter.h\u201d\n// Constructor. CharacterAdapter::CharacterAdapter(BorrowedCharacter* pCharacter) {\n\t // For simplicity, assume a valid pointer. _borrowedCharacter = pCharacter;\n}\n// Adapt the attack method. void CharacterAdapter::attack() {\n\t // Implement the attack functionality in terms of the\n\t // BorrowedCharacter. _borrowedCharacter->borrowedAttack();\n}\n// Adapt the defend method. void CharacterAdapter::CharacterAdapter::defend() {\n\t // Implement the defend functionality in terms of the\n\t // BorrowedCharacter. _borrowedCharacter->borrowedDefend();\n}\n// Adapt the move method. void CharacterAdapter::move() {\n\t // Implement the move functionality in terms of the\n\t // BorrowedCharacter. _borrowedCharacter->borrowedMove();\n}", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 246", "position": 246, "chunk_type": "semantic", "token_estimate": 259}
{"text": "Section: Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 223", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 247", "position": 247, "chunk_type": "semantic", "token_estimate": 10}
{"text": "The composite design pattern is an object structural pattern that allows designers to: compose (large) tree-like design structures by strategically structuring objects that share \na whole\u2013part relationship. Whole\u2013part relationships are those in which a larger entity \n(i.e.,\u00a0the whole) is created by the composition of smaller entities (i.e., the parts). The key \nListing 7.5: C++ Code for the GameEngine\u00a0Method \nto Trigger a Character\u2019s Actions\nclass GameEngine {\npublic:\n\t // ...\n\t // Method to activate a character. void GameEngine::triggeredAction(Character* pCharacter) {\n\t // Activate the character and make it move randomly for a short\n\t // time. pCharacter->move();\n\t // Once the character stops moving, if being attacked, defend! pCharacter->defend();\n\t // Once the characters stops defending, if others characters are\n\t // detected, attack! pCharacter->attack();\n\t }\n\t // ...\n};\nListing 7.6: C++ Code for Client Code in the Gaming\u00a0System \nto Activate a Borrowed Character\n// Instantiate the game engine. GameEngine engine;\n// Create the borrowed character that needs adapting. ConcreteBorrowedCharacter borrowedCharacter;\n// Create the character adapter and pass in the borrowed character. // From this point on, the adapterCharacter object can be used\n// throughout the game engine as if it were a Character! CharacterAdapter adaptedCharacter(&borrowedCharacter);\n// Move, attack, and defend with the borrowed character\u2019s features! engine.triggeredAction(&adaptedCharacter);", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 247", "position": 247, "chunk_type": "semantic", "token_estimate": 204}
{"text": "224\u2002 \u2022\u2002 Software Engineering Design\ufeff: advantage of using the composite design pattern is that it provides a design structure that \nallows both whole and part objects to be treated uniformly; therefore, operations that are \ncommon to both type of objects can be applied the same way to both types of objects. According to the Gang of Four (Gamma et al. 1995, p. 163), the intent of the composite is\u00a0to\nCompose objects into tree structures to represent part-whole hierarchies. Composite lets \n\u00ad\nclients treat individual objects and composites of objects uniformly. Many situations exist that require objects to be composed of many parts. However, in \nsome specific instances, some problems require both objects and their parts to be treated \nuniformly. In the software domain, perhaps the most common example is seen in modern \nuser interfaces, which contain both Menu and MenuItem objects. A Menu, in the graphical \nuser interface context, is a mechanism of the software that allows users to select and activate \nfeatures of the system. A Menu can also provide access to other Menus or MenuItems that \ncan be selected to trigger software execution. Both Menu and MenuItem may contain func-\ntions to change their visible text, size, and background color or to handle events. Therefore, \nboth must be treated uniformly. In this case, the composite design pattern can be used to \ncreate a flexible design structure that groups both Menu and MenuItems, that provides easy \naddition and removal of both Menu and MenuItems to the design structure, and that pro-\nvides a uniform interface so that operations common to both can be easily performed using \nthe composite interface. Although the composite design pattern is prevalent in examples \nsuch as this, its application can be found in numerous practical applications. Problem\nA wireless sensor system is remotely deployed to collect environmental information. The \nsensor system communicates via satellite to a central location, where a schedule of tasks \n(i.e., a mission plan) is created and sent over satellite communications. A mission plan is a \ncomposite message that contains one or more messages that command the sensor \u00ad\nsystem \nto perform particular tasks. These messages contain information on how and when to per-\nform particular tasks. Mission plan messages can be created with many different com-\nbinations of messages.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 248", "position": 248, "chunk_type": "semantic", "token_estimate": 379}
{"text": "224\u2002 \u2022\u2002 Software Engineering Design\ufeff: These messages contain information on how and when to per-\nform particular tasks. Mission plan messages can be created with many different com-\nbinations of messages. Upon creating the mission plan message, it is sent to the wireless \nsensor system, which retrieves each message and message information from the mission \nplan and executes them to collect environmental data, store it, and send it back to the \ncentral location, as directed by the mission plan message. The sensor system is extensible \nand contains many capabilities provided by numerous sensors (e.g., temperature, vibra-\ntion), still-shot camera, and video recording. To operate the sensor system, the operators at \nthe central location are requesting a message generator capable of allowing them to easily \ncreate a mission plan message. The mission plan message may contain both primitive and \ncomposite messages. Numerous mission plan messages can be created to support different \n\u201cmissions,\u201d and it is expected that more sensing capabilities will be added in the future. Therefore, the design of the message generator must provide easy addition and removal of", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 248", "position": 248, "chunk_type": "semantic", "token_estimate": 179}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 225: both \u00ad\nmessages and composite messages to a mission plan. A graphical representation of the \nmessage generator is presented in Figure\u00a07.2. As seen, the topmost composite message represents the mission plan message (or schedule). The message generator provides a series of menu items that allows operators to select a par-\nticular message, to configure its parameters, and to add it to the mission plan message. In this \nexample, Message 3 is a composite message that can be configured to contain Messages\u00a05, 6, \nand 7. Message 3 can also be configured individually and added to the mission plan. Both \nprimitive and composite messages need to be treated uniformly, so that methods such as \ngetId(), setId(), and toXml\n() can be supported by both types of messages. Structure\nThe general and applied structure of the composite design pattern is presented in Figure\u00a07.3. As seen, the general structure of the composite design pattern requires three main classes, \nthe Composite, Leaf, and Component classes. The Component class defines the operations \nthat are common to both Composite and Leaf objects, for example, print\n(), toXml\n(), \ngetId(), setId(), etc., as shown in the Applied View portion of Figure\u00a07.3. The com-\nponent class also defines the methods specific to support the composite design pattern, \nnamely, the add() and remove() methods. The add and remove methods are intended \nfor use by composite objects and not by leaf objects; therefore, they must be specified as \noverridable methods with default implementation that indicates an unsupported operation. Composite\nMessage\nMessage\nComposite\nMessage\nMessage\nMessage\nMessage\nMessage\nMessage\nParam1:\nInclude Message\nMessage 3\nMessage 5\nMessagesMenu\nMessage 1\nMessage 2\nMessage 3\nMessage 4\nMessage 5\nMessage 6\nMessage 7\nParam2:\nParam3:\nFIGURE 7.2\nMessage generator graphical user interface concept.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 249", "position": 249, "chunk_type": "semantic", "token_estimate": 302}
{"text": "226\u2002 \u2022\u2002 Software Engineering Design\ufeff: This means that if at any point during run time a leaf object is called upon to add or remove \nobjects to the hierarchy, the default implementation for these methods is executed to reflect \nthe unsupported requests. In many cases, a good alternative for the default implementation \ninvolves writing code that throws exceptions within the add and remove methods. On\u00a0the \nother hand, composite objects that derive from the component base class are required to \noverride the default implementation so that objects can be added and removed from the \nhierarchy. This way, when composite objects are bound dynamically at run time to a ref-\nerence of the component type, the appropriate code for adding and removing objects is \ncalled, preventing the default implementation from being executed. The steps required to \napply the composite design pattern include\n\t\n1. Identify, understand, and plan the tree-like structure required for the system. 2. With the knowledge from Step 1, identify and design the component base class, \nwhich includes overridable methods common to both leaf and composite objects as \nwell as methods specific to composite objects, which provide capability for adding \nand removing objects to the hierarchy. +operation()\n+add(param1 : Component)\n+remove(param1: Component)\n+getChild(int)\nClient\nLeaf\nComponent\n+operation()\n+add(param1 : Component)\n+remove(param1: Component)\n+getChild(int)\n+operation()\nVideoControlMessage\nMessageGenerator\nGeneral View\nApplied View\nComposite\n+getId(: void): int\n+getName(: void): string\n+setId(id: int): void\n+setName(name: string): void\n+add(message : Message*): void\n+print(: void): void\n+toXml(): string\n+clone(): Message*\n+setFrameRate(framesPerSecond: int): void\n+toXml(): string\n+clone(): Message*\nSelfTestMessage\n+toXml(): string\n+clone(): Message*\nCompositeMessage\n+CompositeMessage(other : const CompositeMessage&)\n+CompositeMessage(name : string)\n+add(message : Message*): void\n+print(): void\n+toXml(): string\n+clone(): Message*\n\u2013messages_: list<Message*>\n\u2013id_: int\n\u2013name_: string\nMessage\nFIGURE 7.3\nUML class diagram for the composite design pattern.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 250", "position": 250, "chunk_type": "semantic", "token_estimate": 292}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 227: 3. For the methods specified in Step 2 for adding and removing objects to the hierarchy, \nimplement default behavior that if not overridden will result in an exception or error \nmessage indicating an unsupported operation. 4. Identify and design the composite class, which overrides methods for adding and \nremoving objects to the hierarchy. The composite class requires an internal data \nstructure to store leaf nodes added to the hierarchy. In addition, the composite class is \nrequired to override all other operational methods identified in Step 2 to implement \nfunctionality in terms of the composite object and all of its contained leaf objects. 5. Identify and design the leaf class, which overrides operational methods specified in \nStep 2 to implement behavior in terms of the leaf object. Leaf objects do not override \nthe add and remove methods identified in Step 2. 6. Identify and design the client that uses both composite and leaf objects. In the message generator example, add() and remove() are used to add and remove \nboth CompositeMessage and all other derived messages to the design structure \n(e.g.,\u00a0VideoControlMessage, SelfTestMessage). Therefore, to support the addi-\ntion of new messages that provide control of future sensing capabilities, a new class that \nderives from the Message base class needs to be added to the message generator design. In addition, to support easy duplication of both types of messages, the prototype design \npattern is incorporated into the message generator design so that message copies can be \neasily created throughout the application. This is reflected in the design with the addition \nof the clone() method to the Message class. The driving forces behind the design include the ability to treat both individual messages \nand mission plan messages uniformly, so that the complexity of client code is minimized. The composite design pattern is also chosen to achieve design flexibility so that new mes-\nsages can be created easily to support future systems\u2019 demands. The most influential step \nwhen applying the composite design pattern is the addition of the add() method in the \nComponent base class. Once this method is created, composite objects override it to store \nthe primitive objects contained by it. Implementation\nMost of the implementation work for the composite design pattern takes place in both \nthe component and composite classes, which are represented in the message generator by \nthe Message and CompositeMessage classes.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 251", "position": 251, "chunk_type": "semantic", "token_estimate": 400}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 227: Once this method is created, composite objects override it to store \nthe primitive objects contained by it. Implementation\nMost of the implementation work for the composite design pattern takes place in both \nthe component and composite classes, which are represented in the message generator by \nthe Message and CompositeMessage classes. Once these are created, other message \nclasses that share the same Message interface can be added easily by deriving from the \nMessage class. The implementation for the Message class is presented in Listing 7.7. As seen, the toXml\n() and clone() methods are incorporated in the Message type \ninterface. These methods are application specific and are not related to the composite \ndesign pattern. The toXml\n() method is added to enforce the policy that all messages in \nthe system are required to provide implementation appropriate to convert the particular \nmessage data into Extensible Markup Language (XML) format. Other application-specific \nmethods include the getId(), setId(), getName(), and setName().", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 251", "position": 251, "chunk_type": "semantic", "token_estimate": 166}
{"text": "228\u2002 \u2022\u2002 Software Engineering Design\ufeff: The add(Message*) method is specific to the composite design pattern. Specifically, it \ngives composite classes the ability to add messages to their structure so that the whole\u2013part \nrelationship can be realized. Because this method is intended specifically for composite \nclasses, it violates the Liskov substitution principle presented in Chapter 5. However, it pro-\nvides the functionality necessary to support efficient solution to the problem; therefore, its \nusage can be easily justified during design reviews. To minimize the effects of this viola-\ntion, careful attention needs to be paid when implementing the default behavior of the \nadd(Message*) method in the Message base class. The easiest solution is to provide a base \nimplementation that notifies the operator stating that the operation is not supported. That \nway, derived classes that do not support the add method would simply inherit the default \nListing 7.7: C++ Header File for the Message Class\nclass Message {\npublic:\n\t // Method to retrieve the message\u2019s id. int getId() const;\n\t // Method to retrieve the message\u2019s name. string getName() const;\n\t // Method to set the message\u2019s id. void setId(int id);\n\t // Method to set the message\u2019s name. void setName(string name);\n\t // Method to add messages to a composite message. virtual void add(Message* message);\n\t // Method to display messages to the console. virtual void print();\n\t // Method to transform the contents of this message to XML format. virtual string toXml() = 0;\n\t // Duplicate Messages using the prototype design pattern. virtual Message* clone() = 0;\nprivate:\n\t // The message\u2019s id. int _id;\n\t // The message\u2019s name. string _name;\n};", "domains": ["Design Patterns", "Design Principles"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 252", "position": 252, "chunk_type": "semantic", "token_estimate": 264}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 229: implementation. A more sophisticated approach includes writing code that throws an excep-\ntion indicating that the operation is not supported. This way, calls to the add(Message*) \nmethod from leaf classes will result in exceptions that can explicitly notify developers of \nthis unsupported operation. The default implementation for both the add() and print\n() \nmethods is presented in Listing 7.8. Notice that the print method can be defined in the \nMessage base class to display the message\u2019s information. This implementation is appropri-\nate for leaf objects but not for composite objects; therefore, leaf objects can inherit this \nimplementation without further changes. The main difference between the CompositeMessage class and all other messages in \nthe design is that the operations of the CompositeMessage need to support its \u00ad\ncontained \nmessages. For example, the print\n() method needs to display the information of the com-\nposite message and all of its contained messages. Similarly, the CompositeMessage \nclass needs to override the add(), toXml\n(), and clone() methods to appropriately sup-\nport all of its contained objects. The CompositeMessage class is specified in Listing 7.9. To support the addition of primitive messages in the composite structure, a C++ \n\u00ad\ntemplate list is used, so the implementation of the add(Message*) method simply pushes \n\u00ad\nmessages to the back of the list. By using a list, implementing the print\n() method is made \neasy since all it has to do is iterate through the list and call each of the message object\u2019s \nprint\n() methods, as displayed in Listing 7.10. Primitive objects of the message type are created by deriving from the Message base class \nand implementing all other application-specific required methods. For example, the video \nListing 7.8: C++ Implementation for the Add() and \nPrint() Methods of the Message Class\n#include \u201cMessage.h\u201d\n#include <string>\n#include <iostream>\n// Method to add messages to a composite message. void Message::add(Message* message) {\n\t // The default implementation lets clients know that the operation\n\t // is unsupported. This behavior is inherited by Leaf classes, but\n\t // overridden by Composite classes. std::cout<<\u201dMessages cannot be added to Leaf objects!\\n\u201d;\n}\n// Method to display messages to the console. void Message::print(void) {\n\t // The default behavior for displaying a message\u2019s information. // This behavior is inherited by Leaf classes, but overridden by\n\t // Composite classes. std::cout<<\u201dMessage \u201c<<_name.c_str()<<\u201d, Id: \u201c<<_id<<endl;\n}", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 253", "position": 253, "chunk_type": "semantic", "token_estimate": 395}
{"text": "230\u2002 \u2022\u2002 Software Engineering Design\ufeff: control message for the system is required to provide implementation for required toXml() and \nclone() methods and all other methods required to execute video control messages, such as the \nsetFrameRate() method. An example of the VideoControlMessage implementation \nis presented in Listing 7.11. In similar fashion, all other messages in the system are created. Once the CompositeMessage and primitive messages are designed and implemented, \nthe client message generator can be implemented, as seen in Listing 7.12. As seen, by using the composite design patterns message hierarchies containing both \nprimitive and composite objects can be created easily simply by adding objects to the com-\nposite objects via the add() interface method. For example, the \u00ad\npowerOnMessage, \n\u00ad\nselfTestMessage, and transmitStatusMessage, all sharing the Message \ninterface, are added to the composite message initializeTaskingMessage, \nListing 7.9: C++ Header File for the CompositeMessage Class\n#include <list>\n#include \u201cMessage.h\u201d\nclass CompositeMessage : public Message {\npublic:\n\t // Copy constructor. CompositeMessage(const CompositeMessage& other);\n\t // Overloaded constructor to set the message\u2019s name. CompositeMessage(string name);\n\t // Destructor to clean up memory for messages in _message. virtual ~CompositeMessage();\n\t // Method to add messages to this Composite Message. void add(Message* message);\n\t // Override the print method to display all messages in _message. virtual void print();\n\t // Method to transform the contents of this message to XML format. string Message::toXml();\n\t // Create a duplicate of the Composite Message using the prototype\n\t // design pattern. Message* clone();\nprivate:\n\t // The Messages that make up the Composite Message. list<Message*> _messages;\n};", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 254", "position": 254, "chunk_type": "semantic", "token_estimate": 252}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 231: which in turn is added to the composite message missionPlanMessage. Similarly, \n\u00ad\ncollectionMessage, which is a composite message, and shutdownMessage, which \nis a primitive message, are both added to the missionPlanMessage to create a full \n\u00ad\ncollection mission plan message. Once the whole message is created from its parts, the \n\u00ad\nmission plan message can be used to display its content and convert all messages contained \nin the missionPlanMessage to XML before being sent out via the communication link. The\u00a0sample output for the code in Listing 7.12 is presented in Listing 7.13. Benefits\n\u2022\t Provides a design structure that supports both composite and primitive objects\n\u2022\t Minimizes complexity on clients by shielding them from knowing the operational \ndifferences between primitive and composite objects; clients that expect a primitive \nobject will also work with a composite object, since operations are called uniformly \non both primitive and composite objects\n\u2022\t Easy to create and add new component objects to applications\nListing 7.10: C++ Implementation of the Composite\u2019s \nAdd() and Print() Methods\n// Add a message to the collection of messages in the Composite\n// Message. void CompositeMessage::add(Message* message) {\n\t // Add this message. _messages.push_back(message);\n}\nvoid CompositeMessage::print() {\n\t // Display the Composite Message\u2019s name and id. cout<<\u201d\\nComposite Message: \u201c<<getName().c_str()\n\t \t\n<<\u201d, Id: \u201c<<getId()<<endl;\n\t // Retrieve an iterator for the _messages collection. list<Message*>::iterator pIter = _messages.begin();\n\t // Iterate through the messages that make up this composite\n\t // message and display their info. for( unsigned int i = 0; i < _messages.size(); i++ ) {\n\t \t // Display the message\u2019s information and move the iterator to\n\t \t // the next position. (*pIter++)->print();\n\t }\n}", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 255", "position": 255, "chunk_type": "semantic", "token_estimate": 277}
{"text": "The facade design pattern is an object structural pattern that provides a simplified inter-: face to complex subsystems. By providing a simplified interface, the facade design pattern \nprovides a higher level of abstraction that liberates clients from the responsibility of know-\ning the internal structure of various elements of the subsystem, which in turn reduces \ncoupling and simplifies client code. Facade also shields clients from changes that occur \nin the subsystem; by having a standardized facade interface, the internal structure of the \nsubsystem can vary without affecting clients. According to the Gang of Four (Gamma \net\u00a0al. 1995, p. 185), the intent of the facade design pattern is to\nProvide a unified to a set of interfaces in a subsystem. Facade defines a higher-level interface \nthat makes the subsystem easier to use. In most practical applications, components or subsystems are created to abstract a \ncomplex behavior that the system must provide. In these cases, executing a complex \nListing 7.11: C++ Header File for the VideoControlMessage Leaf Class\n#include \u201cMessage.h\u201d\nclass VideoControlMessage : public Message\n{\npublic:\n\t // Constructor. VideoControlMessage(void);\n\t // Destructor. ~VideoControlMessage(void);\n\t // TODO: Specific video control methods. void setFrameRate(int framesPerSecond);\n\t // . // . // . // Method to transform the contents of this message to XML format. string toXml(void);\n\t // Duplicate the VideoControlMessage using the prototype design\n\t // pattern. Message* clone(void);\n};", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 256", "position": 256, "chunk_type": "semantic", "token_estimate": 224}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 233: Listing 7.12: C++ Implementation for the Message Generator and Sample Usage\n// Create the initialization primitive messages. PowerOnMessage powerOnMessage;\nSelfTestMessage selfTestMessage;\nTransmitStatusMessage transmitStatusMessage;\n// The message to task the system to initialize properly. CompositeMessage initializeTaskingMessage(\u201cInitialize System\u201d);\n// Add copies of the power on, self test, and transmit status messages\n// to the initialize tasking composite message. initializeTaskingMessage.add( powerOnMessage.clone() );\ninitializeTaskingMessage.add( selfTestMessage.clone() );\ninitializeTaskingMessage.add( transmitStatusMessage.clone() );\n// Collection Control Messages. TemperatureSensorControlMessage temperatureSensorControlMessage;\nVideoControlMessage videoControlMessage;\n// The message to task the system to collect information. CompositeMessage collectionMessage(\u201cInformation Collection\u201d);\n// Add the temp. sensor and video control messages to the collection\n// tasking composite message. collectionMessage.add( temperatureSensorControlMessage.clone() );\ncollectionMessage.add( videoControlMessage.clone() );\n// Shutdown Messages. ShutdownMessage shutdownMessage;\n// The message to task the system to complete Mission 1. CompositeMessage missionPlanMessage(\u201cMission 1 - Temperature\n\t\nand Video Collection\u201d);\n// Add the messages to the initialize, collection, and shutdown\n// messages to the mission plan composite message. missionPlanMessage.add( initializeTaskingMessage.clone() );\nmissionPlanMessage.add( collectionMessage.clone() );\nmissionPlanMessage.add( shutdownMessage.clone() );\n// Before sending message, verify its content. missionPlanMessage.print();\n// If content is valid, send the message through the system. Before\n// being sent out through the communication link, a call to\n// missionPlanMessage.toXml() is made to convert all of the\n// message\u2019s content to XML format.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 257", "position": 257, "chunk_type": "semantic", "token_estimate": 214}
{"text": "234\u2002 \u2022\u2002 Software Engineering Design\ufeff: subsystem behavior may require the combination of multiple function calls from multi\u00ad\nple component and subsystem elements. For example, consider a software component \nthat provides various elements and functionality for assessing the integrity of a particu-\nlar computer. This component may contain elements responsible for particular items of \n\u00ad\ninterests, such as a file system element, memory element, and communication element. In\u00a0this case, the facade design pattern can be used to abstract all elements in the sub\u00ad\nsystem by creating a method testSystem() that in turns calls upon the various elements of \nthe subsystem in the appropriate order to evaluate the integrity of the system. This allows \nclients to be associated only with the facade and relieves them from knowing the internals \nof the integrity assessment component. Problem\nConsider the sensor system described as part of the message generator in the previous \n\u00ad\nsection. Upon field deployment, it is desirable to test the system\u2019s capabilities to ensure \nthat the system works properly before engaging in autonomous operation. For this reason, \na graphical user interface is required to monitor and control the system in the field during \ninstallation. A conceptual diagram of both subsystems and their interactions is presented \nin Figure\u00a07.4. The sensor subsystem consists of the following elements: SystemManager, SerialComm, \nFileSystem, DataAnalyzer, and WirelessComm. A typical set of operations to assess the \nintegrity of the system would require clients to know about all subsystem elements\u2014for \nexample, opening the serial port, sending a collection message to the system manager, and \nopening the wireless communication link. This adds complexity to the developers of the UI \nsubsystem, since they are required to know the details of the sensor sub\u00ad\nsystem. In \u00ad\naddition, \nin many practical applications, the internals of subsystem are prone to change; therefore, \nListing 7.13: Sample Output for the Message Generator Problem\nComposite Message: Mission 1 - Temperature and Video Collection, Id: 20\nComposite Message: Initialize System, Id: 20\nMessage Power On Message, Id: 0\nMessage Self Test Message, Id: 1\nMessage Transmit Status Message, Id: 2\nComposite Message: Information Collection, Id: 20\nMessage Temperature Sensor Control Message, Id: 3\nMessage Video Control Message, Id: 4\nMessage Shutdown Message, Id: 5\nPress any key to continue . . .", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 258", "position": 258, "chunk_type": "semantic", "token_estimate": 376}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 235: clients relying on the internal of subsystems must keep up with changes throughout devel-\nopment and maintenance phases. The designers of the sensor system wants an easy solu-\ntion to shield UI subsystem developers from changes in the sensor subsystem\u2014one that \nallows developers of the sensor subsystem to identify and set interfaces for the visible \naspects of the sensor subsystem so that clients can rely on this interface, giving develop-\ners of the sensor subsystem the ability to change the internals of the subsystem without \naffecting clients. Structure\nThe general and applied structure of the facade design pattern is presented in Figure\u00a07.5. As seen, the facade provides functionality in terms of existing classes through a sim-\nplified interface. In most cases, a facade\u2019s functions will be implemented in terms of \nseveral\u00ad\n functions from different subsystem classes. This prevents clients from depending \non these internal subsystems; therefore, both complexity and dependencies on the client \nside are\u00a0reduced. Consider the set of operations required to retrieve sensor data, which may require open-\ning communication links, testing the connections, and scheduling a collection message. These operations require interfacing with several components within the sensor sub\u00ad\nsystem. In such cases, the UI subsystem is required to know the details required to carry out all of \nthese operations, which increases coupling and complexity of the UI. However, with the \nfacade design pattern, an interface method, named transmitSensorData(), can\u00a0be \nused to abstract all of the required operations to transmit sensor data, such as opening \nSerial\nComm. Msg In\nCon\ufb01gure\nMassages Out\nSystem Manager\nSensor Subsystem\nUser Interface Subsystem\nDecode\nExecute\nSend\nRecv\nSend\nRecv\nWireless\nComm. Con\ufb01gure\nRead\nData Out\nWrite\nData In\nFile System\nData Analyzer\nFIGURE 7.4\nConceptual diagram of wireless sensor system.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 259", "position": 259, "chunk_type": "semantic", "token_estimate": 300}
{"text": "236\u2002 \u2022\u2002 Software Engineering Design\ufeff: the serial connection, opening the wireless connection, testing both connections, and \n\u00ad\nscheduling a collection message. A step-by-step procedure for applying the facade design \npattern includes\n\t\n1. Identify all components involved in carrying out a subsystem operation. 2. Create an ordered list of the operations required to execute the subsystem operation. 3. Design a facade class that includes an interface method to carry out the subsystem \noperation. The facade class has dependencies to all other subsystem components \nrequired to carry out the subsystem operation. 4. Implement the facade interface method by calling operations on one or more sub\u00ad\nsystem components, in the order identified in Step 2. 5. Allow one or more clients to access the objects of the facade type so that they can gain \naccess to the subsystem operation. This creates a many-to-one relationship between \nexternal subsystems and the facade interface instead of many-to-many relationships. The driving forces behind the facade are simplicity of client code and lower coupling. The facade design pattern can be simply applied by creating an additional facade class \nthat provides simple functions summarizing the major external functions expected and \nrequired by clients. Client\nSubsystemClassA\nSubsystemClassB\nSubsystemClassC\nFacade\nSensorSystem\n+simpli\ufb01edInterface()\nSerialComm\nSystemManager\nFileSystem\nDataAnalyzer\nWirelessComm\nclient\n+enableSensor(sensorNum: int): void\n+enableAllSensors(): void\n+disableSensor(sensorNum: int): void\n+disableAllSensor(): void\n+transmitSensorData(sensorNum: int): void\n+transmitAllSensorData(): void\n+scheduleCollection(): void\nApplied View\nGeneral View\nFIGURE 7.5\nUML class diagram for the facade design pattern.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 260", "position": 260, "chunk_type": "semantic", "token_estimate": 238}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 237: Implementation\nImplementing the facade design pattern is straightforward, since it simply provides behav-\nior in terms of other subsystems. An example facade method for transmitting sensor data \nis presented in Listing 7.14. As seen, many of the complexities associated with using the \nsubsystem elements are hidden by the facade. By depending only on the facade, clients are \nshielded from unnecessary details required to perform the operation. Listing 7.14: C++ Implementation of One Method of the SensorSystem Facade\nvoid SensorSystem::transmitSensorData(int sensorNumber) {\n\t // Create an object for serial communications parameters. SerialParams params;\n\t params.setCommPort( SerialParams::COM_1 );\n\t params.setBaudRate( SerialParams::BR_9600 );\n\t params.setParity( SerialParams::PARITY_NO_PARITY );\n\t params.setByteSize( SerialParams::BYTE_SIZE_8 );\n\t params.setStopBits( SerialParams::STOP_BIT_ONE );\n\t // Retrieve pointer to the serial communication object. SerialComm* pSerialComm = SerialComm::getInstance();\n\t // Open the serial communication with the specified parameters. if( serialComm->open(params) ) {\n\t \t // Ready to communicate with collection nodes, now get ready for\n\t \t // transmitting the data via the wireless link. TcpConnection* pConnection = TcpConnection::getInstance();\n\t \t if( pConnection->open(TcpConnection::PORT_NUMBER,\n\t \t\nTcpConnection::IP_ADDRESS) ) {\n\t \t \t // Schedule a collection message. SystemManager::getInstance()->scheduleMessage(/*...*/);\n\t \t }\n\t \t else {\n\t \t \t // Log TCP error here. // Close serial connection.\n\t \t } // end if( pConnection->open(...)\n\t }\n\t else {\n\t \t // Log serial connection error here.\n\t } // end if( serialComm->open(...)\n} // end transmitSensorData function.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 261", "position": 261, "chunk_type": "semantic", "token_estimate": 210}
{"text": "238\u2002 \u2022\u2002 Software Engineering Design\ufeff: Benefits\n\u2022\t Shields clients from knowing the internals of complex subsystem, therefore minimiz-\ning complexity in clients\n\u2022\t Since the internals of the subsystem are prone to change, provides a stable interface \nthat hides changes to internal subsystems, therefore making client code more stable\n\u2022\t Promotes weak coupling on clients; clients depend on only one interface instead of \nmultiple interfaces", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 262", "position": 262, "chunk_type": "semantic", "token_estimate": 65}
{"text": "Behavioral design patterns deal with encapsulating behavior with objects, assigning: responsibility, and managing object cooperation when achieving common tasks (Gamma \net al. 1995). Behavioral design patterns include many of the mainstream design patterns \nused in modern object-oriented frameworks and play a key role in the design of systems \nby making them independent of specific behavior, which is made replaceable with objects \nthroughout these design patterns. Therefore, parts of the system responsible for perform-\ning some algorithm or behavior do so by relying on a common interface without knowl-\nedge of how the actual behavior or algorithm is carried out. In addition, by controlling the \nbehavioral process with common interfaces, enforcing behavioral policies becomes easier, \ntherefore giving systems the ability to create algorithms that share a common interface \nbut that vary widely in behavior. Examples of behavioral patterns include the iterator and \nthe\u00a0observer.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 262", "position": 262, "chunk_type": "semantic", "token_estimate": 143}
{"text": "The iterator design pattern is an object behavioral pattern that provides a standardized way: for accessing and traversing objects in a collection data structure. A collection data struc-\nture may consist of arrays, vectors, lists, or other custom-designed structures. The iterator \ndesign pattern works by abstracting the way each specific collection structure operates on \nthe data so that clients are not required to have knowledge of the details of their internal \nstructure. According to the Gang of Four (Gamma et al. 1995, p. 257), the intent of the \niterator design pattern is to\nProvide a way to access the elements of an aggregate object sequentially without exposing its \nunderlying representation. By providing a standard interface and encapsulated methodology for accessing elements \nof a collection structure, client code becomes more consistent and easier to maintain, since", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 262", "position": 262, "chunk_type": "semantic", "token_estimate": 135}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 239: changing the internal structure of the data collection structure does not affect the way \nclient code interacts with the structure. Iterators are prevalent in software engineering; \ntheir presence can be found built-in in today\u2019s most common programming languages and \nframeworks, such as C++, Java, and the .NET framework. Problem\nA company\u2019s software system manages inventory, financials, and all other information \navailable from its two store branches. Each store carries specific computer products appro-\npriate for its location\u2019s demographics. During design, the software system is decomposed \ninto several components, including two components for deferring and abstracting design \ninformation relevant to requirements for each computer store branch. The detailed design \nof each component is carried out separately by two different software engineers; this \nresults in two different versions of data structures for managing and providing store prod-\nuct information. Now, anytime the software system is called upon to display information \nabout store products, it is required to identify between the two store branches so that the \ncorrect implementation for accessing store information can be executed. This problem is \nencountered every time a new computer store branch is added to the system; therefore, \na\u00a0uniform and standardized method for accessing computer store products from different \ncollection data structures is highly desirable. Consider the existing ComputerProduct \ncode for the store\u2019s software system, as presented in Listing 7.15. The ComputerProduct \nis the product class for all products carried at all store branches, which includes simple or \nadvanced computer products. Consider the case where the designer of one computer store branch uses a list data \nstructure to save computer products for the computer store branch carrying simple com-\nputer products. To retrieve the products from the simple computer store, a method is \nListing 7.15: C++ Specification of the ComputerProduct Type\nclass ComputerProduct {\npublic:\n\t // Return the product\u2019s id. int getProductId();\n\t // Return the product\u2019s price. int getPrice() const;\n\t // Return the product\u2019s description. string getDescription() const;\n\t // Other methods here...\n};", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 263", "position": 263, "chunk_type": "semantic", "token_estimate": 335}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 241: Notice that by having different methods to retrieve each product (i.e., getSimple\u00ad\nProduct and getAdvancedProduct), the client code now requires a conditional state-\nment to differentiate between the two store branches, which results in two versions of code \nfor displaying product information. For each store added to the system, a new conditional \nstatement is required to support the display of the new computer store branch. Structure\nThe general and applied structure of the iterator design pattern is presented in Figure\u00a07.6. The key to designing the iterator design pattern lies in the Iterator interface. As seen in \nthe General View portion of Figure\u00a07.6, the Iterator interface consists of the first\n(), \nnext\n(), isDone(), and currentItem() interface methods. These methods specify the \nfundamental operations that need to be provided by iterator objects that implement the \ninterface. Regardless of the collection data structure employed to store products, these inter-\nface methods can be used uniformly to traverse the items contained by the data structure. The first\n() method is used to return the first item in the collection; the next\n() method \nis used to move the current item to the next element of the list; the \u00ad\ncurrentItem() \nmethod is used to return the product stored at the current location of the iterator; and \nthe isDone() method is used to determine if there are more products to traverse in the \n\u00ad\ncollection item. Listing 7.17: C++ Code for the AdvancedComputerStore Class\n#include \u201cAdvancedProductList.h\u201d\n// Advanced Computer Store\nclass AdvancedComputerStore {\npublic:\n\t // Constructor. AdvancedComputerStore() { /*Initialize all products. */ }\n\t // Computer store methods...\n\t // Return a pointer to the advanced product list. AdvancedProductList* getProducts() {\n\t \t // Return the advanced product list. return &_products;\n\t }\nprivate:\n\t // The computer products... in ProductList form. AdvancedProductList _products;\n};", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 265", "position": 265, "chunk_type": "semantic", "token_estimate": 306}
{"text": "242\u2002 \u2022\u2002 Software Engineering Design\ufeff: Also, in the General View of the iterator design pattern, the Aggregate interface speci-\nfies the method for instantiating and returning an iterator object. Clients use this object to \ntraverse the collection using the iterator interface instead of the concrete aggregate object. This version of the iterator design pattern is the preferred version for new design efforts. However, in practice, the iterator can be designed differently from project to project, espe-\ncially when existing code is in place. For example, in the Applied View of Figure\u00a07.6, some \nListing 7.18: C++ Code for the Centralized Server \nSoftware to Display Computer Products\n// Simple store. SimpleComputerStore simpleStore;\nComputerProduct* pProduct = 0;\nSimpleProductList* simpleStoreProducts = simpleStore.getProducts();\n// Display simple store products. for( int i = 0; i < simpleStoreProducts->size(); i++ ) {\n\t // Retrieve the product at index i.\n\t pProduct = simpleStoreProducts->getSimpleProduct(i);\n\t // Make sure pProduct is valid before using it! // Display product\u2019s information. cout<<\u201dProduct id: \u201c<<pProduct->getProductId()<<endl\n\t \t <<\u201dProduct price: \u201c<<pProduct->getPrice()<<endl\n\t \t <<\u201dProduct Description: \u201c<<pProduct->getDescription().c_str()<<endl;\n}\n//Advanced store. AdvancedComputerStore advancedStore;\nAdvancedProductList* advancedProducts = advancedStore.getProducts();\n// Display advanced store products. for( int i = 0; i < advancedProducts->length(); i++ ) {\n\t // Retrieve the product at location i.\n\t pProduct = advancedProducts->getAdvancedProduct(i);\n\t // Make sure pProduct is valid before using it! // Display product\u2019s information. cout<<\u201dProduct id: \u201c<<pProduct->getProductId()<<endl\n\t \t <<\u201dProduct price: \u201c<<pProduct->getPrice()<<endl\n\t \t <<\u201dProduct Description: \u201c<<pProduct->getDescription().c_str()<<endl;\n}\n// Repeat here for all other types of lists!", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 266", "position": 266, "chunk_type": "semantic", "token_estimate": 234}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 243: of the iterator interface methods are omitted and the names are modified from the original \npattern. In addition, each concrete aggregate class is designed as of two independent and \nexisting classes in the system. This is necessary when code for the existing collection data \nstructures (e.g., SimpleProductList) cannot be modified. When examined closely, \nthe Applied View of Figure\u00a07.6 consists of the same relationships and similar interface \nmethods but are structured differently to account for the existing code. Similar variations \nof the iterator design pattern can be found in practice; therefore, modifying the iterator \nrelationships to fit a particular problem is common. Notice, however, that if code for both \nSingleProductList and AdvancedProductList is available for modification, the \nAggregate\nIterator\n+createIterator()\nConcreteAggregate\n+createIterator()\nSimpleProductList\n+createIterator(): StoreProductIterator*\n<<interface>>\nComputerStore\n+createIterator(): StoreProductIterator*\nAdvancedComputerStore\n+createIterator(): StoreProductIterator*\nAdvancedComputerStore\nAdvancedProductList\n+hasNext(): bool\n+getNext(): ComputerProduct*\n+reset(): void\n<<interface>>\nStoreProductIterator\n+hasNext(): bool\n+getNext(): ComputerProduct*\n+reset(): void\nSimpleStoreProductIterator\n+hasNext(): bool\n+getNext(): ComputerProduct*\n+reset(): void\nAdvancedStoreProductIterator\n+\ufb01rst()\n+next()\n+isDone()\n+currentItem()\nGeneral View\nConcreteIterator\n+\ufb01rst()\n+next()\n+isDone()\n+currentItem()\nApplied View\nFIGURE 7.6\nUML class diagram for the iterator design pattern.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 267", "position": 267, "chunk_type": "semantic", "token_estimate": 188}
{"text": "244\u2002 \u2022\u2002 Software Engineering Design\ufeff: design of these classes would take the place of the simple and advanced computer store \nfrom the Applied View of Figure\u00a07.6 to match the general view of the design pattern. In the applied version, the hasNext\n() method is specified to return true if the col-\nlection data structure has more elements for traversal; the getNext\n() interface method \nis used to move the iterator\u2019s pointer to the next element in the collection and return the \nproduct stored at that location; finally, the reset\n() interface method is designed to reset \nthe collection index to the first item in the collection. Similar to the applied design for the \ncomputer store software, the iterator design pattern is applied in software systems with dif-\nferent interface methods to solve the original problem that the pattern describes. Once the iterator is designed, the next key element of the design pattern involves design-\ning the concrete iterators that provide a uniform level of abstraction for each collection \nstructure (e.g., array, linked list) in the system. As seen in Figure\u00a07.6, for each concrete \niterator designed an association is made to the appropriate collection structure. This means \nthat each iterator knows the specific interface methods provided by its associated collection \nstructure so that it can use them to traverse and access its products. This way, when clients \nof the iterator call a method from the iterator interface (e.g., getNext\n()\n), the concrete \niterator can carry out the request internally in terms of the collection structure\u2019s inter-\nface method, hiding these details from its clients. Therefore, regardless of the collection \nstructure, clients of the iterator can always rely on the Iterator interface to traverse any \ncollection structure supported by concrete iterators. This property of the iterator design \npatterns is desirable in many practical applications. Finally, the iterator design pattern requires the design of the Aggregate interface which \nis manifested in the computer store problem as the ComputerStore interface. The impor-\ntance of this interface is that it allows clients of the computer store to create iterators for \ntraversing through the different store product items. As discussed earlier, the aggregate \n\u00ad\ninterface can be directly implemented by the class representing the collection structure \nor, if this code is unavailable, by another class that provides one more levels of abstrac-\ntion, such as the ComputerStore in Figure\u00a07.6.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 268", "position": 268, "chunk_type": "semantic", "token_estimate": 397}
{"text": "244\u2002 \u2022\u2002 Software Engineering Design\ufeff: The impor-\ntance of this interface is that it allows clients of the computer store to create iterators for \ntraversing through the different store product items. As discussed earlier, the aggregate \n\u00ad\ninterface can be directly implemented by the class representing the collection structure \nor, if this code is unavailable, by another class that provides one more levels of abstrac-\ntion, such as the ComputerStore in Figure\u00a07.6. With this in place, clients rely on the \nComputerStore interface to create and return an iterator without needing to know the \nparticular type of store; once the iterator is returned, clients use the iterator interface to \ntraverse through the products, therefore providing a design that relies fully on interfaces \nrather than concrete implementations. This results in flexible designs that can be modified \nand adapted easily to future demands. The step-by-step approach for applying the iterator \ndesign pattern is as follows:\n\t\n1. Identify and design the Iterator interface. 2. For each class representing a collection data structure in the software system, design \na concrete iterator and associate it with it. Implement the concrete iterator\u2019s methods \nin terms of the collection data structure. 3. Create the aggregate interface, which includes the interface method to create iterators. 4. For each class representing a collection data structure, implement the aggregate \ninterface to instantiate and return a concrete iterator.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 268", "position": 268, "chunk_type": "semantic", "token_estimate": 227}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 245: The driving forces behind the design are decreased complexity for clients and \u00ad\nflexibility. By applying the iterator design pattern, clients are shielded from the internals of the \n\u00ad\ncollection data structure. This in turn provides flexibility by allowing new stores to be \nadded easily or different existing iterators to be swapped without changes to the client code. Implementation\nThe implementation of the iterator design pattern for the computer store system \nassumes that both collection data structures (i.e., simple and advanced lists) cannot be \nmodified. Therefore, the aggregate portion of the pattern is split, as seen in Figure\u00a07.6. The implementation of the iterator design pattern begins with the specification of the \nStoreProductIterator interface, as seen in Listing 7.19. This interface is designed \nListing 7.19: C++ Specification of the StoreProductIterator Interface\n// Forward reference. class ComputerProduct;\n// The base for all store product iterators. class StoreProductIterator {\npublic:\n\t // Constructor. StoreProductIterator() : _position(0) { /*Intentionally left\n\t \t \t\nblank. */}\n\t // Interface method for determining if more products are available. virtual bool hasNext() = 0;\n\t // Interface method for retrieving the next available product. virtual ComputerProduct* getNext() = 0;\nprotected:\n\t // Give access to derived classes for setting the iterator\u2019s\n\t // position. void setPosition(int position) { _position = position; }\n\t // Allow derived classes to retrieve the iterator\u2019s position. int getPosition(void) { return _position; }\n\t // Reset the iterator\u2019s position. void reset(void) { _position = 0; }\nprivate:\n\t // The iterator\u2019s current position. int _position;\n};", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 269", "position": 269, "chunk_type": "semantic", "token_estimate": 253}
{"text": "246\u2002 \u2022\u2002 Software Engineering Design\ufeff: with simplicity in mind; therefore it contains two main methods for iteration, hasNext\n() \nand getNext\n(). There are many different ways iterators can be designed; in this case, \nif\u00a0the method hasNext\n() returns true, a subsequent call to getNext\n() can be made to \nmove the iterator to the next element and to retrieve the product stored at that location. Once the StoreProductIterator interface is specified, each concrete iterator can be \ncreated. Listing 7.20 presents the specification of the SimpleStoreProductIterator, \nwhich is the iterator used for traversing through in the simple computer store, which stores \ncomputer products in a simple product list. Since this iterator is designed to work with the \nsimple computer store, a SimpleProductList memory reference or pointer is passed \nto it in the constructor. As expected, the interface methods for the SimpleStoreProductIterator type \nare implemented in terms of the SimpleProductList type, as seen in Listing 7.21. Of\u00a0particular interest is the getNext\n() method, which encapsulates the specific call to \ngetSimpleProduct\n() to retrieve a computer product. The specification of the AdvancedStoreProductIterator is similar to the one \npresented in Listing 7.21 but is specific to the AdvancedProductList collection data \nstructure. Therefore, implementation of the AdvancedStoreProductIterator is \nmade in terms of this data structure, as seen in Listing 7.22. To enforce the policy that all computer stores must support the iterator design pattern, a \nstandard ComputerStore interface is specified, as seen in Listing 7.23. Computer stores deriving from this interface must provide an implementation for the \n\u00ad\ncreateIterator() method before they can be instantiated. This provides clients with \na standard method for retrieving iterators from all computer stores. Listings 7.24 and 7.25 \npresent\u00ad\n the C++ implementation for both simple and advanced computer stores, respectively. Listing 7.20: C++ Specification of the SimpleStoreProductIterator\nclass SimpleStoreProductIterator : public StoreProductIterator {\npublic:\n\t // Constructor. SimpleStoreProductIterator(SimpleProductList* products);\n\t // Determine if more products are available. bool hasNext();\n\t // If more products are available, get the next one. ComputerProduct* getNext();\nprivate:\n\t // Pointer to the simple computer product list. SimpleProductList* _products;\n};", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 270", "position": 270, "chunk_type": "semantic", "token_estimate": 344}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 247: Listing 7.21: C++ Implementation for the SimpleStoreProductIterator\n#include \u201cSimpleStoreProductIterator.h\u201d\n#include \u201cSimpleProductList.h\u201d\n// Constructor. SimpleStoreProductIterator::\n\t \t SimpleStoreProductIterator(SimpleProductList* products) {\n\t // For simplicity, assume a valid pointer. _products = products;\n}\n// Determine if more products are available. bool SimpleStoreProductIterator::hasNext() {\n\t // The return value. bool isNextProductAvailable = false;\n\t if( getPosition() < _products->size() ) {\n\t \t isNextProductAvailable = true;\n\t }\n\t return isNextProductAvailable;\n}\n// If more products are available, get the next one. ComputerProduct* SimpleStoreProductIterator::getNext() {\n\t // Temporary pointer to computer product. ComputerProduct* pProduct = 0;\n\t // Get the iterator\u2019s current position. int nextItem = getPosition();\n\t // Determine if there are more products. if( hasNext() ) {\n\t \t // Get the address of the next product and move the iterator\u2019s\n\t \t // position. pProduct = _products->getSimpleProduct(nextItem++);\n\t \t // Set the new position of the Iterator. setPosition(nextItem);\n\t }\n\t // Return the requested product. return pProduct;\n}", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 271", "position": 271, "chunk_type": "semantic", "token_estimate": 147}
{"text": "248\u2002 \u2022\u2002 Software Engineering Design\ufeff: Listing 7.22: C++ Implementation for the AdvancedStoreProductIterator\n#include \u201cAdvancedStoreProductIterator.h\u201d\n#include \u201cAdvancedProductList.h\u201d\n// Constructor. AdvancedStoreProductIterator::\n\t \t AdvancedStoreProductIterator(AdvancedProductList* products) {\n\t // For simplicity, assume valid pointer. _products = products;\n}\n// Determine if more products are available. bool AdvancedStoreProductIterator::hasNext() {\n\t // The return value. bool nextProductAvailable = false;\n\t if( getPosition() < _products->length() ) {\n\t \t nextProductAvailable = true;\n\t }\n\t return nextProductAvailable;\n}\n// If more products are available, get the next one. ComputerProduct* AdvancedStoreProductIterator::getNext() {\n\t // Temporary pointer to computer product. ComputerProduct* pProduct = 0;\n\t // Get the iterator\u2019s current position. int nextItem = getPosition();\n\t // Determine if there are more products. if( hasNext() ) {\n\t \t // Get the address of the next product and move the iterator\u2019s\n\t \t // position. pProduct = _products->getAdvancedProduct(nextItem++);\n\t \t // Set the new position of the iterator. setPosition(nextItem);\n\t }\n\t // Return the requested product. return pProduct;\n}", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 272", "position": 272, "chunk_type": "semantic", "token_estimate": 142}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 249: With the iterator design pattern in place, the function to display computer products in \nthe software system can be modified to work in terms of the iterator interface, as seen in \nListing 7.26. The software system can now display each store\u2019s product using a unified interface, as \nseen in Listing 7.27. This design supports adding new computer stores without much effort. Listing 7.23: C++ Specification of the ComputerStore Interface\nclass StoreProductIterator; // Forward reference. // The interface for all computer stores. class ComputerStore {\npublic:\n\t // The interface method to create an iterator. virtual StoreProductIterator* createIterator() = 0;\n};\nListing 7.24: C++ Implementation for the Simple Computer Store\n#include \u201cSimpleStoreProductIterator.h\u201d\n#include \u201cSimpleProductList.h\u201d\n// Simple Computer Store\nclass SimpleComputerStore : public ComputerStore {\npublic:\n\t // Override the createIterator interface method to create the\n\t // appropriate iterator for simple computer stores. StoreProductIterator* createIterator() {\n\t \t // Create and return a simple store product iterator. return new SimpleStoreProductIterator(&_products);\n\t }\n\t // All other methods for simple computer stores. private:\n\t // The simple product list. SimpleProductList _products;\n};", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 273", "position": 273, "chunk_type": "semantic", "token_estimate": 181}
{"text": "250\u2002 \u2022\u2002 Software Engineering Design\ufeff: Listing 7.25: C++ Implementation for the Advanced Computer Store\n// Advanced Computer Store\nclass AdvancedComputerStore : public ComputerStore {\npublic:\n\t // Override the createIterator interface method to create the\n\t // appropriate iterator for advanced computer stores. StoreProductIterator* createIterator() {\n\t \t // Create and return an advanced store product iterator. return new AdvancedStoreProductIterator(&_products);\n\t }\n\t // All other methods for advanced computer stores. private:\n\t // The advanced product list. AdvancedProductList _products;\n};\nListing 7.26: C++ Implementation of the Display \nFunction in the Centralized Software\n// Display the products using the iterator. void displayProducts(StoreProductIterator* pIterator) {\n\t // Temporary pointer to hold a computer product. ComputerProduct* pProduct = 0;\n\t // Determine if there are more products to browse. while( pIterator->hasNext() ) {\n\t \t // Retrieve the next product. pProduct = pIterator->getNext();\n\t \t // Display the product\u2019s information. cout<<\u201d\\nProduct id: \u201c<<pProduct->getProductId()<<endl\n\t \t \t\n<<\u201dProduct price: \u201c<<pProduct->getPrice()<<endl\n\t \t \t\n<<\u201dProduct Description: \u201c<<pProduct->getDescription().c_str();\n\t }\n}", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 274", "position": 274, "chunk_type": "semantic", "token_estimate": 146}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 251: Benefits\n\u2022\t Provides a consistent way for clients to iterate through the objects in a collection\n\u2022\t Abstracts the internals of the collection objects so that if they change, clients do not \nhave to change\n\u2022\t Allows client code to be extended easily; numerous iterators can be created to support \ndifferent traversals from the same or different collection structure\nSkill Development 7.2: Iterator Design Pattern\nUsing the UML tool of choice, create the design presented in the Applied View Section \nof Figure\u00a07.6. Rename the aggregate interface method from ComputerStore to \n\u00ad\ncreate Product Iterator. Make the appropriate modifications to both simple and \nadvanced computer stores so that they work with the new interface method. Generate \ncode from the model, and \u00ad\ncreate a test driver code to verify the design. Once the code \ncompiles and executes, describe how your design benefited from using the iterator \ndesign pattern. Listing 7.27: C++ Code for the Centralized Software \nto Create Iterators and Display Products\n// Simple store. SimpleComputerStore simpleStore;\n// Iterator for the simple store. StoreProductIterator* pIterator = simpleStore.createIterator();\n// Display the products using the iterator. displayProducts(pIterator);\n// Cleanup the simple computer store iterator. delete pIterator;\n// Advanced store. AdvancedComputerStore advancedStore;\n// The advanced store iterator. pIterator = advancedStore.createIterator();\n// Display the products using the iterator. displayProducts(pIterator);\n// Cleanup the advanced computer store iterator. delete pIterator;", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 275", "position": 275, "chunk_type": "semantic", "token_estimate": 233}
{"text": "The observer design pattern is an object behavioral pattern that standardizes the opera-: tions between objects that interoperate using a one-to-many relationship. According to the \nGang of Four (Gamma et al. 1995, p. 293), the intent of the observer is to\nDefine a one-to-many dependency between objects so that when one object changes state, all \nits dependents are notified and updated automatically. In many practical applications, a common design structure is required to support inter-\naction between objects that monitor a common data source so that when changes occur in \nthe data source the objects react appropriately. Consider a detailed design that supports the \nmodel\u2013view\u2013controller (MVC) architectural pattern from Chapter 4. In the MVC archi-\ntectural pattern, once the data in the model component changes, all views must change as \nwell. In cases such as the MVC, the observer design pattern provides the necessary struc-\ntural interfaces to allow one or more views to register with the model component. Once \nregistered, the observer design pattern provides the structural interfaces for executing a \nuniform change propagation mechanism for the model to notify all registered views of the \nrecent changes. The observer design pattern is very popular and prevalent in today\u2019s modern \nlanguages and frameworks, such as Java (i.e., Observable and Observer interfaces) and .NET. Problem\nA local university is designing a system for weather-alert notification that allows students, \nfaculty, and staff to receive notifications of class cancellations (due to weather) via e-mail, \nvoice call, or SMS text messages. Other methods of notification may be added in the \nfuture. The system is based on the weather data decision engine that interfaces with several \nweather-related data sources, fuses the information, and automatically decides whether \nclass cancellations are in effect. The university is interested in integrating the existing com-\nmunication services (i.e., e-mail, SMS, and voice) with the decision engine so that these \nservices can be triggered to initiate notification via their respective communication types. The design must be flexible so that other types of communication mechanisms can be \nadded to the system in the future. Structure\nThe general and applied structure of the observer design pattern is presented in Figure\u00a07.7. The typical application of the observer design pattern includes one concrete subject and \none or more concrete observers, as seen in the Applied View of Figure\u00a07.7. Each concrete observer is required to implement the update() interface method spec-\nified by the Observer interface.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 276", "position": 276, "chunk_type": "semantic", "token_estimate": 402}
{"text": "The observer design pattern is an object behavioral pattern that standardizes the opera-: The typical application of the observer design pattern includes one concrete subject and \none or more concrete observers, as seen in the Applied View of Figure\u00a07.7. Each concrete observer is required to implement the update() interface method spec-\nified by the Observer interface. Similar to other design patterns, implementation of the \nobserver design pattern varies depending on particular details of projects. Specifically,", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 276", "position": 276, "chunk_type": "semantic", "token_estimate": 76}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 253: the implementation of the update method is typically seen in two common versions. One \nversion includes passing as parameter the details of the change notification. Using this \napproach, concrete observers examine notification information using the update param-\neter and act accordingly. This is possible when the type of notification can be abstracted \nso that it provides a common interface for all other concrete observers. Another popular \napproach involves designing the update() method without parameters. Upon receiving \nchange notification, concrete objects call a method of the concrete subject to retrieve the \ndetails of the notified change. Since the behavior for attaching, detaching, and notifying \nobservers is the same, the Subject base class can specify and implement these methods, \nwhich are inherited by all other concrete subjects. The step-by-step approach for applying \nthe observer design pattern includes\n\t\n1. Design the subject interface and implement code for attaching, detaching, and noti-\nfying observer objects. The code for keeping track of observers can be done using \nlinked-lists data structures. 2. For classes that manage information of interest to observers, inherit from the subject \nclass created in Step 1. 3. Design the observer interface, which includes the abstract update interface method. 4. For all observers in the system, implement the observer interface, which requires \nimplementing the update method. 5. At run time, create each observer and attach it to the subject. When changes occur, \nthe subject iterates through its list of registered objects and calls its update method. +attach(pObserver: Observer*): void\n+dettach(pObserver: Observer*): void\n#notify(): void\nSubject\nEmailService\n+update(): void\n<<interface>>\nObserver\n+update(): void\nConcreteObserver\nConcreteSubject\nDecisionEngine\nServiceNoti\ufb01er\nApplied View\nGeneral View\n+update(msg: string): void\n+attach(pService: Service*): void\n+detach(pService: Service*): void\n#notify(): void\n<<interface>>\nService\n+update(msg: string): void\nPhoneService\n+update(msg: string): void\nSmsService\n+update(msg: string): void\nFIGURE 7.7\nUML class diagram for the observer design pattern.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 277", "position": 277, "chunk_type": "semantic", "token_estimate": 310}
{"text": "254\u2002 \u2022\u2002 Software Engineering Design\ufeff: The driving force behind the application of the observer design pattern is flexibility. By\u00a0applying the observer design pattern, future additions of services can be done automati-\ncally, therefore leading to software that is easy to maintain. Implementation\nImplenting the observer design pattern begins with the ServiceNotifier class, which \nserves as base class for the subjects. As seen, the methods to provide registration and noti-\nfication services are implemented in terms of a C++ STL list, as presented in Listing 7.28. With the registration mechanism in place, all services realize the Service \u00ad\ninterface to \nacquire notification capabilities. Listing 7.29 presents an example for the EmailService \nobserver. An example of the registration and notification mechanism is presented in Listing 7.30. As seen, many different observers can register with the DecisionEngine object to get \nnotifications of weather alerts. Benefits\n\u2022\t Flexibility for adding new services to the system\n\u2022\t Maintaining and modifying existing system services become easier because specific \nservices are compartmentalized\nListing 7.28: C++ Code to Provide Registration and Notification to Observers\n// Provide the registration mechanism for all observers. void ServiceNotifier::attach(Service* pService) {\n\t // Add this observer to the list of registered observers. Assume a\n\t // valid pointer. _services.push_back(pService);\n};\n// The trigger mechanism to notify all observers of class cancellation. void ServiceNotifier::notify(string message) {\n\t // Get an Iterator that points to the beginning of the\n\t // observers_ list. list<Service*>::iterator pIter = _services.begin();\n\t // Iterate through the list of observers and notify them. for( int i = 0; i < _services.size(); i++ ) {\n\t \t // Pass the message along to all registered observers. (*pIter++)->update(message);\n\t }\n}", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 278", "position": 278, "chunk_type": "semantic", "token_estimate": 272}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 255: Skill Development 7.3: Observer Design Pattern\nUsing the UML tool of choice, create the detailed component design of the MVC archi-\ntectural design presented in Figure\u00a04.9 using the observer design pattern. Generate \ncode from the model, and create a test driver method to validate the design. Explain \nthe differences between the MVC architectural pattern and the observer design pattern \nin this example. Listing 7.29: C++ Code for the Update() Method \nof the EmailService Observer\nclass EmailService : public Service {\n\t public:\n\t // Once the Observable object changes, it will call this method. void update(string message) {\n\t \t // Open file containing all users registered for email\n\t \t // notification. Open connection to the Email server. // For all registered clients, notify them via email.\n\t } // ...\n};\nListing 7.30: C++ Registration and Notification\u00a0Mechanism \nof the WeatherDataObject\n// Sends message as email. EmailHandler emailHandler;\n// Sends message as text message. SmsHandler smsHandler;\n// Translates message to speech and sends it via the voice interface. VoiceHandler voiceHandler;\n// Assume that the decision engine object is a singleton. DecisionEngine::getInstance()->register(&emailHandler);\nDecisionEngine::getInstance()->register(&smsHandler);\nDecisionEngine::getInstance()->register(&voiceHandler);", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 279", "position": 279, "chunk_type": "semantic", "token_estimate": 188}
{"text": "Structural and behavioral designs patterns help identify problems that deal with the structure: and behavior of software designs; they prescribe the classes required for their design solu-\ntion and interrelationships required to support object creation. These patterns allow design-\ners to quickly and systematically identify structural layouts of systems (or\u00a0subsystems) and \nprovide avenues for examining the system\u2019s interactions and quality evaluation within the \noperational system. Structural design patterns are patterns that deal with designing larger \nstructures from existing classes or objects at run time. They play a key role in the design and \nevolution of systems by allowing integration of new designs with existing ones, via object \ncomposition (i.e., object structural) or inheritance (i.e., class structural). By\u00a0allowing designs \nto build on other existing structures, systems can be made interoperable by designing com-\npatible interfaces for otherwise incompatible systems. Examples of structural design patterns \ninclude adapter, composite, and facade design patterns. Behavioral design patterns deal with \nencapsulating behavior with objects, assigning responsibility, and managing object coopera-\ntion when achieving common tasks. Behavioral design patterns include many of the main-\nstream design patterns used in \u00ad\nmodern object-oriented frameworks and play a key role in the \ndesign of systems by making them independent of specific behavior, which is made replace-\nable with objects throughout these design patterns. Therefore, parts of the system respon-\nsible for performing some algorithm or behavior do so by relying on a common interface \nwithout knowledge of how the actual behavior or algorithm is carried out. In\u00a0addition, by \ncontrolling the behavioral process with common interfaces, enforcing behavioral policies \nbecomes easier, therefore giving systems the ability to create algorithms that share a com-\nmon interface but vary widely in behavior. Examples of behavioral patterns include the \niterator and the observer. This \u00ad\nchapter explored each structural and behavioral design \npattern to present the problems they are designed to address together with the benefits \nthey provide. Identifying and designing using these design patterns can improve the effi-\nciency of the development \u00ad\nprocess and the quality of the final system.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 280", "position": 280, "chunk_type": "semantic", "token_estimate": 343}
{"text": "1.\tWhat are structural design patterns? What are they used for?: 2. Compare and contrasts the following patterns:\n\t\na.\t Adapter\n\t\nb. Composite\n\t\n3. What is the adapter design pattern? Explain its main benefits and features. 4. What is the composite design pattern? List and explain the main features of the \nbuilder design pattern. 5. Give an example each of both adapter and composite design patterns. Do not use the \nones presented in the chapter.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 280", "position": 280, "chunk_type": "semantic", "token_estimate": 74}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 257: 6. Explain the steps required to implement the composite design pattern. 7. What is the facade design pattern? What does it do? 8. What are the essential structural elements required in the composite design pattern? 9. What are the main benefits of using the iterator design pattern? 10. What is the observer design pattern? Give one example of a particular software \n\u00ad\nfeature that you think is appropriate for applying the observer. 11. What are the essential elements required in the observer design pattern?", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 281", "position": 281, "chunk_type": "semantic", "token_estimate": 93}
{"text": "1.\tYou have been hired to work on a car testing utility class. The car testing utility: class has one method with the following signature: void testCar(Car* pCar). As seen, the testCar function is designed to test objects of the type Car. The \ncar interface supports the following methods: void enableCruise(), void \n\u00ad\nopenWindow(), void closeWindow(), and void accelerate(int mph). The \ntest utility function is currently being used to test objects of type TypicalCar, \nwhich support all interface methods. However, the test utility is now needed to test \nobjects of the new type RaceCar, however, the RaceCar type only supports the \naccelerateReallyFast(int mph) method. Use an appropriate design pattern \nto allow the RaceCar type to be used in the testCar utility function. Feel free to \nmake any assumptions necessary to complete the design. The usage and output are \npresented below. void testCar(Car* pCar)\n{\n\t pCar->enableCruise();\n\t pCar->openWindow();\n\t pCar->closeWindow();\n\t pCar->accelerate(50);\n}\n// Sample output - if typical car passed in to the test utility\n// function. TypicalCar::enabling smart cruise control...\nTypicalCar::opening 2 windows...\nTypicalCar::closing 2 windows...\nTypicalCar::accelerating fast to 50 mph...\n// Sample output - if race car passed in to the test utility\n// function. ConcreteRaceCar::no cruise control available...\nConcreteRaceCar::no window available...\nConcreteRaceCar::no window available...\nConcreteRaceCar::accelerating really fast to 50 mph...", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 281", "position": 281, "chunk_type": "semantic", "token_estimate": 210}
{"text": "\u2022\t Understand the importance and role of construction design: \u2022\t Identify, understand, and apply table-based and state-based func-\ntion design\n\u2022\t Identify, understand, and apply the general construction styles\n\u2022\t Understand how quality can be evaluated during construction design", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 283", "position": 283, "chunk_type": "semantic", "token_estimate": 39}
{"text": "The transition from software design to construction should occur with: minimal effort. In some cases, component designs provide enough detail \nto allow their transformation from design artifact into code easily; how-\never, in other cases, a more fine-grained level of design detail is required. Construction design provides a form of design that closely resembles code so \nthat complex operations can be planned and evaluated prior to implemen-\ntation in code. Once the correctness of operations is verified, the construc-\ntion design activity provides additional heuristics to enforce consistency \nin the code. Construction design provides the last form of design to create \nhigh-quality software operations that are correct, consistent, and efficient. WHAT IS CONSTRUCTION DESIGN? The idea of the detailed design phase is to manage complexity so that \ndesign artifacts can be translated to code with minimal effort. Even though", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 283", "position": 283, "chunk_type": "semantic", "token_estimate": 139}
{"text": "260\u2002 \u2022\u2002 Software Engineering Design\ufeff: significant attempts can be made during the detailed (component) design activity to \u00ad\ncreate \nextensive designs, in most practical applications transitioning from the component design \ndomain to code can still be daunting. Regardless of the amount of effort spent during \nthe design phase, additional design efforts may still be required during construction to \n\u00ad\nidentify, plan, and manage the construction of complex operations. This form of con-\nstruction design extends the work performed during detailed design to provide essential \ninformation that is used to generate correct, efficient, and consistent code. Construction \ndesign is the lowest level of detailed design that addresses the modeling and specification \nof function implementations. By designing complex operations, problem solutions can be \nevaluated, analyzed, and verified for correctness and efficiency before construction using \nprogramming languages. Construction design provides the means for evaluating problem \nsolutions using a form of design that closely relates to code\u2014that is, a form of design that \nmodels what the code does and how the code is specified. Construction design can address problem solving from a dynamic (behavioral) perspec-\ntive, which provides the description of operations (such as methods and functions) and the \ninternal details and logic of each design entity (IEEE 2009). This approach involves graph-\nical, tabular, or other methods to model and specify the internal structure of functions \n(e.g.,\u00a0operations, routines) so that the algorithms or flows required to carry out a function\u2019s \nintent are evaluated and clearly specified. The algorithm approach minimizes complexity \nduring construction by providing a graphical method for specifying the details required \nby programmers to implement the function\u2019s code. A separate but closely related task per-\nformed when evaluating the quality of software construction deals with enforcing styles for \nestablishing a consistent approach to structuring function \u00ad\nimplementations. These styles \nplay a significant role in shaping the system\u2019s \u00ad\nmaintainability, complexity, and testability. Therefore, they are included as part of the construction design activity. Construction design is not a new concept. In fact, there are many books covering con-\nstruction design under different names. McConnell (2004) specifies five levels of software \ndesign, the lowest two of which deal with division of data and routines within classes and \ninternal routine design. Similarly, Fox (2006) identifies a form of low-level design that fills \nthe gap between detailed design and programming and deals with issues such as opera-\ntion specification, including operation name, parameter types, and return types.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 284", "position": 284, "chunk_type": "semantic", "token_estimate": 404}
{"text": "260\u2002 \u2022\u2002 Software Engineering Design\ufeff: McConnell (2004) specifies five levels of software \ndesign, the lowest two of which deal with division of data and routines within classes and \ninternal routine design. Similarly, Fox (2006) identifies a form of low-level design that fills \nthe gap between detailed design and programming and deals with issues such as opera-\ntion specification, including operation name, parameter types, and return types. Similarly, \nMeyer (1997) and Misfeldt, Bumgardner, Gray, and Xiaoping (2004) provide coverage of \nconstruction design. WHY STUDY CONSTRUCTION DESIGN? Construction design is about developing abstract models of the structure and behavior of \nthe internal implementation of operations. From a behavioral perspective, construction \ndesign is important because it provides the means for evaluating different implementations \nfor a particular function before committing to it. Behavioral designs at this level provide", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 284", "position": 284, "chunk_type": "semantic", "token_estimate": 134}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 261: the means to evaluate a function\u2019s completeness, complexity, testability, and maintainabil-\nity. They also provide the means for analysts to evaluate algorithms in regard to time\u2013space \nperformance and processing logic prior to implementation (IEEE 2009). Finally, since they \nprovide a representation of the code through graphical and tabular ways, they increase \ncollaborative evaluation efforts, since other members without knowledge of the particu-\nlar programming language in use can evaluate the design and contribute to the solution. These collaboration efforts can lead to improvement in future phases, for example, the \ntesting phase, where construction designs can be used to generate unit test cases, or the \nmaintenance phase, where construction designs can be used to increase knowledge and \nunderstanding of the software behavior. From the structural perspective (i.e., construction styles), construction design is impor-\ntant because it provides heuristics for establishing a common criterion for evaluating the \nquality of the structure of code, which directly affects code readability and thus mainte-\nnance. Code with low readability leads to higher maintenance costs, since it requires more \neffort to understand (Collar 2005). Construction styles are important during the design \nand construction phases so that code generation from design models can be done \u00ad\ncorrectly. From a construction phase perspective, construction styles serve as a blueprint that ensures \nconsistency among teams of developers. Finally, as mentioned before, \u00ad\nduring the testing \nand maintenance phase construction styles increase code readability and understanding, \nwhich can result in minimized cost during these phases.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 285", "position": 285, "chunk_type": "semantic", "token_estimate": 251}
{"text": "Behavioral designs at the construction level are used to model complex logic that is: unknown or difficult to understand. This way, details required to describe an operation \ncan be discovered or evaluated without requiring code. The purpose of behavioral design \nis to model the dynamic aspects of code that makes up a particular function. Behavioral \ndesigns have been the topic of much research work in software engineering and are an \nintegral part of all major software design strategies (e.g., structured and object-oriented \ndesigns). Behavioral designs provide the means for assessing the completeness, correct-\nness, and quality of functions before actual implementation occurs and therefore are an \nessential activity for complex operations. Four major approaches to behavioral design at \nthe construction level are flow-based designs, state-based designs, table-based designs, and \nprogramming design languages. Flow-Based Designs\nFlow-based designs provide a systematic methodology for specifying the logic of opera-\ntions using a graphical approach. Two popular approaches for creating flow-based designs \ninclude flowcharts and Unified Modeling Language (UML) activity diagrams. Both work", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 285", "position": 285, "chunk_type": "semantic", "token_estimate": 169}
{"text": "262\u2002 \u2022\u2002 Software Engineering Design\ufeff: well for modeling the internal flow of routines because they can be defined using sequential \nprocess flows, loops, conditional statements, and other useful mechanisms needed to model \ncomplex business logic or complicated algorithms. UML activity diagrams provide power-\nful constructs for modeling complex logic at different stages of the software engineering \nlife cycle; however, when applied toward modeling logic, activity diagrams provide similar \nfeatures to flowcharts. Four important modeling constructs for flow-based designs are\n\u2022\t If statements\n\u2022\t Case statements\n\u2022\t Do while loop\n\u2022\t While loops\nThe common elements used to model flow-based designs using UML activity diagrams \nare presented in Figure\u00a08.1, together with examples of modeling conditional and repeti-\ntion statements. State-Based Designs\nFlow-based designs can be used to model operational logic by identifying the transitions \nfrom activity to activity required to perform an operation. However, in some cases the \noperational logic of a function or system is dictated by the different states that the system \nexhibits during its lifetime. That is, certain activities can be performed only when a system \nis in a particular state. When this occurs, the operational logic of a system can be modeled \nas a state machine using a (UML) state diagram. State diagrams are typically used to model \nthe behavior of complete system. However, in many practical applications, state diagrams \ncan be used to guide the logical design of one or more operations in the system. Consider \nthe state design presented in Figure\u00a08.2. Figure\u00a0 8.2 depicts the design of a software system that receives messages and per-\nforms operations based on the messages received and the system\u2019s state. That is, during \nthe power-on initialization state, the system only reacts to the GetStatus, SelfTest, and the \nSoftwareUpdate message. Once the SelfTest message is received, the system transitions \nto the self-test state, where system capabilities are evaluated to determine the integrity \nof the system. Once the self-test state is complete, two transitions can occur; if the tests \nwere successful then the system transitions to the operational state, and if any failures are \nencountered then the system enters a fault state, in which no commands can be executed. Once the fault state is complete, the system transitions to a power-down state, which allows \nthe system to save all pertinent information to the file system before transitioning to the \n\u00ad\ninitialization (Power On) state.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 286", "position": 286, "chunk_type": "semantic", "token_estimate": 395}
{"text": "262\u2002 \u2022\u2002 Software Engineering Design\ufeff: Once the self-test state is complete, two transitions can occur; if the tests \nwere successful then the system transitions to the operational state, and if any failures are \nencountered then the system enters a fault state, in which no commands can be executed. Once the fault state is complete, the system transitions to a power-down state, which allows \nthe system to save all pertinent information to the file system before transitioning to the \n\u00ad\ninitialization (Power On) state. Upon successfully execution of the self-test state, the system transitions to the operational \nstate, where all messages in the system can be processed, including the SelfTest message and \nShutDown message. As seen, the state diagram presents the state of the system, together \nwith the transitions and the events that trigger each transition. Unlike the flow-based design", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 286", "position": 286, "chunk_type": "semantic", "token_estimate": 139}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 263: approach in the previous section, the system\u2019s state-based designs show the flow of opera-\ntions from state to state; it acts like a well-structured algorithm that is efficient, simple, \nadaptable, and understandable (Booch, Rumbaugh, and Jacobson 2005). It also presents \nthe full operation of a complete system during its lifetime, which can be derived from the \ndesign. Consider the implementation of Listing 8.1, which implements the state machine. Initially, the system is set to the Power-OnState; therefore, upon executing the code the \nexecutePowerOnState() method is called to process the received message and deter-\nmines if a state change is required (or not), as seen in Listing 8.2. Listing 8.2 uses a message \nqueue for retrieving messages received in the system. Branch\nTransition\nIf Statement\nCase Statement\ntrue\ntrue\ntrue\ntrue\nAction\nFinal State\nActivity 1\nActivity Diagram Examples\nInitial State\nElements in Activity Diagram\nActivity2\nActivity3\nActivity5\nActivity6\nActivity1\nfalse\nfalse\nfalse\nfalse\nDo While Loop\nActivity4\nActivity7\nActivity8\ntrue\nfalse\nWhile Loop\nFIGURE 8.1\nFlow-based logic design using UML activity diagrams.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 287", "position": 287, "chunk_type": "semantic", "token_estimate": 178}
{"text": "264\u2002 \u2022\u2002 Software Engineering Design\ufeff: The source of the code presented in Listing 8.2 can be traced back to the state design \npresented in Figure\u00a08.2. As seen, once the EmbeddedComponent is in the power-on state, \nit can execute the messages only for updating the software, retrieving the component\u2019s \nstatus\u00ad\n, and executing a self-test. Messages containing different IDs cannot be executed in \nthis state; therefore, upon receiving any other message the system logs an event and waits \nfor the next message to be received. In a similar fashion, the code for all other states is \nimplemented according to the state design, as presented in Listings 8.3 and 8.4. As seen, once the EmbeddedComponent enters the self-test state, it executes the appro-\npriate tests, and based on the tests results it sets the new system state to the operational \nor fault state, as defined in the state design. Assuming all tests are performed successfully, \nthe EmbeddedComponent transitions to the operational state, where all messages can be \nreceived and processed by the EmbeddedComponent. The implementation for the opera-\ntional sate is presented in Listing 8.4. Table-Based Designs\nMany times, the internal logic of routines is made up of complex conditional statements, \neach statement evaluating a condition (i.e., a cause) and providing some action (i.e.,\u00a0an \neffect) as a result. This can lead to an increasingly complex nesting structure that is \nerror-prone, hard to read, and hard to maintain. In these cases, the logic design can be \nmanaged using a decision table (Hurley 1982). A decision table is a well-structured table \nthat provides the means to formulate, evaluate, and improve the design of complex prob-\nlems that deal with cause and effect. The format of decision tables is presented in Table\u00a08.1. Table\u00a08.1 has four different sections. The first section is the Condition section, which \ncontains a list of all of the conditions present in the decision problem. The second \u00ad\nsection \nis the Action section, which contains a list of all possible outcomes that can result from one \nor more conditions occurring. The third and fourth sections are found in matrix form, \nadjacent to the Condition and Action sections. The matrix adjacent to the Condition \u00ad\nsection \nindicates all possible combinations of conditions for the decision problem, while the \nmatrix adjacent to the Action section indicates the corresponding actions.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 288", "position": 288, "chunk_type": "semantic", "token_estimate": 389}
{"text": "264\u2002 \u2022\u2002 Software Engineering Design\ufeff: The third and fourth sections are found in matrix form, \nadjacent to the Condition and Action sections. The matrix adjacent to the Condition \u00ad\nsection \nindicates all possible combinations of conditions for the decision problem, while the \nmatrix adjacent to the Action section indicates the corresponding actions. Combined, the \nSelfTest\nFault\nOperational\nPower On\nSelfTest\nMsg Received\nSelfTest Msg Received\nFault Processing\nComplete\nAll Other\nMessages Received\nPower Down Process Complete\nGetStatus Msg\nUpdateSoftware Msg\nShutDown\nMsg Received\nTest Passed\nTests did not pass\nPower\nDown\nFIGURE 8.2\nExample of a state design using UML state diagrams.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 288", "position": 288, "chunk_type": "semantic", "token_estimate": 102}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 265: respective columns in both matrices provide a policy for decision making in the \u00ad\ndecision \n\u00ad\nproblem. Four types of decision tables are as follows (Hurley 1982):\n\u2022\t Limited-entry decision table (LEDT)\n\u2022\t Extended-entry decision table (EEDT)\n\u2022\t Mixed-entry decision table (MEDT)\n\u2022\t Hybrid-entry decision table (HEDT)\nListing 8.1: C++ Implementation of the State Design\n// The state machine\u2019s execute method. void EmbeddedComponent::execute() {\n\t // Execute the state machine. _compnentState is a member variable\n\t // of the EmbeddedComponent class. switch( _componentState ) {\n\t \t case PowerOnState:\n\t \t \t // Execute in the power on state. When finished, allow the\n\t \t \t // executing function to determine if a state change is required\n\t \t \t // (or not) and set the state appropriately. This capability is\n\t \t \t // provided by executing functions in all other states. executePowerOnState();\n\t \t \t break;\n\t \t case SelfTestState:\n\t \t \t // Execute in the self test state. executeSelfTestState();\n\t \t \t break;\n\t \t case OperationalState:\n\t \t \t // Execute in the operational state. executeOperationalState();\n\t \t \t break;\n\t \t case FaultState:\n\t \t \t // Execute in the fault state. executeFaultState();\n\t \t \t break;\n\t \t case PowerDownState:\n\t \t \t // Execute in the power down state. executePowerDownState();\n\t \t \t break;\n\t \t default:\n\t \t \t // invalid state, log error. break;\n\t }\n}", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 289", "position": 289, "chunk_type": "semantic", "token_estimate": 186}
{"text": "266\u2002 \u2022\u2002 Software Engineering Design\ufeff: Limited-Entry Decision Table\nThe LEDT is the simplest type of decision table in which the condition section of the \nLEDT presents Boolean conditional statements. That is, the condition section of the LEDT \n\u00ad\npresents features of the design problem that are either present or not, and their combined \npresence (or absence) triggers specific actions. Therefore, the condition entry section of \nthe LEDT consists of Boolean values, such as true or false or yes or no, that can be used to \ndefine different policies in the decision problem. For example, consider the LEDT design \nfor a function that computes discounts for the purchase of mobile phones. Two types of \ndiscounts are available, a store discount of $15 and a manufacturer discount of $30, as \npresented in Table\u00a08.2. Using the information specified in the LEDT from Table\u00a08.2, the code for the function \nused to compute phone discounts can be easily implemented, simply by translating the \ninformation captured in the LEDT to code, as presented in Listing 8.5. The table name is \nListing 8.2: C++ Implementation of the PowerOn State\nvoid EmbeddedComponent::executePowerOnState() {\n\t // Assume messages are received and placed in a blocking message\n\t // queue. Therefore, the messageQueue.read call is a blocking call. Message* message = messageQueue.read(WAIT_FOREVER);\n\t // Retrieve the message\u2019s id. MessageIdType messageId = message->getId();\n\t // This state only processes three messages according to the state\n\t // diagram. if( messageId == UpdateSoftwareMsgId ) {\n\t \t // Cast message to an UpdateSoftwareMsg. // Retrieve the software image from the message and update\n\t \t // software.\n\t } else if( messageId == GetStatusMsgId ) {\n\t \t // Retrieve status from File System and return to client.\n\t } else if( messageId == SelfTestMsgId ) {\n\t \t // Cast message to a SelfTestMsg. // Retrieve the type of self test and change state. selfTestType_ = message->getTestType();\n\t \t _componentState = SelfTestState;\n\t }\n\t else {\n\t \t // Any other message received in this state results in an error. // Log the specific error here and do not change state.\n\t } }", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 290", "position": 290, "chunk_type": "semantic", "token_estimate": 334}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 267: Listing 8.3: C++ Implementation of the SelfTest State\nvoid EmbeddedComponent::executeSelfTestState() {\n\t // No messages are processed during self test. // Perform either a simple, normal, or advanced test. Advanced tests\n\t // perform a complete test of the system, therefore they take\n\t // longer to complete. if( performTest(_selfTestType) ) {\n\t \t // Software and hardware are working properly. Log results and\n\t \t // change state to the operational state. _componentState = OperationalState;\n\t }\n\t else {\n\t \t // Faulty system software or hardware! Log results and change\n\t \t // state to the Fault state. _componentState = FaultState;\n\t }\n}\nListing 8.4: C++ Implementation of the Operational State\nvoid EmbeddedComponent::executeOperationalState() {\n\t // Assume messages are received and placed in a blocking message\n\t // queue. Therefore, the messageQueue.read call is a blocking call. Message* message = messageQueue.read(WAIT_FOREVER);\n\t // Retrieve the message\u2019s id. MessageIdType messageId = message->getId();\n\t // Process messages according to the state diagram. if( /* messageId == x */ ) {\n\t \t // Process message x.\n\t } else if( /* messageId == y */ ) {\n\t \t // Process message y.\n\t } else if (/* ... */ {\n\t \t // ...\n\t }\n\t else {\n\t \t // Invalid message. Log error.\n\t } }", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 291", "position": 291, "chunk_type": "semantic", "token_estimate": 197}
{"text": "270\u2002 \u2022\u2002 Software Engineering Design\ufeff: Additionally, discounts of $70, $180, or $370 (i.e., the sum of all dis-\ncounts) can be applied toward the purchase of a special phone. The problem is formulated \nusing the decision table presented in Table\u00a08.4. Using the information presented in Table\u00a08.4, the construction of the function applying dis-\ncounts to phone products can take place. Listing 8.6 presents the code for the phone type used \nin this problem. As seen, the phone type includes interface methods for returning a phone\u2019s \ntype (i.e., simple, advanced, or special phone) and the particular discount that applies the \nphone type. Using the phone type created, the code for the (getPhoneDiscount) function is presented \nin Listing 8.7. As seen, the code matches the table-based design presented in Table\u00a08.4. Table-Based Construction\nTable-based construction is a technique for transforming table-based designs to code \nthat is easy to maintain, read, and so forth. As seen, the resulting code for implementing \nthe table-based design from Table\u00a08.4 contains various conditional statements. Similarly, \ntable-based designs can result in complex code that is hard to read and maintain. When", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 294", "position": 294, "chunk_type": "semantic", "token_estimate": 186}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 279: Naming Conventions\nNaming conventions can help programmers develop models for differentiating different \naspects of software programs and maintain consistency through software items. This can \nin turn result in code that is self-documented by the use of conventions applied consis-\ntently in the code. Naming conventions can be used to differentiate all elements that com-\npose a software program; therefore, consistent use of naming style can help software teams \nto better understand the work done by each other. When applied consistently, styles can \neasily help software developers, testers, and maintainers understand the code and make \nassumptions about it based on the programming style. A general naming convention that applies to all elements in a software program is the \nuse of meaningful names. Meaningful names are ones that are complete and contextually \ncorrect. Naming conventions should lead to names that unambiguously and completely \ndefine the intent of the entity that they represent. Names should be chosen so that they \nclearly define entities so that they quickly become familiar to those who read and maintain \nthe code. Failure to select meaningful names can result in code that is hard to understand, \nfollow, and maintain. Examples of bad and good examples of meaningful names are pre-\nsented in Listing 8.17. Listing 8.17 presents several cases of good and bad names. Example 1 presents the \nchoice of using rdo1 and rdo2 for names to describe two Radio objects. These names \nare incomplete and as a consequence can make the code hard to understand, debug, and \nListing 8.15: In-line Bracket Placement Style\n// Inline brace placement style in C++ class definition. class List {\n\t // ...\n};\n// Inline brace placement style in function definition. void append() {\n\t // ...\n}\n// Inline brace placement style in conditional statements. if( condition == true ) {\n\t // ...\n}\nelse {\n\t // ...\n}\n// Inline brace placement style in loops. while( condition == true ) {\n\t // ...\n}", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 303", "position": 303, "chunk_type": "semantic", "token_estimate": 329}
{"text": "280\u2002 \u2022\u2002 Software Engineering Design\ufeff: maintain. Example 2 shows the usage of the name xmit to abstract the transmission func-\ntion of a radio object. Developers who are not familiar with this abbreviation of the word \ntransmit may find it difficult to find the appropriate function call in the documentation \nto transmit a message. In addition, consider the case where the integrated development \nenvironment (IDE) supports the intellisense feature. In this case, developers would intui-\ntively and without success type the letter t in hopes that the IDE would reveal a function \nname that somewhat relates to the transmission behavior required by the radio object. Example 3 presents the case where the name chosen is both incomplete and inappropri-\nate for the program\u2019s context. That is, it is hard to determine the correct meaning of the \ncode when using s and MaxAmount. This is mainly because s does not describe the entity \nbeing evaluated and MaxAmount can refer to multiple limits that relate to different prop-\nerties (e.g., max salary, max number of items). These names are improved by making them \ncomplete and appropriate for the context. Finally, Example\u00a04 presents an example of a \ncontextually inappropriate name for an object of type DirectoryManager. In this case, \nobjects of type DirectoryManager monitor a directory for cleanup. Once the directory \nreaches a specified threshold, objects of the DirectoryManger type would begin delet-\ning files. The choice of name reaper and destroy are not appropriate for this context. Reaper and destroy seem more appropriate for a gaming context; therefore, the names are \nimproved by replacing them to describe better the actions of these objects. Listing 8.16: New-Line Bracket Placement Style\n// Newline brace placement style in C++ class definition. class List\n{\n\t // ...\n};\n// Newline brace placement style in function definition. void append()\n{\n\t // ...\n}\n// Newline brace placement style in conditional statements. if( condition == true )\n{\n\t // ...\n}\n// Newline brace placement style in loops. while( condition == true )\n{\n\t // ...\n}", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 304", "position": 304, "chunk_type": "semantic", "token_estimate": 340}
{"text": "282\u2002 \u2022\u2002 Software Engineering Design\ufeff: Documentation Conventions\nSimilar to formatting and naming conventions, documentation conventions can also \nbe (almost universally) applied to projects in different domains and with different pro-\ngramming languages. Documentation conventions deal with styles and specifications for \nwhat to document and how to document during construction. Generally, if the naming \nconventions are followed, comments should provide information that describes why an \noperation is written as opposed to what the operation is doing. In many cases, the actions \nperformed by operations (or blocks of codes) can be inferred from the naming conven-\ntions or programming syntax; however, the reasons behind the choice of code cannot be \ninferred as easily. Therefore, comments should provide the reasons why code was written \nand, when necessary, what the code is doing. Documenting Files\nIn software construction, files are units of cohesive work. In some architectural efforts, \nusing the development view discussed in Chapter 3, systems are decomposed using files \n(and directories) as a main unit of system decomposition. Therefore, files should be well \ndocumented in a clear and concise manner so that clients of the file can understand the \nactions carried out by its contents. Depending on the language, files can contain one or \nmore classes, one or more functions, or one or more variable, constant, or type definitions. In all cases, file documentation is necessary for managing the file throughout its lifetime. File documentation can vary from company to company or even from project to proj-\nect within a same company. However, at a minimum, file documentation should contain \nheader information that identifies the contents of the file, description, and original author. In addition, file documentation can include other important information, such as revision \ninformation (e.g., bug fixes or enhancements), classification (mostly for companies that \nwrite software for national security purposes) of the file\u2019s content, and any restrictions\u00ad\n asso-\nciated with the file\u2019s content. An example of file documentation is presented\u00ad\n in Listing\u00a08.18. Documenting Functions\nSimilar to files, functions are units of work; however, they operate on a smaller scale. Therefore, their intent should be well documented in a clear and concise manner so that \ntheir clients can understand the actions carried out by the function\u2019s contents. Functions \noperate on a finer-grained context than files; therefore, their documentation should be \nspecific to the work performed by the functions. Information such as classification and \nhistory can be deferred to the file\u2019s documentation.", "domains": ["Software Quality Attributes", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 306", "position": 306, "chunk_type": "semantic", "token_estimate": 401}
{"text": "284\u2002 \u2022\u2002 Software Engineering Design\ufeff: simple and readable rather than clever (Abran et al. 2005). Some important standards that \ncan be created for software projects include the software development plan, the software \nversion document, the interface control document, and the programming style standard, \nas presented in Chapter 5.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 308", "position": 308, "chunk_type": "semantic", "token_estimate": 48}
{"text": "The construction design activity is the last major design step performed before construc-: tion. Therefore, it provides the last opportunity to evaluate the quality of the system\u00ad\n \nto be built. There are numerous project-specific quality characteristics (e.g., security\u00ad\n, \nusability) that can be identified and evaluated for construction designs. However, at \na minimum, the design\u2019s completeness, correctness, testability, and maintainability \nshould be evaluated, since these generally apply to all software projects. Completeness and correctness deal with the degree to which construction designs cor-\nrectly meet the allocated requirements. Construction designs that are correct, but incom-\nplete, complete but incorrect, or incomplete and incorrect\u2014those that do not meet all \nrequirements, are incorrect, or both\u2014need to be addressed and resolved to maintain the \nenvisioned software quality of the product. Completeness and correctness can both be \nevaluated through peer reviews, unit testing, and audits. In all of these activities, the use of \nchecklists\u2014one of the seven common tools of quality\u2014is essential. In other cases, incom-\nplete designs are the product of incomplete specifications. In these cases, construction \nListing 8.19: Style for File Documentation\n//*******************************************************************\n// METHOD:\t\nEventLogger::log(EventId id, string description)\n//\n// DESCRIPTION:\t This function writes events occurring in the system \n//\t\nto the event console. Events are displayed together\n//\t\nwith their classification and description, which are\n//\t\nboth provided by the client\u2019s calling function. //\t\nIn addition, the number of events received for each\n//\t\ntype of event is computed and displayed in the event\n//\t\nconsole. Events are required to have id and\n//\t\ndescription. //\n// RETURNS:\t\nThe function returns a boolean value indicating\n//\t\nsuccess/failure of the operation. //\n// PRE-CONDITIONS:\t ...\n// POST-CONDITIONS:\t...\n//\n//*******************************************************************", "domains": ["Software Quality Attributes", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 308", "position": 308, "chunk_type": "semantic", "token_estimate": 279}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 285: designs can be further analyzed using prototypes for eliciting the required capabilities to \ncomplete the specifications and therefore the construction design. Testability quality (in construction design) deals with the amount of effort required to \ntest artifacts that are the result of construction design. On the other hand, a design\u2019s main-\ntainability deals with the amount of effort required to maintain a tested artifact that is the \nresult of construction design. Both testability and maintainability goals can be achieved \nin many ways, as determined by nonfunctional requirements of the project. A common \napproach for evaluating the testability and maintainability of construction designs includes \nthe measurement of the design\u2019s cyclomatic complexity (McCabe 1976); therefore, testabil-\nity and maintainability goals can be transformed into requirements that are based on the \ncyclomatic complexity. In addition, maintainability quality can also be evaluated by the \ncompliance of the resulting implementation of construction design to the programming \nstyle defined for the project. Pressman (2010, p. 437) states that \u201csource code and related \nwork products must conform to local coding standards and exhibit characteristics that will \nfacilitate maintainability.\u201d Therefore, evaluation techniques that enforce 100% compliance \nwith local styles of programming must be in place. Peer Reviews\nPeer reviews are tasks that concentrate on verifying and validating designs and code \n(i.e.,\u00a0design reviews and code reviews, respectively). Peer reviews must be planned, orga-\nnized, and conducted in such a way that a collective approval among all members of the \nproject (with different disciplines) is reached. The main tasks are performed by techno-\nlogically savvy engineers and domain experts that can verify and validate the items of \nreview. In addition, the presence of an auditor (or software quality personnel) is required \nto inspect both processes and products. Finally, members of the software testing and main-\ntenance team can contribute highly to the review of items. A great deal of time during code review is spent evaluating code. In many practical situ-\nations, where requirements have been established to meet a specific programming style, it \ncan be time-consuming to read code line by line to validate that the code meets the style\u2019s \nrequirements. In these cases, the use of automated style checkers can provide significant \nbenefits. Automated style checkers are tools that can be configured to enforce a \u00ad\nspecific \nstyle of programming. Some of the capabilities provided by automated style checkers \ninclude checks for numerous conventions.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 309", "position": 309, "chunk_type": "semantic", "token_estimate": 402}
{"text": "286\u2002 \u2022\u2002 Software Engineering Design\ufeff: \u2022\t Good practices for class design\n\u2022\t Checks for duplicated code sections\n\u2022\t Checks cyclomatic complexity against a specified threshold\n\u2022\t Other multiple complexity measurements\nUnit Testing\nUltimately, the quality of construction designs in terms of completeness and correctness \nis\u00a0evaluated through unit testing. Therefore, as construction designs are created, so are unit \ntests. One or more unit test cases are essential for verifying and validating construction \ndesigns. A sample unit test case is presented in Table\u00a08.5. Cyclomatic Complexity\nCyclomatic complexity is a technique developed by McCabe (1976) that can be used for \nevaluating the quality of flow-based designs. It is a mathematical technique based on graph \ntheory that provides a quantitative justification for making design decisions that lead to \nhigher quality in terms of a design\u2019s maintainability and testability. The cyclomatic com-\nplexity computation allows designers to measure the complexity of flow-based operational \ndesigns by determining the complexity of the decision structure of operations instead of \nlines of code. In his original work, McCabe illustrated the correlation between intuitive \ncomplexity and the graph-theoretic complexity of several programming operations and \nshowed that the complexity of an operation had less to do with physical size and more to \ndo with the decision structure of the operation. By using this approach, the cyclomatic \ncomplexity provides not only a measurement of the complexity of flow-based designs but \nalso a measurement of the maximum number of independent paths required to fully test \nthe operation (Galin 2003). Therefore, cyclomatic complexity can be used to determine the \nmaintainability (i.e., understandability) and testability of flow-based designs. The cyclomatic complexity technique works by computing the cyclomatic number v(G) \nof a graph G with n vertices, e edges, and p connected components, as seen in Equation 8.1.\n\t\nv G\ne\nn\np\n( )= \u2212+ 2 \t\n(8.1)\nFor a strongly connected graph G\u2014in which there is a path connecting any pair of arbi-\ntrary distinct nodes\u2014the cyclomatic number is equal to the maximum number of linearly \nindependent circuits (McCabe 1976). Therefore, flow-based designs can be associated with \ndirected, strongly connected graphs that have unique entry and exit points, where each node \ncan be reached from the entry node, and each node can reach the exit node.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 310", "position": 310, "chunk_type": "semantic", "token_estimate": 373}
{"text": "288\u2002 \u2022\u2002 Software Engineering Design\ufeff: in the parent and child operations, which can be equal to the number of operations (parent \nand child operations) being evaluated. It is important to note that when p \u2260 1, the complex-\nity measure will be equal to the summation of the individual complexities of each connected \ncomponent, since complexity measures are\u00a0additive. Computing the cyclomatic complexity for large operations can be tedious; therefore, \ntwo simplification methods are available for easily computing the cyclomatic complexity \nof \u00ad\nsingle-component graphs (i.e., p = 1). The first method allows for the computation of \ncomplexity in terms of a program\u2019s decision constructs, such as if statements, while loop, for \nloop, and case statements. Mills (1972) proved that the cyclomatic complexity (C) of a struc-\ntured program meeting the control graphs requirements previously mentioned is equal to \nthe number of conditions in the code (\u03c0) plus 1, as seen in Equation (8.2). C =\n+\n\u03c0 1\t\n(8.2)\nThe number of conditions (\u03c0) can be easily measured as follows. Conditional statements, \nsuch as if statements, while loop, and for loop, all count as one unit of complexity. Compound \nconditional statements, such as if x and y then z, count as two complexity units, since with-\nout the connective and the condition would have to be specified as if x then, if\u00a0y\u00a0then z \n(McCabe 1976). Case statements, such as the switch statement in C++, Java, and C#, or other \nconditional statements containing multiple n branching statements are counted as \u03c0 = n \u2013 1 \nunit of complexity. The second simplification approach allows for the visual determination of complexity via \nthe program\u2019s control graph (i.e., flow-based design). This approach is based on the work of \nmathematician Leonhard Euler, who proved that for connected planar graphs\u2014those with-\nout intersecting edges\u2014the regions (r) of a graph can be computed using Equation\u00a0(8.3), \nknown as Euler\u2019s formula. 2 =\n\u2212+\nn\ne\nr \t\n(8.3)\nA region is an area enclosed by arcs; therefore, given the characteristics of the program \ncontrol chart, the number of regions enclosed by arcs, plus one that resides outside the \ngraph, is equal to the cyclomatic complexity of the graph. All three methods for computing \nthe cyclomatic complexity of a program control graph are presented in Figure\u00a08.3. The top-left corner of Figure\u00a08.3 represents the program control graph designed using a \n(flow-based) activity diagram.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 312", "position": 312, "chunk_type": "semantic", "token_estimate": 398}
{"text": "288\u2002 \u2022\u2002 Software Engineering Design\ufeff: All three methods for computing \nthe cyclomatic complexity of a program control graph are presented in Figure\u00a08.3. The top-left corner of Figure\u00a08.3 represents the program control graph designed using a \n(flow-based) activity diagram. As seen, the program control graph represents a case state-\nment with five branches; therefore, the number of conditions (\u03c0) is equal to 5 \u2013 1 = 4 and \nthe cyclomatic complexity, using Equation (8.2), is C = 4 + 1 = 5. This can be easily verified \nwith Equations (8.1) and (8.3). For example, using Equation (8.1), the cyclomatic complex-\nity is v(G) = 10 \u2013 7 + 2(1) = 5. The top-right corner presents the evaluation of complexity of a program control graph \nusing the regions visual inspection. As seen, the number of regions of the planar graph is \nfive; therefore, the cyclomatic complexity of the design is five. This can easily be verified \nby rearranging Equation (8.3) to solve for r, which results in r = 9 \u2013 6 + 2 = 5. Finally, the \nbottom of Figure\u00a08.3 presents a more complex program design, which includes 23 nodes", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 312", "position": 312, "chunk_type": "semantic", "token_estimate": 192}
{"text": "The transition from software design to construction should occur with minimal effort.: In\u00a0some cases, component designs provide enough detail to allow their transformation from \ndesign artifact into code easily; however, in other cases, a more fine-grained level of design \ndetail is required. Construction design provides a form of design that closely resembles code \nso that complex operations can be planned and evaluated prior to implementation in code. Once the correctness of operations is verified, the construction design activity provides \nadditional heuristics to enforce consistency in the code. Construction designs are typically \ncreated using the following techniques: flow-based, state-based, table-based, and program-\nming design language. Each method provides its own benefits; therefore, careful attention \nshould be paid when selecting the appropriateness of construction designs in practical \napplications. The benefits acquired from designing complex functions and enforcing styles \nfor consistency are essential to maintaining each system\u2019s envisioned quality.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 314", "position": 314, "chunk_type": "semantic", "token_estimate": 147}
{"text": "1.\tWhat is construction design, and why is it important?: 2. List and explain common quality attributes that can be addressed during construc-\ntion design. 3. Why are styles important during construction? 4. What are flow-based designs, and how do they relate to UML activity diagrams? 5. Describe the following elements of an activity diagram:\n\t\na. Initial state\n\t\nb. Final state\n\t\nc.\t Action\n\t\nd.\t Branch\n\t\ne.\t Transition\n\t\n6. What are state-based designs, and why are they important for construction design? 7. How are state-based designs typically translated to code? 8. What are table-based designs, and why are they important for construction design? 9. Compare and contrasts the following:\n\t\na.\t Limited-entry decision table\n\t\nb.\t Extended-entry decision table\n\t\nc.\t Mixed-entry decision table", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 314", "position": 314, "chunk_type": "semantic", "token_estimate": 120}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 291: 10. How are table-based designs used to decrease code\u2019s complexity and increase both \nreadability and maintainability? 11. In decision tables, what are missing policies and redundant actions? How does iden-\ntifying these help make more efficient tables? 12. What is programming design language, and what is the main benefit that it provides \nover other construction design methods? 13. How are construction styles used to decrease code\u2019s complexity and increase both \nreadability and maintainability? 14. What are the main methods used for evaluating quality of construction designs? 15. List and explain an efficient method for enforcing styles during construction. 16. What is cyclomatic complexity? Name three different ways to compute the cyclo-\nmatic complexity of a function during construction design. 17. What is the relationship between cyclomatic complexity and software quality? Explain.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 315", "position": 315, "chunk_type": "semantic", "token_estimate": 137}
{"text": "1.\tSelect a project of choice, and identify three different functions that can be designed: using flow-based, table-based, and state-based design. Create the designs for these \nfunctions, and prepare a 5- to 10-minute presentation including designs, code, \nand\u00a0justification. 2. Compute the cyclomatic complexity of the following code using all three methods:\nswitch( state ) {\n\t case ONE:\n\t \t // Perform activity. if( /*some condition*/ ) {\n\t \t \t // Perform activity.\n\t \t } else if( /*some condition*/ ) {\n\t \t \t // Perform activity.\n\t \t } else {\n\t \t \t // Perform activity.\n\t \t } break;\n\t case TWO:\n\t \t // Perform activity FIVE. break;", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 315", "position": 315, "chunk_type": "semantic", "token_estimate": 94}
{"text": "293: 9\nHuman\u2013Computer Interface Design\nJacob Somervell\nUniversity of Virginia, College at Wise", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 317", "position": 317, "chunk_type": "semantic", "token_estimate": 13}
{"text": "\u2022\t Understand the role that the computer interface plays in high-quality: and successful software systems\n\u2022\t Describe how to address interface design and evaluation within the \nsoftware development life cycle\n\u2022\t Provide usable guidance for evaluating designs", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 317", "position": 317, "chunk_type": "semantic", "token_estimate": 37}
{"text": "To end users, the interface is the system. Most end users do not know, nor: do they even need to know, about the underlying structure and implemen-\ntation of the software system. They are concerned only with the interface \npresented to them and the capabilities provided by that interface. Consider \nthe analogy of driving a car: the driver does not need to know anything \nabout how an internal combustion engine works and how it is connected \nto the transmission to send power to the wheels, nor do they need to know \nabout hydraulics and fluid dynamics of the braking system to actually \ndrive a car. Indeed, mainly the driver needs to know that \u201cD\u201d means drive \n(assuming an automatic transmission), press gas pedal to go, press brake \npedal to stop. The same concept applies to software systems. End users are \nconcerned only with what they can do with the system and how they do it, \nnot with how it works \u201cunder the hood.\u201d Hence, it is of vital importance to \nget the interface design sufficiently correct so that it serves users in an efficient \nand usable \u00ad\nmanner. This chapter shifts the focus away from the detailed \nunder-the-hood approach to design to cover the essential human\u2013computer \ndesign activity. The chapter focuses on providing valuable information on \nhow to create effective and usable interfaces for software systems.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 317", "position": 317, "chunk_type": "semantic", "token_estimate": 226}
{"text": "294\u2002 \u2022\u2002 Software Engineering Design: WHAT IS HUMAN\u2013COMPUTER INTERFACE DESIGN? So what does it mean to \u201cget it right?\u201d As part of the software design process, human\u2013computer \ninteraction (HCI) design must account for the user of the software. While designing the \narchitecture and detailed design of software systems is essential for meeting most quality \nattributes, designing an efficient user interface that is understandable by the end user is \nparamount to the usability quality of all successful software systems. The most elegant, \nefficient, and high-quality architectural and detailed designs can be felled by a poor inter-\nface. In the context of HCI, interface design refers to the creation of the user interface. IEEE (1990, p. 80) defines the user interface as follows:\nAn interface that enables information to be passed between a human user and hardware or \nsoftware components of a computer systems. For most software, this entails designing the graphical user interface (GUI). This involves \nselecting appropriate information presentation and interaction techniques for the various \nend-user classes (Rosson and Carroll 2002). More specifically this entails selecting appro-\npriate information layouts, correct language, appropriate interface controls (e.g., radio but-\ntons versus check boxes), and tying the detailed design to the various input mechanisms \nprovided in the interface. An essential task of the HCI design activity involves making sure that the interface provides \nappropriate means for using the system in an efficient manner. The best way to ensure an inter-\nface is sufficiently good is to iteratively improve the design through user testing. The implication \nis that there will be multiple iterations of a process that includes the following HCI design tasks:\n\u2022\t Creating a prototype of the system\n\u2022\t Having end users use that prototype in realistic ways\n\u2022\t Gathering data from these tests\n\u2022\t Redesigning the interface to address discovered problems\nAll of this work (choosing appropriate information representation and interaction methods) \nhinges on a thorough understanding of the users of the system. It is paramount to learn \nhow the users typically perform similar actions and what their expectations of the new \nsystem may be. This information is gleaned through detailed requirements gathering and \nanalysis and through significant user testing. WHY STUDY HUMAN\u2013COMPUTER INTERFACE DESIGN? The HCI design activity is where general principles are applied to optimize the interface \nbetween humans and computers. Visual designs have a major role in the success or failure", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 318", "position": 318, "chunk_type": "semantic", "token_estimate": 394}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 295: of software systems. Systems that meet functional requirements but are not usable cannot\u00ad\n \nsucceed. The major concerns of the HCI designs may include the evaluation and use of \nmodes, navigation, visual designs, response time and feedback, and design modalities, \nsuch as forms and menu-driven. HCI designs directly influence the quality of any system \nand are essential to understanding and addressing the factors that affect the overall usabil-\nity of the system. Many design principles and evaluation techniques exist to successfully \ndesign user interfaces. Therefore, understanding the techniques and tools for designing \ninterfaces allows designers to become proficient in creating efficient interfaces. Providing \nan interface that allow users to accomplish their goals with the software, without unneces-\nsary effort, is the ultimate goal of the user interface designer. The \u201cwithout unnecessary effort\u201d clause is important. Consider a system that requires a \ndate from the user, as presented on Iteration 1 of Figure\u00a09.1. The user interface could ask the user to type in the date in a text box. Without any extra \ninformation a user could type any of the following:\n\u2022\t Jan 1, 2011\n\u2022\t 1 / 1/ 11\n\u2022\t 1 - 1 - 11\n\u2022\t 1 January 2011\nWhich format was expected by the software? If the information typed by the user doesn\u2019t \nmatch the format, what happens? An error message? Program crash? The most flexible \noption involves allowing all of these and others as valid input and then correctly parsing the \ninput to find the appropriate fields for month, day, and year from that input string. This is a \nnontrivial solution and does not help the user form a basis or understanding of the desired \ninput. A simpler solution involves adding a label to the input box specifying the appropriate \nformat (i.e., MM/DD/YYYY), as presented on Iteration 2 of Figure\u00a09.1. This option works \nDate:\nDate: (MM/DD/YYYY)\nDate: (MM/DD/YYYY)\nInvalid Date\nIteration 3\nIteration 2\nIteration 1\nFIGURE 9.1\nSimple data entry user interface.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 319", "position": 319, "chunk_type": "semantic", "token_estimate": 331}
{"text": "296\u2002 \u2022\u2002 Software Engineering Design: fine and helps the user understand the expected formats for date objects, knowledge that \ncan be leveraged in other software systems with similar requirements. Finally, to address \ninput errors, error indicators in the interface are introduced to help guide the user to the \ncorrect input format, as presented on Iteration 3 of Figure\u00a09.1. Typically, a red error indica-\ntor (e.g., as a background color on input boxes) is a passive way of accomplishing this. Many other options for date input could be used instead, including drop-down lists, graph-\nical mini-calendars for selecting the date, and spinners. Each of these options has been used \nwith varying levels of success in various applications. Learning which method works for \na specific software system requires end-user testing: create prototype systems or mock-ups \nwith each design choice, have users complete realistic tasks using these systems, record infor-\nmation about the users\u2019 performance (e.g., speed, accuracy), and empirically determine the \nbest design. This effort is significant and requires time and resources to accomplish correctly. The point of this discussion is that the interface (the presented information to the user) \nplays a significant role in the utility of the software and the experience of the user. Carefully \nconsidering the user and the user\u2019s abilities when designing the interface can only increase \nthe usability of the software system. Thorough testing of the design, with end users, is \nparamount to designing successful software systems. So how do we go about involving the user in the process? One must spend time early in \nthe software development life cycle identifying the user classes for the software. A user class \nis a set of users who share common tasks with the software. Consider a student information \nsystem that may be used by a university. Clearly, one class of user would be the students. Another obvious class would be the faculty. Other classes that might not be immediately \nobvious could include department chairs, registrar, advisors, enrollment management staff, \nand financial aid staff. There could be others. Furthermore, a single person could take on the \ncharacteristics of multiple classes. For example, a faculty member could also be an advisor \nand a department chair. Each of the user classes to which a user belongs contributes to the \ntype of work that that user should be able to perform with the software.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 320", "position": 320, "chunk_type": "semantic", "token_estimate": 392}
{"text": "296\u2002 \u2022\u2002 Software Engineering Design: For example, a faculty member could also be an advisor \nand a department chair. Each of the user classes to which a user belongs contributes to the \ntype of work that that user should be able to perform with the software. After identifying the user classes, it is then necessary to hold requirements meetings with \nrepresentatives of each user class. These meetings should elicit the tasks that the target user \nclass should be able to do with the software as well as tasks that would be \u201cnice\u201d to have. Recall that these meetings would normally occur as part of the requirements gathering \nprocess in the overall software development life cycle, not as a separate activity, although it \ncould be separate if needed. Similar to software architects, it is common for user interface \ndesigners to go back and forth between requirements and design, until the interface is \n\u00ad\nsufficiently appropriate to accommodate the needs of users of each class. Skill Development 9.1: Eliciting Needs from Different User Classes\nCreate a list of 10 questions you would ask a group of students about their expectations \nfor a new student information system. Create a list of 10 questions you would ask a \ngroup of faculty about their expectations for the same system.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 320", "position": 320, "chunk_type": "semantic", "token_estimate": 214}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 297: After learning about the typical interactions your user classes will have with the system, \none can begin designing the user interface to meet those needs. One of the most challenging \nthings for software engineers is to disconnect from the system they are designing and try to \nsee the world through the eyes of the end user. It is tempting to simply design an interface \nthat meets the needs of the engineer or developer (e.g., for testing, verification) instead of \ndesigning an interface that meets the needs of the end user. It is up to software developers to \nmaintain a clear focus on the end user while developing the user interface for a system. The \nfollowing sections provide specific information to aid the designer in \u00ad\nfocusing on the user.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 321", "position": 321, "chunk_type": "semantic", "token_estimate": 134}
{"text": "Several design principles and heuristics exist for guiding user interface designers. Accord-: ing to Nielsen and Mack (1994), there are 10 major heuristics to follow when creating a user \ninterface:\n\t\n1. Visibility of system status: The interface should have some mechanism for showing \nwhere users are in their task. 2. Match between system and the real world: The interface should provide interaction \ntechniques that mimic or model what is expected in the real world. 3. User control and freedom: The interface should support user exploration without fear \nof breaking anything. Undo and redo should be supported. 4. Consistency and standards: The interface should use, for example, language or wording \nthat is consistent with users\u2019 expectations. Follow style guides and platform standards. 5. Error prevention: The interface should help users avoid mistakes. Always ask them \nwhen they initiate a destructive command. 6. Recognition rather than recall: The interface should support rapid and easy learning \nof the system and support recognizing features and their associated actions rather \nthan relying on memorization of unique interface widgets. 7. Flexibility and efficiency of use: The interface should provide users with shortcuts or \nother accelerators. This helps the interface get out of the way of expert users while \nallowing novice users the opportunity to become more efficient. 8. Aesthetic and minimalist design: The interface should present only the necessary infor-\nmation and no more. Extra visual elements can distract from the important information. 9. Help users recognize, diagnose, and recover from errors: Error messages should be \nexpressed in plain language (no codes), precisely indicate the problem, and con-\nstructively suggest a solution. 10. Help and documentation: Make sure the help and documentation is clearly available \nin the interface. These 10 guidelines or heuristics are generic and open. This is intentional so that they can \nbe applied across a large cross section of software systems. This generality can sometimes", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 321", "position": 321, "chunk_type": "semantic", "token_estimate": 312}
{"text": "298\u2002 \u2022\u2002 Software Engineering Design: lead to ambiguity and confusion on the part of the developer. More specific, heuristics \ncan be useful when developing software for specific platforms or systems (Somervell and \nMcCrickard 2005). However, the point is that there are some simple, straightforward things \nto consider when designing any user interface. More importantly, these 10 guidelines are \nfocused on users and strive to keep them in control of the system: the system serves the \nuser. Applying these rules in a specific application can help create an interface that users \nwill find both useful and usable. Consider a popular online calendar application as pre-\nsented in Figure 9.2. In this particular calendar application, creating an appointment relies mostly on direct \nmanipulation\u2014directly clicking on the desired day, typing in a description, including \ntime, and hitting the return key. This action is analogous to writing that information on \na desk calendar or other paper calendar. It is exactly what users expect to be able to do \nwith a calendar. In addition, there is a button (\u201cCreate event\u201d) that allows users to add \nappointments by filling in a form: some users may prefer this method of entry, especially \nfor events that occur in the future, which would require navigation within the calendar to \nenter through the direct manipulation route. A new appointment is shown immediately in \nthe day for which it is assigned. Now consider the 10 guidelines in relation to this interface. In terms of system status this \ninterface shows an entire month (or week or day) of appointments in the expected monthly \nformat. A newly created appointment appears immediately within the day for which it \nFIGURE 9.2\nExample calendar user interface.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 322", "position": 322, "chunk_type": "semantic", "token_estimate": 280}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 299: occurs. Error conditions are displayed prominently in the top center of the display in red \ntext. In terms of matching the real world, it clearly mimics the desktop calendar and heavily\u00ad\n \nutilizes that metaphor. The form and layout closely resembles other calendar applications \nso consistency and standards are followed. Users can really commit no errors in the soft-\nware, and any mistakes are easily corrected through undo or deletion capabilities. As a \nGUI application, there are no commands to learn and remember from usage to usage, and \nhelp is available through pop-up labels on hover. The design is minimal in that only the \nnecessary information is shown with extra functionality available in submenus. Overall, \nthis particular\u00ad\n interface performs well with respect to Nielsen and Mack\u2019s (1994) heuristics. This high-level analysis of the calendar application serves to illustrate a good interface \nand how a good interface will typically meet most of the general heuristics. Improvements \nto an interface will often revolve around one of the 10 areas described by these guidelines. However, these guidelines are just that: guidance. How does one go about starting the inter-\nface design process? How do we get a prototype of the system? HUMAN\u2013COMPUTER INTERFACE DESIGN METHODS\nHCI sits at the intersection of design, science, and engineering (McCrickard, Chewar, and \nSomervell 2004). To create an effective interface, the designer must rely on information from \npsychology, sociology, graphic design, human factors and ergonomics, computer \u00ad\nscience, \nand mathematics (among a plethora of other specialty areas). This implies that designers \nwork on or with a multidisciplinary team. Each of the aforementioned areas contributes to \nthe design of the interface in some specific way\u2014whether it be in leveraging the intricacies \nof the human information systems (e.g., visual, audible, haptic) through color choice, font \nchoice, line width, and so forth or in leveraging the societal norms or customs of the target \nuser class through, for example, wording, ordering of information, or icon design. Getting Started\nAlmost all design activities, regardless of discipline, start with some form of brainstorm-\ning activity. There is no specific structure required or followed; the designer simply starts \nthinking about ways to solve a problem and then drawing or writing out descriptions of \nthat solution. Often at this stage in design, the only technologies needed are kindergarten \ntools: pencils, paper, crayons, markers, scissors, tape.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 323", "position": 323, "chunk_type": "semantic", "token_estimate": 393}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 299: There is no specific structure required or followed; the designer simply starts \nthinking about ways to solve a problem and then drawing or writing out descriptions of \nthat solution. Often at this stage in design, the only technologies needed are kindergarten \ntools: pencils, paper, crayons, markers, scissors, tape. Some people prefer to work on a \nchalkboard or whiteboard and take pictures of the drawings for record keeping. In any \ncase, the point is to capture ideas and thoughts on \u201cpaper\u201d for later access. It is interesting (but not surprising) to note that the majority of interfaces (electronic) \nare rectangular. We use rectangular paper, rectangular calendars, rectangular screens, and \nrectangular books. Humans like rectangles. Most of the interfaces you will design will be \ncontained in rectangles. This fact can be leveraged when creating an interface. Furthermore, \nat least in North America, people read from left to right and from top to bottom. This is", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 323", "position": 323, "chunk_type": "semantic", "token_estimate": 158}
{"text": "300\u2002 \u2022\u2002 Software Engineering Design: taught from early childhood when parents read to their children and trace their finger \nalong with the words. Certainly by kindergarten, even before they know how to read, most \nchildren are trained to look at \u201creadable\u201d objects and materials at the top left and proceed to \nthe right and down. This knowledge is used in interface design by placing prominent infor-\nmation in the upper left corner of the interface. Take a moment to examine your favorite \nprogram. Check out the interface and identify the type of information placed in the upper \nleft quadrant. Most programs will have some important functionality located in that area \nof the interface. One notable exception is the Start menu in Windows operating systems \n(but it is still on the left). This type of understanding of the human element can help the \ninterface designer create effective and usable interfaces. Fidelity in Prototypes\nEarly design efforts generate low-fidelity prototypes of the system interface. Fidelity in this \nsense means the level of sophistication or realism in the interface (Virzi, Sokolov, and Karis \n1996). Certainly a drawing of an interface on paper, done in pencil, would require lots of \nimagination on the part of end users or clients if they were to get a feel for the intent of \nthe interface. More realism is needed when communicating design ideas to customers; \nperhaps screen shots or a simple presentation. Mostly working, high-fidelity prototypes \nare required for summative evaluations (Hix and Hartson 1993). The idea is that there is \na spectrum of fidelity when it comes to designing prototypes. Low-fidelity prototypes are \nuseful in early design for communicating and eliciting requirements from the client and \nend users. Medium-fidelity prototypes are useful for illustrating interaction sequences and \nspecific design choices. High-fidelity prototypes are required for effective end-user testing. Each level of fidelity is useful to the designer and will likely be utilized during the interface \ncreation process. Skill Development 9.2: Low-Fidelity User Interface Design\nUsing only paper and pencil, draw an interface for a ticket purchasing kiosk. The hard-\nware supports touch-screen interaction. Low-fidelity prototypes are useful to the designer in the early stages for several reasons. They cost very little. Pencil and paper and other similar materials are cheap. The time and \nenergy required to create a simple sketch of an interface are also negligible.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 324", "position": 324, "chunk_type": "semantic", "token_estimate": 390}
{"text": "300\u2002 \u2022\u2002 Software Engineering Design: Pencil and paper and other similar materials are cheap. The time and \nenergy required to create a simple sketch of an interface are also negligible. Often, if the \nideas come during the initial requirements gathering meetings, designers can create mock-\nups on the spot to clarify ideas and get a better grasp of the customer\u2019s wants and needs. Low-fidelity prototypes can also be \u201cthrown away\u201d easily. Often designers simply crum-\nple up a piece of paper and \u201cstart over\u201d with the design. This is much more difficult and \ntime-consuming when using higher-fidelity tools (e.g., commercial tools, integrated devel-\nopment environments, presentation software). Figure\u00a09.3 presents an example of a low-", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 324", "position": 324, "chunk_type": "semantic", "token_estimate": 115}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 301: fidelity prototype of a fictional document editor, in which the major interface components \nare illustrated without any real details. After identifying requirements and getting initial feedback from customers on early pro-\ntotypes, designers must then work toward creating a more realistic prototype that can be \nused for specific testing. Interface design tools with drag-and-drop support for widgets \nlike text boxes, labels, buttons, and other controls are highly useful for this phase. Most \npopular programming languages have graphical development environments with support \nfor interface design. One popular example is Visual Studio, which has excellent support \nfor C# and Visual Basic. Using these types of tools, and others, the designer then creates a \nmore realistic prototype of the system, with either stubbed functionality or some \u201cWizard \nof Oz\u201d* approach (Carroll and Aaronson 1998). In the high-fidelity prototype of the system \nall controls are functional and do what is expected of them so that it can be used for more \nextensive testing purposes. It is during this phase of creation that guidelines like the afore-\nmentioned heuristics can aid the designer in creating an interface that will be useful and \nusable. Style guides, system compatibility issues, and other external constraints must be \nfollowed and can impact the flexibility of the designer. Considerations such as these serve \nas input to the design process, and the resulting interface should meet as many of these \nconstraints as possible. Metaphors\nHelping the end user learn and use a new interface requires thought and effort on the part \nof the interface designer. One highly used technique is the incorporation of metaphors in \n*\tThe Wonderful Wizard of Oz is a children\u2019s story by L. Frank Baum. In this story an all-powerful wizard turns out to be a \nnormal man operating some sophisticated machinery behind a curtain. The relevance here is that the designers or testers \n\u201cfake\u201d the functionality for testing purposes. FIGURE 9.3\nLow-fidelity prototype of a fictional document editor.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 325", "position": 325, "chunk_type": "semantic", "token_estimate": 327}
{"text": "302\u2002 \u2022\u2002 Software Engineering Design: the design. A metaphor is the application of a known, often real-world, object and its char-\nacteristics to an electronic interface. A classic example is the desktop metaphor used in all \nmajor operating system graphical shells (GUIs). Before computers became ubiquitous in \nthe workplace, people sat at desks where all of the tools needed in their work were available \nwithin arm\u2019s reach. This work environment and management style was \u201ccopied\u201d in the cre-\nation of the virtual desktop. People now rely on their graphical user interface to access all \nof the tools they need to get their work done. Learning this environment is straightforward \nand relatively simple for those familiar with a physical desk. Other similar metaphors abound in electronic interfaces. Consider e-mail, which consists \nof a blend of two physical objects that are heavily used in interoffice communications: \u00ad\nletters \nand memos. Most e-mail composition programs provide an interface that includes text entry \nareas for the recipient, copies, and subject\u2014all requirements for most interoffice memos. E-mail also supports both formal and informal letter writing and copies the idea of sending \na \u00ad\nletter to someone. The e-mail\u2013memo metaphor is readily understood by newcomers and \n\u00ad\neasily \u00ad\nmastered by those who have never dealt with the real-world counterparts: an all-around \nexcellent use of a metaphor to aid the end user in learning and using a software system. One must be mindful of overusing metaphors. While the benefits include ease of learn-\ning and ease of use, overapplication or too literal an application of a metaphor can limit \nthe designer and prevent improvements. Take the classic calculator. A handheld calculator \nwith basic functionality is simple and easy to use. Creating a calculator for use within an \noperating system is a normal thing, and many users employ the software calculator for \nvarious tasks. Figure\u00a09.4 presents a simple software calculator interface. FIGURE 9.4\nSimple software calculator.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 326", "position": 326, "chunk_type": "semantic", "token_estimate": 320}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 303: Notice that the software version looks much like a handheld calculator. This is good for \nlearning how the interface works and what is possible. A novice user can easily use the inter-\nface to perform simple calculations. However, the interface is a literal copy of the real-world \ninterface and as such does not provide any extra features that might be expected in soft-\nware, including selectable history, multiple storage areas (variables), and visualizations \n(like\u00a0graphing or showing the equation that yielded the answer). In this case, the designers \ntook the metaphor too far and restricted the utility of the program. Unfortunately, there are \nno hard-and-fast rules to tell when a designer has taken a metaphor \u201ctoo far.\u201d The only way \nto discern this information is through beta testing or actual use. People will use a product \nand indicate functionality they would like to see in the product. Good designers try their \nbest to anticipate that functionality, but that ability comes with experience. Skill Development 9.3: Metaphors in User Interface Design\nDescribe three metaphors used on the popular social website Facebook (http://www. facebook.com). Gestalt Principles\nAnother set of useful design guidance comes from perceptual psychology. Knowing how \nthe human brain processes information should be high on the list of things with which an \ninterface designer should be familiar. German psychologists described several principles \nof perception in the 1920s. They used the term gestalt, which means \u201cwhole,\u201d to illustrate \nhow the human brain recognizes and organizes information. Take a moment to examine \nFigure\u00a09.5. What do you see in the image on the left? Most people would describe it as a plus \nsign. Very few, if any, would describe it as two symmetric right angles sharing a common \npoint. The image on the right shows the two right angles slightly separated for emphasis. There are six major gestalt principles: proximity, similarity, closure, area, symmetry, and \ncontinuity (Rosson and Carroll 2002). Proximity relies on the fact that objects arranged \nclose together are considered grouped together. Similarity simply means that objects that \nFIGURE 9.5\nIllustration of continuity.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 327", "position": 327, "chunk_type": "semantic", "token_estimate": 348}
{"text": "304\u2002 \u2022\u2002 Software Engineering Design: share visual characteristics (e.g., color, shape) will be considered as a group or as similar \nin functionality. Closure is the idea that humans try to organize things into closed figures. Area is similar to closure but with the extra emphasis on the fact that humans try to create \nthe figure with the smallest area. Symmetry refers to the fact that humans often treat sym-\nmetric elements as part of the same figure or group. Finally, \u00ad\ncontinuity refers to the human \npredisposition to see continuous contours or patterns. Skill Development 9.4: Gestalt Principles in User Interface Design\nIdentify instances of the six gestalt principles in the interface presented in Figure\u00a09.6. Knowledge of the gestalt principles is useful in and of itself, but knowing how to utilize \nand capitalize on them for effective interface design requires extensive practice. In addition \nto the gestalt principles, there are some other useful design guidelines to consider. Consider \nwhite space in interface designs. White space is the area in a graphical display with no \nvisual elements. White space becomes very important for helping the end user understand \nthe graphical elements in a display. For example, tabs are often used for alignment pur-\nposes, and it is the extra white space between the columns in a tabbed display that allows \nusers to perceive the data as columns, thus allowing them to more readily understand the \npresented information. Be generous with white space as it directly reinforces several of \nthe gestalt principles. Simultaneously, be very careful about superfluous design elements. Anything extra in an interface that does not provide useful information has the potential \nto detract from the utility of the interface (Carroll 1990). Consider the interface in the pre-\nvious skill development. All of the vertical and horizontal lines can be removed from the \ninterface without detracting the utility or communication provided. Be careful about any \nFIGURE 9.6\nCommon user interface for printer systems.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 328", "position": 328, "chunk_type": "semantic", "token_estimate": 324}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 305: graphical element. Whenever a graphical element is added to an interface, always ask the \nquestion, \u201cIs this necessary?\u201d\nReusing Earlier Designs\nSometimes interface designers do not need to start from scratch. Instead, they have access \nto similar products or have rough designs given to them. In these types of situations, inter-\nface designers are likely to work with designs that do need heavy modification to meet the \nunique needs of the new system. In such situations, designers need to rely on field studies \nand other empirical testing to identify areas for improvement. In other words, reusing \nan existing interface can sometimes reduce the design effort but will usually increase the \n\u00ad\ntesting effort.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 329", "position": 329, "chunk_type": "semantic", "token_estimate": 118}
{"text": "Before systems are deployed, significant efforts must be made to ensure that user interfaces: are sufficiently complete, understandable, and efficient for providing users with systems \nthat exhibit high quality in terms of usability. IEEE (1990, p. 80) defines usability as\nThe ease with which a user can learn to operate, prepare inputs for, and interpret outputs of \na system or component. Therefore, evaluation of the HCI quality is essential during the design process. Several \napproaches can be taken when evaluating and minimizing the degree of complexity \ninvolved when learning or using the system, including usability testing, analytic testing, \nand empirical testing. Usability Testing\nAt this point during the interface design process there should be some usable prototype of \nthe interface that can be used for testing purposes. It is beneficial to understand testing and \nhow to go about doing it. First, it should be noted that there are two classes of evaluation \n(Scriven 1967):\n\u2022\t Formative\n\u2022\t Summative\nFormative evaluation occurs within the design process and focuses on alternatives \nand clarification. Summative evaluation occurs \u201cafter\u201d the design process and focuses on \nassessing the result. Formative evaluation should be heavily utilized throughout the inter-\nface design process, iteratively improving the design. Summative evaluation should be", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 329", "position": 329, "chunk_type": "semantic", "token_estimate": 204}
{"text": "306\u2002 \u2022\u2002 Software Engineering Design: utilized when a solid version of the interface is completed. (Note: this does not mean after \nthe design is complete but rather when a version of the interface is considered ready for \ntesting.) An easy way to distinguish between formative and summative evaluation is that \nformative evaluation is like the cook tasting the soup and summative evaluation is like the \ncustomer tasting the soup. There are two main methods of user interface testing: analytic and empiric (Scriven \n1967). Each can be used for both formative and summative evaluations. Analytic testing \ninvolves domain or usability experts analyzing an interface for design issues. Empirical \ntesting (also known as user testing) involves representative end users performing realistic \ntasks with the interface. Each type of test reveals different information to the interface \ndesigner, and ideally both should be utilized in a mediated evaluation (Scriven 1967). Analytic Testing\nAnalytic testing is often used earlier in the development process than empirical testing. The reason for this is that early in the interface design process there is usually no working \n\u00ad\nsystem with which to test end users. Instead there are low- or high-fidelity prototypes. These \nprototypes can be examined by knowledgeable experts for compliance with, for example, \ndesign guidelines, style guides, and compatibility guides. The key result of an analytic eval-\nuation is a subjective opinion about the interface. Multiple specific tests fall under the ana-\nlytic umbrella: usability inspections, heuristic evaluations, and cognitive walkthroughs. Usability inspections are simply experts using the prototype in intended ways while ensur-\ning usability guidelines are followed. Often these types of inspections have checklists or \nother guidelines (e.g., style guides) that are noted by evaluators. The end result is often a \nlist of usability issues identified and sometimes rated by severity (how much an impact the \nissue might have on end users\u2019 ability to complete their task). Cognitive walkthroughs are \nan example of a usability inspection. In this specific type of inspection, experts are given \na script to work through in an interface while looking for violations of usability guidelines \nand standards while assessing the interface for visual cues (Lewis, Polson, Wharton, and \nRieman 1990). The goal is to identify aspects of the interface that detract from users\u2019 ability \nto complete their tasks with the system and to identify missing information that could be \nuseful.", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 330", "position": 330, "chunk_type": "semantic", "token_estimate": 390}
{"text": "306\u2002 \u2022\u2002 Software Engineering Design: In this specific type of inspection, experts are given \na script to work through in an interface while looking for violations of usability guidelines \nand standards while assessing the interface for visual cues (Lewis, Polson, Wharton, and \nRieman 1990). The goal is to identify aspects of the interface that detract from users\u2019 ability \nto complete their tasks with the system and to identify missing information that could be \nuseful. The result of a cognitive walkthrough is a detailed listing of good and bad aspects \nof interfaces with respect to specific tasks. Heuristic evaluation is similar to usability inspection whereas it involves multiple experts \nreviewing an interface with respect to a list of heuristics (see Nielsen\u2019s heuristics described \nearlier; Nielsen and Mack 1994). The difference is that the evaluator may be a representa-\ntive stakeholder (e.g., developer, end user). Again, the result is a list of problems identified \nin the interface. These can be rated by severity. The interesting thing to note about this \napproach is the utility it brings. A few (3\u20135) experts can find about 80% of the usability \nissues in an interface with this method (Nielsen and Molich 1990). However, heuristic \nevaluation and all analytic methods suffer a major weakness: the results are mainly the \nopinion (albeit\u00a0educated) of evaluators. Whether an identified issue will negatively impact", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 330", "position": 330, "chunk_type": "semantic", "token_estimate": 224}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 307: real users of the system is unknown without further testing. This type of data is subjective \nand often holds less weight than objective data. Empirical Testing\nThe opposite of subjective data is objective data, or empirical data. This type of data is \nhighly respected because it is hard to argue about\u2014it is factual data about the system \nof interest. Empirical testing provides this type of data to the designers. Unfortunately, \nempirical testing is difficult and expensive. Why? It costs time and money to set up and \nexecute a good empirical study. Costs revolve around securing space, development time \n(of the tests), \u00ad\nhiring participants, data collection, analysis, and reporting. Nonetheless, \nempirical testing is highly respected and should be utilized in the interface design process. Many types of empirical testing can be used for interface evaluation: field studies, lab \nbased experiments, and user surveys. The recorded data can vary from observations of use \nto survey responses to measured data from lab-based experiments. This data is objective, \nand the data itself is unquestionable. The issue with empirical data is the interpretation of \nthe data and the validity of the setting from which the data came. Field studies involve designers or design teams going into the field and observing the end \nusers in their current work environment. Observations of work practices, data flow, and \ncommunication channels can provide insight for what to include in user interfaces. The \nraw data from a field study is typically not as useful as the analysis of the data through cate-\ngorization or content classification (higher-level issues that caused the observed behavior). A major drawback of field studies is the cost involved. Significant time (and thus money) \nwould need to be invested to fully understand the existing work environment. On projects \nwith tight schedules, this type of evaluation may not be feasible. It is useful to note that \nfield studies are highly useful for formative evaluations. Lab-based studies are highly useful in usability evaluation (whether formative or sum-\nmative). Often the prohibitive cost of doing field work implies testing should be done in \na computer lab. In this situation the designers work with testers to create a testing envi-\nronment with which to isolate and study specific aspects of an interface. Participants are \nbrought into the lab environment and asked to perform the required tasks. In these settings, \nexcellent data on usage can be collected.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 331", "position": 331, "chunk_type": "semantic", "token_estimate": 402}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 307: Participants are \nbrought into the lab environment and asked to perform the required tasks. In these settings, \nexcellent data on usage can be collected. The major issue with lab-based studies comes from \nvalidity. Validity refers to how realistic the experiment happens to be\u2014how well does the \ntesting situation model the real-world situation? Are the participants representative of the \nreal end users? Did the participants used in the test have more knowledge of this type of \nsystem than the average user? Would the participants be more distracted in their normal \nwork environment? All of these questions and others take away from the utility of the data \nthat comes from a lab-based study. Controlling for validity is difficult and time-consuming. Results should always be considered in light of any validity issues. A specific type of lab-based study is the controlled experiment. If a specific design choice \nneeds to be validated through experimental means, one can design an experiment to objec-\ntively determine the performance of competing options. Suppose a design team wants to \ndetermine which color scheme to use for a system display. The choices have been narrowed", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 331", "position": 331, "chunk_type": "semantic", "token_estimate": 191}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 309: evidence for specific design choices. Often, survey results are used for categorization of the \nparticipants and aid in interpreting results.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 333", "position": 333, "chunk_type": "semantic", "token_estimate": 25}
{"text": "This chapter has provided high-level guidance for completing the human\u2013computer: interface design phase within system design. The main focus is users. It is the duty of the \ndesigner to keep users and their interests as the focus of the interface. The application \nof design guidelines, perceptual psychology, and sound scientific method are all used to \nprovide and justify concrete interface designs that meet the needs of the users. It is on \nthe shoulders of the designer to make sure the system is going to be easy to use, easy to \nlearn, and enjoyable for the end user. Balancing these fundamental requirements with \nthe various system requirements and functional constraints is the core of the interface \ndesigner\u2019s challenge.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 333", "position": 333, "chunk_type": "semantic", "token_estimate": 117}
{"text": "1.\tWhat is human\u2013computer interface design?: 2. What are the steps in the HCI design phase? 3. Why is the focus on the user so important to successful interface design? 4. What is a metaphor with regards to interface design? 5. What are the gestalt principles? 6. Why is white space so important? 7. What are the two major types of evaluations? 8. What are the two major evaluation methods? 9. Why are analytic methods typically cheaper and faster and empirical methods? 10. What is the difference between a between-subjects design and a within-subjects design?", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 333", "position": 333, "chunk_type": "semantic", "token_estimate": 95}
{"text": "1.\tUsing presentation software (e.g., PowerPoint, Impress), create a high-fidelity pro-: totype of the ticket purchasing kiosk described in Skill Development 7.2. Fake the \nfunctionality by linking to different slides in your prototype. 2. Repeat Exercise 1 using a high-level graphical language (e.g., Visual Basic, Visual C#). 3. Analyze your favorite e-mail client with regards to Nielsen\u2019s 10 heuristics. Create a \nlist of usability issues and rank them by severity.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 333", "position": 333, "chunk_type": "semantic", "token_estimate": 70}
{"text": "312\u2002 \u2022\u2002 Software Engineering Design: elements. Instead, the chapter develops a design management framework that describes \nimportant concepts related to each element with the hope of facilitating the successful man-\nagement of this complex phase. For this purpose, the chapter begins by describing the soft-\nware design phase as a complex task that must be managed to achieve acceptable quality\u00ad\n \nlevels. Various project management techniques to monitor and control the resources that are \nresponsible for the completion of design tasks are presented. The chapter\u00ad\n then describes the \nrelationship between management and leadership and highlights several\u00ad\n leadership traits \nthat are important for successful results. Finally, the chapter presents various ethic items \nfrom the Software Engineering Code of Ethics that are relevant to software\u00ad\n design\u00a0projects. WHAT IS SOFTWARE DESIGN MANAGEMENT? Griffin (2010, p. 5) defines management as \u201ca set of activities\u2014including planning and deci-\nsion making, organizing, leading, and controlling\u2014directed at an organization\u2019s resources \n(i.e. human, financial, physical, and information), with the aim of achieving organizational \ngoals in an efficient and effective manner.\u201d Management plays a big role in software engi-\nneering projects. In the design phase, management refers to a set of activities required to \nefficiently create quality design artifacts, within schedule and budget constraints. This def-\ninition encompasses a broad set of activities that are particular to specific organizations. However, at the core of every organization\u2019s management activities, quality is a focal point. WHY STUDY DESIGN MANAGEMENT? In large-scale software projects, software design management is essential to plan, organize, \nstaff, track, and lead the activities required to carry out successfully the software architecture \nand detailed design steps. Key to the success of software design management is an effective \nuse of resources to achieve the various goals set forth for each main component in the design \nphase (i.e., software architecture, detailed design, and documentation). Therefore, software \ndesign management is needed to control/monitor the processes and resources \u00ad\nnecessary for \ncompleting quality design artifacts according to organizational goals.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 336", "position": 336, "chunk_type": "semantic", "token_estimate": 327}
{"text": "Quality is a term that can be loosely defined as a performance measure for a service pro-: vided or a product produced, and it is relative to a particular stakeholder. For example, \na personal website can be classified as high quality by the programmer that developed it \nand as low quality by user clients. That is, two stakeholders of the software system have", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 336", "position": 336, "chunk_type": "semantic", "token_estimate": 63}
{"text": "314\u2002 \u2022\u2002 Software Engineering Design: characterized by planning activities. Although some of the artifacts resulting from this phase \n(e.g., schedule) may be deliverables to clients, this phase is not viewed as contributing signifi-\ncantly to the percentage project completion. The implementation stage, on the other hand, \nis where most of the effort is employed and where most of the design project deliverables \nare achieved, including completed design documents. Therefore, the percent project comple-\ntion is the highest during this stage. In the termination stage, key activities involve verifica-\ntion that everything is in place for a smooth transition into the code construction phase. Activities include, for example, making sure that the latest versions of the design documents \nare securely stored according to configuration management procedures, updating schedule \nand cost current values, reevaluating schedule and budget plans based on the resulting per-\nformance measures of the design phase, and communicating results to upper management. The design documents generated in this stage are critical for the robustness and maintain-\nability of the software designed. However, the relative impact of this stage to project comple-\ntion is not viewed as significant as that of the implementation phase. The key is that each of \nthese phases must be individually managed to ensure that all phases meet acceptable levels of \nquality and performance measures. For example, an important outcome of the planning stage \nis a clear understanding of the tasks to be accomplished and the resources that are neces-\nsary to successfully complete the tasks. Various project management techniques exist to help \nachieve this outcome. Therefore, it is important to know how to apply these project manage-\nment techniques to your particular design project, and go through a peer-review process* to \nensure that the objectives of the planning stage are achieved. Performance measures in the \nplanning stage are thoroughness (everything is considered), completeness (complete defini-\ntion of plans), and accuracy of estimates. In the execution/implementation stage, quality is a \nfunction of a series of technical attributes of software designs. Managing during this stage is \nmainly a monitoring approach to make sure that the plan is being followed and to take cor-\nrective actions if necessary. Important factors that affect the effectiveness of managing these \nphases are leadership and good ethical conduct. Therefore, a design management framework \ncomposed of the following four main areas is proposed:\n\u2022\t Planning\n\u2022\t Execution/implementation\n\u2022\t Termination\n\u2022\t Leadership and ethics", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 338", "position": 338, "chunk_type": "semantic", "token_estimate": 400}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 315: tasks that must be completed, resources in terms of personnel skills required to complete \neach task and any hardware and software required, the durations of tasks, and the specific \npoints within the project\u2019s life cycle phases where resources will be needed. Basically, plan-\nning establishes the directions to follow to complete the project and improve its probability \nof success. It is intended to facilitate future project accomplishments. The key functions in \nthe project planning stage are scoping and organizing. Scoping\nProject scoping is the first key function of the planning stage. It involves two main activities: \nidentify the tasks and develop the budget. The idea is to follow the divide and conquer para-\ndigm to utilize a mechanism for identifying lower-level assignable activities that need to be \ncompleted. Then, expected costs for each activity are estimated to develop the \u00ad\nbudget. Two \ncommonly used techniques for project scoping are the work breakdown \u00ad\nfunction\u00a0(WBS) \nand budgeting. Work Breakdown Structure\nIn the project management point of view, a project begins as a statement of work (SOW), \nwhich mainly consists as the set of main objectives to be achieved. The SOW is decomposed \ninto tasks where these tasks are decomposed into subtasks and subtasks into work \u00ad\npackages. A management technique to represent, either graphically or in list format, a \u00ad\nproject modu-\nlarized into task activities is called WBS. Also known as hierarchical planning, the WBS is \na simple but powerful technique that helps to plan, clearly define, and organize the activi-\nties related to reach specific milestones and complete a project. Milestones are defined \nas specific events to be reached at specific points in time. For example, obtaining budget \nand schedule approvals for a project are typically considered important project milestones. Given that the major artifacts in the design phase are the main components of the design \nprocess, these are considered the main milestones. That is, the completion of the architec-\nture design, detailed design, and documentation constitute the main project milestones of \na design project. Therefore, the objective of a WBS in the design phase is to establish the \nwork elements for each of these major milestones. Table\u00a010.1 shows an example of a WBS for the design of a software application. This \nfigure shows the managerial levels for each component. The top level is the design project\u00ad\n \nitself.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 339", "position": 339, "chunk_type": "semantic", "token_estimate": 399}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 315: This \nfigure shows the managerial levels for each component. The top level is the design project\u00ad\n \nitself. This level represents the overall objective to be achieved, which is to successfully \ncomplete the design phase. Then, this top level is decomposed into the three main mile-\nstones of the design phase, which are the development of architectural and detailed \ndesigns, and the completion of the design document. These tasks are direct sublevels of the \ndesign project; therefore they are labeled 1.1, 1.2, and 1.3. Each task is then decomposed \ninto appropriate subtasks. For the architectural design task, two subtasks were identified: \nevaluation of alternative designs and selection of the final architectural design. Since these \nare sublevels of the architectural design task, they are labeled 1.1.1 and 1.1.2. Each of these \nsubtasks is decomposed into appropriate work packages. For example, the evaluation of", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 339", "position": 339, "chunk_type": "semantic", "token_estimate": 149}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 317: the construction of a house is expected to be more accurate than the budget for develop-\ning a complex software application. For the project of constructing a house, planners often \nhave a very good idea of the resources that are needed, cost of permits, and so forth. For \nthe software project, it becomes a more challenging task due to the level of uncertainty in \nkey elements such as the number of software lines of code that it would take to develop the \napplication, the number of software engineers required, and unknown learning curves for \nnewer technology, to name a few. Compared with the house construction project, the typi-\ncal error size for the estimation of cost parameters in software projects is much higher. Due \nto these uncertainties, monitoring and controlling activities must be enforced throughout \nthe course of the project to determine any deviations from the plan (i.e., budget), and study \nthe causes of these deviations (monitoring and control mechanisms will be discussed later \nin the chapter). As such, the budget serves as a baseline to compare differences between \nactual and estimated costs at any point in the life of a project. Conceptually, a common strategy to develop a budget is to simply cost each element in \nthe WBS. To accomplish this, elements are associated with direct and indirect costs. Direct \ncosts are those that can be directly tied to the development of the design. The most often \nused direct costs are labor and equipment (i.e., hardware and software equipment). Indirect \ncosts, on the other hand, include costs such as fringe benefits and administrative expenses. One of the most significant and hard-to-estimate direct costs for each task is the cost of \nthe staff that will be directly working on the completion of the task. The level of difficulty \nin developing accurate cost estimates related to task durations is a function of the complex-\nity of the design project itself. Given that software projects are typically custom-made solu-\ntions to particular problems, tasks are considered nonrepetitive and often involve learning \nrates. This is particularly true for tasks that involve new technologies or the use of skills \nthat the staff is unfamiliar with. Therefore, it is important to account for learning rates in \nthe budgeting process. It is important to understand that developing accurate budgets for design projects is often \nvery difficult due to the complexity of the projects.", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 341", "position": 341, "chunk_type": "semantic", "token_estimate": 405}
{"text": "318\u2002 \u2022\u2002 Software Engineering Design: They are basically graphical representations of \nthe logical flow between tasks (i.e., activities) and their durations. The Gantt chart technique is \nvery simple to follow. Because of its simplicity, this approach is often used to show schedule and \nprogress as well as to serve as a control and monitoring mechanism. The three basic param-\neters needed for a Gantt chart are tasks, their durations, and their predecessors and successors. These parameters are used to develop a graph that depicts the durations of tasks and their rela-\ntionship. For example, consider a snapshot of a Gantt\u00a0chart presented in Figure\u00a010.2 from the \nMicrosoft Project software package. The left-hand side of this figure shows the list of tasks from \na WBS with expected duration, start date, and finish date. It also shows any predecessor for \neach task. For example, the predecessor to evaluate detailed design alternatives (WBS\u00a0#1.2.1) \nis to have selected a final architectural design (WBS #1.1.2.2). On the right-hand side, we can \nsee the actual Gantt chart showing predecessors of tasks and their durations. We can see, for \nexample, that the documentation for the architectural design can be started as soon as the \narchitectural design passes a formal review and the detailed design is ready to begin.", "domains": ["Code Organization"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 342", "position": 342, "chunk_type": "semantic", "token_estimate": 213}
{"text": "326\u2002 \u2022\u2002 Software Engineering Design: Earned Value Management\nEarned value management (EVM) is an important project management technique to \ndetermine the progress of tasks based on the value of the work currently completed versus \nthe work that was expected to be completed at that particular time. The term used to define \nthe dollar amount of the work currently completed is called earned value (EV), which is \ncalculated by multiplying the percentage work completed times the planned total cost of \nthe work when completed. Therefore, a key factor is to accurately estimate the percentage \nof work completed, which can be hard to do because of the complexity of tasks and the \nhigh degree of subjectivity that is typically involved. Furthermore, workers tend to inflate \nthe percentage of work completed to give the perception that work is progressing smoothly \nfor the completion of the task. Portraying a false sense of work completion is very danger-\nous for a project and can result in significant schedule and budget overruns. Knowing \nthat the percent completion of a task at a particular point in time is lower than expected \nprovides managers the opportunity to implement corrective actions to mitigate the risks of \nnot completing the task within established cost and schedule constraints. There are various \nways to estimate percentage completion. Meredith and Mantel (2009) provide a rough set \nof guidelines that can be used to help in the estimation process, which are briefly described \nin Table\u00a010.5. Armed with EV calculations for each task (i.e., each element in the WBS), we can exam-\nine deviations to cost and schedule and then establish a dollar amount to these devia-\ntions. The terms used to define current deviations to schedule and cost are called schedule \nvariance (SV) and cost variance (CV). SV is calculated as the difference between the EV \nand the planned value (PV), which is the cost/value of the work that was expected to be \ncompleted at that point in time of the schedule. CV is the difference between the EV and \nthe actual cost (AC), which is the amount of money that was spent on the work currently \ncompleted. Two other important measures are the cost performance index (CPI) and the \nschedule performance index (SPI). The CPI value is calculated as the ratio of EV to AC. This \nmeasure can be used to estimate the projected cost to complete some work.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 350", "position": 350, "chunk_type": "semantic", "token_estimate": 397}
{"text": "During the termination stage, key activities involve verification that everything is in place: for a smooth transition into the code construction phase. Activities include, for example, \nmaking sure that the latest versions of the design documents are securely stored based \non configuration management procedures, updating schedule and cost current values, \nreevaluating schedule and budget plans based on the resulting performance measures of \nthe design phase, and communicating results to upper management.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 353", "position": 353, "chunk_type": "semantic", "token_estimate": 71}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 331: by a foreign citizen with a proposition to sell the software design and other important \ndocuments to an enemy country. If focused on the safety of the people (i.e., the higher \npurpose), then ethical values will provide the answer of not accepting the offer and report-\ning the foreign person to the authorities. Another approach that can be taken to over-\ncome the challenges associated with ethical decisions is to find support from other ethical \npeople (e.g., friends, family, coworkers). To help employees distinguish between ethical and \nunethical activities, most companies have their own internal documents that describe the \nexpected ethical behavior from employees. It is very important for leaders to conform to \nthese guidelines and discuss them with employees. Power\nLeading is about influencing others. The potential influence that leaders have over others \nis called power. The word potential means that it is actually the perception of power, and \nnot the power itself, that influences followers. The two main sources of power are position \npower and personal power. Position power is related to hierarchical position levels. More \nspecifically, higher hierarchical levels mean higher potential power. Therefore, the presi-\ndent of a software company has more potential power than any other employee in the com-\npany because of position power. Position power is important because it allows \u00ad\nmanagers \nto influence employees to reach planned objectives. There are various types of position \npower. An example of one is called the reward power. This type of power gives managers \nthe \u00ad\nability to influence employees with something of value to them, namely, performance \nevaluations. Employees will be influenced to complete their corresponding assignments \nbecause of their manager\u2019s reward power to provide good performance evaluations\u00ad\n. Another type of position power\u2014related to reward power\u2014is called coercive power. The \ncoercive power basically says that managers have the ability to influence \u00ad\nothers by the idea \nof punishment and withholding of rewards. Following the same example, employees can \nTABLE\u00a010.9\nTraits of Effective Leaders\nPrinciple\nDescription (Trait\u2019s Characteristics in a Person)\nDominance\nThis trait describes a person who wants to be a manager and takes control. Successful \nleaders with this trait are not overly bossy and avoid the bullying style. High energy\nThis trait describes a positive-minded person who works hard to achieve objectives and \nis good at taking initiative. Integrity\nThis trait describes a person who is highly ethical and trustworthy.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 355", "position": 355, "chunk_type": "semantic", "token_estimate": 406}
{"text": "332\u2002 \u2022\u2002 Software Engineering Design: be influenced to complete their corresponding assignments because of their manager\u2019s \ncoercive power to provide bad performance evaluations and withhold salary increases. Personal power relates to the potential influence that a person\u2019s behavior has to influ-\nence others. Being positive, assertive, and hard-working are some of the characteristics that \nincrease personal power. As with position power, there are also various types of personal \npower. One example is the expert power. This type of power is based on the ability to influ-\nence others based on a leader\u2019s skill and knowledge. For example, being an expert in devel-\noping architectural designs will influence others to follow the expert. The expert power of \nan individual gets stronger as people with similar expertise levels become fewer. Another \ntype of personal power is called connection power. Connection power refers to the ability \nof a person\u00ad\n to influence others because of the person\u2019s relationships with influential people.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 356", "position": 356, "chunk_type": "semantic", "token_estimate": 157}
{"text": "Various skills are important to leadership. Some of these skills include communication,: networking, motivation, and negotiation. These are described in the following subsections. Communication Skills\nGood communication skills are essential for effective leadership. Various researchers \n(see,\u00a0e.g., Li and Liu 2010; Simkin 1996) have mentioned that a high percent of a managers\u2019 \ntime is spent in communications. As already mentioned, leadership is about influencing \nothers. Leaders can influence and establish productive relationships with others through \ncommunication. Truly effective communication occurs when the information passed is \nequally and fully understood by all parties. One way to achieve effective communication is \nto plan in advance the message that needs to be conveyed. To achieve this, the goal of the \nmessage needs to be clearly understood. Also, it is important to think about the best timing \nto convey the message, how the message will be delivered (e.g., oral, written), and where \n(e.g., company\u2019s auditorium, employee\u2019s office). One type of communication is oral communication. To become an effective oral commu-\nnicator can be challenging and often takes much practice. One way to become effective is to \nhave a process in place so that focus can be placed in the individual elements of the process. Lussier and Achua (2010) describe a five-step process for effectively sending oral messages. The first step is to develop a rapport. This means to try establishing a good relationship with \nthe receiving party and begin small conversations related to the message. The second step is \nto clearly state the objective of the message. This is crucial as it helps the receiver to under-\nstand what the message is expected to accomplish before the details of the message are trans-\nmitted. This will engage the receiver\u2019s mind to focus on the message\u00ad\n to be received. The third \nstep is to actually transmit the message. The fourth step is to perceive the receiver\u2019s under-\nstanding of the message. It is important that the message was well understood; otherwise, its \nobjectives were not achieved. This can be accomplished by asking direct questions or reading", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 356", "position": 356, "chunk_type": "semantic", "token_estimate": 341}
{"text": "334\u2002 \u2022\u2002 Software Engineering Design: has been an area of investigation to many researchers. Various theories have been developed \nto describe a set of motivational factors that significantly affect individuals\u2019 behavior. The \ngeneral benefit sought from these research studies was that identifying and understand-\ning these factors would provide leaders with necessary resources to positively influence and \ninspire employees to successfully complete their tasks. One of the motivational theories developed is called the hierarchy of needs theory (Lussier \nand Achua 2010). This theory describes five types of needs through which employees are \nmotivated. Table\u00a010.10 shows the five types and provides some of the activities that can \nhelp meet the particular needs associated with each type. Negotiation Skills\nNegotiation skills are an important part of any management job. Good negotiators are \ncapable of leading by looking out for the best interests of the people that they are leading. There are many research studies related to negotiations, some of which have resulted in \nguidelines that can help to improve a person\u2019s negotiation skills. One such set of guidelines, \ncalled principled negotiation, was developed by Fisher and Ury (1991). Principled negotia-\ntion is composed of four guidelines. The first one is to separate the people from the problem. This principle helps to keep the focus on the problem at hand rather than on interpersonal \nissues. The second guideline is to focus on interests rather than \u00ad\npositions. This principle helps \nto keep the focus of the negotiation on the interests of people rather than their positions. The third guideline is to generate options before trying to reach an\u00a0agreement. This\u00a0principle \npromotes creativity and reminds the negotiating parties to brainstorm to find potential \nTABLE\u00a010.10\nTypes of Needs and Activities to Meet Them\nType of Need\nActivities to Meet the Needs\nPhysiological\nAdequate salaries\nAllowance of breaks\nAdequate working conditions\nSafety\nSafe working conditions\nSalary increases (considering inflation)\nFringe benefits\nSocial\nSocial activities that conform to individual behavior\nTeam-building retreats\nTeam sports\nLunch gatherings\nEsteem\nRaises based on performance\nAwards\nPublic recognition\nParticipation in decision making\nSelf-actualization\nSkill development activities\nPromotions\nIncrease control of an employee\u2019s task", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 358", "position": 358, "chunk_type": "semantic", "token_estimate": 355}
{"text": "Fisher, R., and W. Ury. Getting to Yes, 2d ed. New York: Penguin Books, 1991.: Griffin, Ricky W. Management, 10th ed. Mason, OH: South-Western Publications, 2010. IEEE Computer Society. \u201cSoftware Engineering Code of Ethics and Professional Practice.\u201d 2010. Available at \nhttp://www.computer.org/portal/web/certification/resources/code_of_ethics. Judge, T. A., R. Ilies, J. E. Bono, and M. W. Gerhardt. \u201cPersonality and Leadership: A Qualitative and Quantitative \nReview.\u201d Journal of Applied Psychology 87, no. 4 (2002): 765\u2013768. Li, Mei Yan, and Ying Zong Liu. \u201cStudy on Line Managers\u2019 Competence-Based Abilities of Performance \nManagement.\u201d Applied Mechanics and Materials 40\u201341 (2010): 820\u2013824. Lussier, Robert, and Christopher Achua. Leadership: Theory, Application, & Skill Development, 4th ed. Florence, \nKY: Cengage Learning, 2010. Meredith, Jack, and Samuel Mantel. Project Management: A Managerial Approach, 7th ed. Hoboken, NJ: \nJohn\u00a0Wiley & Sons, 2009. Nebus, J. \u201cBuilding Collegial Information Networks: A Theory of Advice Network Generation.\u201d Academy of \nManagement Review 31, no. 3 (2006): 615\u2013637. Pelosi, Marilyn K., and Theresa M. Sandifer. Elementary Statistics: From Discovery to Decision. Hoboken, NJ: \nJohn Wiley & Sons, 2003. Simkin, Mark. \u201cThe Importance of Good Communication Skills on \u2018IS\u2019 Career Paths.\u201d Journal of Technical \nWriting and Communication 26, no. 1 (1996): 69\u201378. Veiga, J. F. \u201cSpecial Topic Ethical Behavior in Management, Bringing Ethics into the Mainstream: An Introduction \nto the Special Topic.\u201d Academy of Management Executive 18, no. 2 (2004): 37\u201338.", "domains": ["Software Quality Attributes"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 364", "position": 364, "chunk_type": "semantic", "token_estimate": 223}
{"text": "Software Engineering & Systems Development: Taking a learn-by-doing approach, Software Engineering Design: Theory and \nPractice uses examples, review questions, chapter exercises, and case study assign-\nments to provide students and practitioners with the understanding required to de-\nsign complex software systems. Explaining the concepts that are immediately rele-\nvant to software designers, it begins with a review of software design fundamentals. The text presents a formal top-down design process that consists of several design \nactivities with varied levels of detail, including the macro-, micro-, and construction-\ndesign levels. As part of the top-down approach, it provides in-depth coverage of \napplied architectural, creational, structural, and behavioral design patterns. For \neach design issue covered, it includes a step-by-step breakdown of the execution of \nthe design solution, along with an evaluation, discussion, and justification for using \nthat particular solution. The book outlines industry-proven software design practices for leading large-scale \nsoftware design efforts, developing reusable and high-quality software systems, \nand producing technical and customer-driven design documentation. It also:\n\u2022 Offers one-stop guidance for mastering the Software Design \n& Construction sections of the official Software Engineering \nBody of Knowledge (SWEBOK\u00ae)\n\u2022 Details a collection of standards and guidelines for structuring  \nhigh-quality code\n\u2022 Describes techniques for analyzing and evaluating the quality \nof  software designs \nCollectively, the text supplies comprehensive coverage of the software design \nconcepts students will need to succeed as professional design leaders. The section \non engineering leadership for software designers covers the necessary ethical and \nleadership skills required of software developers in the public domain. The section on \ncreating software design documents (SDD) familiarizes students with the software \ndesign notations, structural descriptions, and behavioral models required for SDDs. Course notes, exercises with answers, online resources, and an instructor\u2019s \nmanual are available upon qualified course adoption. ISBN: 978-1-4398-5168-5\n9 781439 851685\n90000", "domains": ["Design Patterns"], "source": "Software Engineering Design- Theory and Practice.pdf", "section": "Page 365", "position": 365, "chunk_type": "semantic", "token_estimate": 298}
