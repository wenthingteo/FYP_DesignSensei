{"text": "SOLID Principles for Object-Oriented Design: \u2022 Five basic principles (guidelines) for Object-Oriented Design (OOD)\n\u2022 Results in systems that are:\n\u2022 Easy to maintain\n\u2022 Easy to extend\n\u2022 SOLID is a guide for:\n\u2022 Creating designs from scratch\n\u2022 Improving existing designs\n3", "domains": ["Design Principles"], "source": "12-design-principles.pdf", "section": "Page 3", "position": 3, "chunk_type": "semantic", "token_estimate": 44}
{"text": "SOILD Principles: \u2022 Single Responsibility Principle (SRP)\n\u2022 Open/closed Principle (OCP)\n\u2022Liskov Substitution Principle (LSP)\n\u2022Interface Segregation Principle (ISP)\n\u2022Dependency Inversion Principle (DIP)\n4", "domains": ["Design Principles", "Code Organization"], "source": "12-design-principles.pdf", "section": "Page 4", "position": 4, "chunk_type": "semantic", "token_estimate": 24}
{"text": "Single Responsibility Principle: \u2022 Every class should have A SINGLE RESPONSIBILITY\n\u2022 The responsibility of a class drives its need to change\n\u2022 Responsibility should be entirely encapsulated by the class\n\u2022 All functionality of the class should focus on that single responsibility\n\u2022 Why? \u2022 More cohesive\n\u2022 Easier to understand\n\u2022 Easier to maintain\n5", "domains": ["Design Principles"], "source": "12-design-principles.pdf", "section": "Page 5", "position": 5, "chunk_type": "semantic", "token_estimate": 57}
{"text": "Polymorphic Open/Closed Principle: \u2022 Abstract base class and multiple implementations that we can \nsubstitute for each other\n\u2022 Base design on abstract base classes\n\u2022 Focus on sharing the interface, not the implementation\n\u2022 \u201cCode to an interface, not an implementation\u201d\n\u2022 Reuse implementation via delegation\n\u00ababstract\u00bb\nParser\n+parse()\nParserImplementation\n+parse()\nParserRubyImplementation\n+parse()\n15", "domains": ["Code Organization"], "source": "12-design-principles.pdf", "section": "Page 15", "position": 15, "chunk_type": "semantic", "token_estimate": 54}
{"text": "Liskov Substitution Principle: \u2022 An Object in a program should be replaceable with an instance of subtypes \nwithout affecting program correctness\n\u2022 \u201cObjects of subtypes should behave like those of supertypes if used via supertype \nmethods.\u201d\n\u2022 Preconditions cannot be strengthened in a subtype\n\u2022 Postconditions cannot be weakened in a subtype\n\u2022 Invariants of supertype must be preserved in subtype\n\u2022 History constraint - new methods in subtype cannot introduce state \nchanges in a way that is not permissible in the supertype\n\u2022 Why? \u2022 Knowledge/assumptions about base class apply to the subclass\n\u2022 Easier to understand\n\u2022 Easier to maintain. 16", "domains": ["Design Patterns", "Design Principles"], "source": "12-design-principles.pdf", "section": "Page 16", "position": 16, "chunk_type": "semantic", "token_estimate": 103}
{"text": "Interface Segregation Principle: \u2022 A client should NOT be forced to depend on methods it does not use\n\u2022 Having many client-specific interfaces is better than one general-\npurpose interface\n\u2022 Why? \u2022 More cohesive\n\u2022 Lower coupling\n\u2022 Easier to understand\n\u2022 Easier to maintain\n22", "domains": ["Design Principles", "Code Organization"], "source": "12-design-principles.pdf", "section": "Page 22", "position": 22, "chunk_type": "semantic", "token_estimate": 47}
{"text": "Dependency Inversion Principle: \u2022 Depend upon abstractions, not concretions (specific implementations \nof an abstraction)\n\u2022 Abstractions should not depend on details, but details on abstractions\n\u2022 High-level modules are independent and should not depend on low-\nlevel modules\n\u2022 Why? \u2022 Lower coupling\n\u2022 Reuse\n\u2022 Easier to test\n\u2022 Easer to understand\n\u2022 Easier to maintain\n25", "domains": ["Design Principles", "Code Organization"], "source": "12-design-principles.pdf", "section": "Page 25", "position": 25, "chunk_type": "semantic", "token_estimate": 58}
{"text": "Other Helpful Principles: \u2022 DRY- Don\u2019t Repeat Yourself\n\u2022 Use functional decomposition or abstractions to reduce redundancies\n\u2022 YAGNI \u2013 You Aren\u2019t Gonna Need It\n\u2022 Don\u2019t try to build out features now that you think your software MIGHT need \nlater\n\u2022 Software development is too volatile for that, focus on what is needed now \nand the maintainability of your design\n\u2022 Occam\u2019s Razor/KISS \u2013 Keep it simple\n\u2022 Don\u2019t introduce unnecessary complexity or overblown designs\n\u2022 GRASP \u2013 General Responsibility Assignment Software Patterns\n\u2022 Design patterns that can help with your software design/implementation\n\u2022 More on design patterns later\u2026\n30", "domains": ["Design Principles", "Software Quality Attributes"], "source": "12-design-principles.pdf", "section": "Page 30", "position": 30, "chunk_type": "semantic", "token_estimate": 101}
{"text": "Conclusion: \u2022 Meant to be applied together\n\u2022 Make it more likely that the system is easy to maintain and extend \nover time\n\u2022 SOLID principles are guidelines\n\u2022 Do not guarantee success\n\u2022 Can be misused\n\u2022 Use in conjunction with other principles\n\u2022 Don\u2019t chase perfection\n\u2022 Design based on your needs \n\u2022 Good enough design gets software delivered\n31", "domains": ["Design Principles"], "source": "12-design-principles.pdf", "section": "Page 31", "position": 31, "chunk_type": "semantic", "token_estimate": 62}
