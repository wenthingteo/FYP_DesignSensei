{"text": "(SECURITY,: EVENT NOTIFICATION, TRANSACTIONS, PERSISTENCE, LOAD BALANCING,", "domains": ["Software Quality Attributes"], "source": "design-principles4.pdf", "section": "Page 1", "position": 1, "chunk_type": "semantic", "token_estimate": 7}
{"text": "Session  Router: Module\nEvent  Filter\nModule\nSwitch  Adapter\nModule\nEvent  Analyzer\nModule", "domains": ["Design Patterns", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 1", "position": 1, "chunk_type": "semantic", "token_estimate": 12}
{"text": "\u000f Decompose system into: components\n\u2013 i.e., identify the software\narchitecture\n\u000f Determine relationships\nbetween components\n\u2013 e.g., identify component\ndependencies\n\u000f Determine intercomponent\ncommunication mechanisms\n\u2013 e.g., globals, function calls,\nshared memory, IPC/RPC\n2\nDesign Principles\nMotivation: Goals of the Design Phase (2/2)", "domains": ["Code Organization"], "source": "design-principles4.pdf", "section": "Page 1", "position": 1, "chunk_type": "semantic", "token_estimate": 44}
{"text": "Tail: \u000f Specify component interfaces\n\u2013 Interfaces should be well-de\ufb01ned\n\u0003 Facilitates component testing\nand team communication\n\u000f Describe component functionality\n\u2013 e.g., informally or formally\n\u000f Identify opportunities for systematic\nreuse\n\u2013 Both top-down and bottom-up\n3", "domains": ["Code Organization"], "source": "design-principles4.pdf", "section": "Page 1", "position": 1, "chunk_type": "semantic", "token_estimate": 38}
{"text": "Design Principles: Macro Steps in the Design Process\n\u000f In the design process the orientation moves from\n\u2013 Customer to developer\n\u2013 What to how\n\u000f Macro steps include:\n1. Preliminary Design\n\u2013 External design describes the real-world model\n\u2013 Architectural design decomposes the requirement speci\ufb01cation\ninto software subsystems\n2. Detailed Design\n\u2013 Specify each subsystem\n\u2013 Further decomposed subsystems, if necessary\n4\nDesign Principles\nMicro Steps in the Design Process\n\u000f Given a requirements spec, design is an\niterative decision process with the following\ngeneral steps:\n1. List the hard decisions and decisions likely to\nchange\n2. Design a component speci\ufb01cation to hide\neach such decision\n\u2013 Make decisions that apply to whole program\nfamily \ufb01rst\n\u2013 Modularize most likely changes \ufb01rst\n\u2013 Then modularize remaining dif\ufb01cult\ndecisions and decisions likely to change\n\u2013 Design the uses hierarchy as you do this\n(include reuse decisions)\n3. Treat each higher-level component as a\nspeci\ufb01cation and apply above process to each\n4. Continue re\ufb01ning until all design decisions\nare:\n\u2013 hidden in a component\n\u2013 contain easily comprehensible components\n\u2013 provide individual, independent, low-level\nimplementation assignments\n5\nDesign Principles\nExample: Designing a Web Server", "domains": ["Code Organization"], "source": "design-principles4.pdf", "section": "Page 2", "position": 2, "chunk_type": "semantic", "token_estimate": 193}
{"text": "www.cs.wustl.edu/\u02dcjxh/: research/\n\u000f Web server design\ndecisions\n\u2013 Portability issues\n\u2013 I/O demuxing and\nconcurrency\n\u2013 HTTP protocol\nprocessing\n\u2013 File access\n\u000f Web server\ncomponents\n\u2013 Event dispatcher\n\u2013 Protocol handler\n\u2013 Cached virtual\n\ufb01lesystem\n6\nDesign Principles\nKey Design Concepts and Principles\nKey design concepts and design\nprinciples include:\n1. Decomposition\n2. Abstraction and information hiding\n3. Component modularity\n4. Extensibility\n5. Virtual machine architectures\n6. Hierarchical relationships\n7. Program families and subsets\nMain goal of these\nconcepts and principles is\nto:\n\u000f Manage software\nsystem complexity\n\u000f Improve software quality\nfactors\n\u000f Facilitate systematic\nreuse\n\u000f Resolve common design\nchallenges\n7", "domains": ["Software Quality Attributes", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 2", "position": 2, "chunk_type": "semantic", "token_estimate": 104}
{"text": "Design Principles: Challenge 1: Determining the Web Server Architecture\n\u000f Context: A large and complex production web server\n\u000f Problems:\n\u2013 Designing the web server as a large monolithic entity is tedious\nand error-prone\n\u2013 Web server developers must work concurrently to improve\nproductivity\n\u2013 Portability and resuability are important quality factors\n8\nDesign Principles\nSolution: Decomposition\n\u000f Decomposition handles complexity by splitting large problems into\nsmaller problems\n\u000f This \u201cdivide and conquer\u201d concept is common to all life-cycle\nprocesses and design techniques\n\u000f Basic methodology:\n1. Select a piece of the problem (initially, the whole problem)\n2. Determine the components in this piece using a design paradigm,\ne.g., functional, structured, object-oriented, generic, etc. 3. Describe the components interactions\n4. Repeat steps 1 through 3 until some termination criteria is met\n\u2013 e.g., customer is satis\ufb01ed, run out of time/money, etc. ;-)\n9\nDesign Principles\nDecomposition Example: Web Server Framework\nPipes and filters\nComponent  configurator\nComponent  configurator\n~\n/home/...\nProtocol\nhandler\nProtocol\nfilter\nProtocol pipeline\nframework\nConcurrency\nstrategy\nframework\nTilde\nexpander\nCached virtual\nfilesystem\nI/O strategy\nframework\nAdapter\nActive object\nStrategy\nState\nAcceptor\nAsynchronous completion token\nMemento\nReactor/Proactor\nStrategy\nSingleton\nState\nEvent dispatcher\n\u000f Features\n\u2013 High-performance\n\u2013 Flexible concurrency,\ndemuxing, and caching\nmechanisms\n\u2013 Uses frameworks based\non ACE\nwww.cs.wustl.edu/\u0018schmidt/PDF/JAWS.pdf\n10\nDesign Principles\nObject-Oriented Decomposition Principles\n1. Don\u2019t design components to correspond to execution steps\n\u000f Since design decisions usually transcend execution time\n2. Decompose so as to limit the effect of any one design decision on\nthe rest of the system\n\u000f Anything that permeates the system will be expensive to change\n3. Components should be speci\ufb01ed by all information needed to use\nthe component\n\u000f and nothing more! 11", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 3", "position": 3, "chunk_type": "semantic", "token_estimate": 282}
{"text": "Design Principles: Challenge 2: Implementing a Flexible Web Server\n\u000f Context: The requirements that a production web server must meet\nwill change over time, e.g. :\n\u2013 New platforms\n\u2013 New compilers\n\u2013 New functionality\n\u2013 New performance goals\n\u000f Problems:\n\u2013 If the web server is \u201chard coded\u201d using low-level system calls it will\nbe hard to port\n\u2013 If web server developers write software that\u2019s tightly coupled with\ninternal implementation details the software will be hard to evolve\n12\nDesign Principles\nSolution: Abstraction", "domains": ["Software Quality Attributes"], "source": "design-principles4.pdf", "section": "Page 4", "position": 4, "chunk_type": "semantic", "token_estimate": 85}
{"text": "\u000f Abstraction manages complexity: by emphasizing essential\ncharacteristics and suppressing\nimplementation details\n\u000f Allows postponement of certain\ndesign decisions that occur at\nvarious levels of analysis, e.g.,\n\u2013 Representational and\nalgorithmic considerations\n\u2013 Architectural and structural\nconsiderations\n\u2013 External environment and\nplatform considerations\n13\nDesign Principles\nCommon Types of Abstraction\n1. Procedural abstraction\n\u000f e.g., closed subroutines\n2. Data abstraction\n\u000f e.g., ADT classes and component models\n3. Control abstraction\n\u000f e.g., loops, iterators, frameworks, and multitasking", "domains": ["Design Patterns", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 4", "position": 4, "chunk_type": "semantic", "token_estimate": 77}
{"text": "Design Principles: Information Hiding\n\u000f Information hiding is an important means of achieving abstraction\n\u2013 i.e., design decisions that are subject to change should be hidden\nbehind abstract interfaces\n\u000f Application software should communicate only through well-de\ufb01ned\ninterfaces\n\u000f Each interface should be speci\ufb01ed by as little information as possible\n\u000f If internal details change, clients should be minimally affected\n\u2013 May not even require recompilation and relinking...\n15", "domains": ["Code Organization"], "source": "design-principles4.pdf", "section": "Page 4", "position": 4, "chunk_type": "semantic", "token_estimate": 69}
{"text": "Design Principles: Typical Information to be Hidden\n\u000f Data representations\n\u2013 i.e., using abstract\ndata types\n\u000f Algorithms\n\u2013 e.g., sorting or\nsearching techniques\n\u000f Input and Output\nFormats\n\u2013 Machine\ndependencies, e.g.,\nbyte-ordering,\ncharacter codes\n\u000f Lower-level interfaces\n\u2013 e.g., ordering of low-level operations,\ni.e., process sequence\n\u000f Separating policy and mechanism\n\u2013 Multiple policies can be implemented\nby same mechanisms\n\u0003 e.g., OS scheduling and virtual\nmemory paging\n\u2013 Same policy can be implemented by\nmultiple mechanisms\n\u0003 e.g., reliable communication\nservice can be provided by multiple\nprotocols\n16\nDesign Principles\nInformation Hiding Example: Message Queueing\nMessage\nBlock\nMessage\nQueue\nhead_\ntail_\nSYNCH\nSTRATEGY\nMessage\nBlock\nnext()\nprev()\ncont()\nMessage\nBlock\nnext()\nprev()\ncont()\nMessage\nBlock\nnext()\nprev()\ncont()\nData_Block\nData_Block\nData_Block\nData_Block\nnext()\nprev()\ncont()\n\u000f A Message_Queue is a list of\nACE_Message_Blocks\n\u2013 Ef\ufb01ciently handles\narbitrarily-large message\npayloads\n\u000f Design encapsulates and\nparameterizes various aspects\n\u2013 e.g., synchronization, memory\nallocators, and reference\ncounting can be added\ntransparently\n17\nDesign Principles\nThe ACE_Message_Block Class", "domains": ["Design Patterns", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 5", "position": 5, "chunk_type": "semantic", "token_estimate": 167}
{"text": "data_block_ : ACE_Data_Block *: *        1\nClass characteristics\n\u000f Hide messaging implementations from clients\nACE_Message\n_Block\ncont()\ndata_block()\nwr_ptr()\nrd_ptr()\nPAYLOAD\nACE_Data\n_Block\nACE_Message\n_Block\ncont()\ndata_block()\nwr_ptr()\nrd_ptr()\nACE_Data_Block\nACE_Message\n_Block\ncont()\ndata_block()\nrd_ptr()\nwr_ptr()\nreference_count() = 2\n(1) SIMPLE MESSAGE STRUCTURE\n(2) COMPOSITE MESSAGE STRUCTURE\n18\nDesign Principles\nThe ACE_Message_Queue Class\n+ ACE_Message_Queue (high_water_mark : size_t = DEFAULT_HWM,\n                     low_water_mark : size_t = DEFAULT_LWM,\n                     notify : ACE_Notification_Strategy * = 0)\n+ open (high_water_mark : size_t = DEFAULT_HWM,\n        low_water_mark : size_t = DEFAULT_LWM,\n        notify : ACE_Notification_Strategy * = 0) : int\n+ flush () : int\n+ notification_strategy (s : ACE_Notification_Strategy *) : void\n+ is_empty () : int\n+ is_full () : int\n+ enqueue_tail (item : ACE_Message_Block *,\n                timeout : ACE_Time_Value * = 0) : int\n+ enqueue_head (item : ACE_Message_Block *,\n                timeout : ACE_Time_Value * = 0) : int\n+ enqueue_prio (item : ACE_Message_Block *,\n                timeout : ACE_Time_Value * = 0) : int\n+ dequeue_head (item : ACE_Message_Block *&,\n                timeout : ACE_Time_Value * = 0) : int\n+ dequeue_tail (item : ACE_Message_Block *&,\n                timeout : ACE_Time_Value * = 0) : int\n+ high_water_mark (new_hwm : size_t) : void\n+ high_water_mark (void) : size_t\n+ low_water_mark (new_lwm : size_t) : void\n+ low_water_mark (void) : size_t\n+ close () : int\n+ deactivate () : int\n+ activate () : int\n+ pulse () : int\n+ state () : int", "domains": ["Design Patterns"], "source": "design-principles4.pdf", "section": "Page 5", "position": 5, "chunk_type": "semantic", "token_estimate": 233}
{"text": "Design Principles: Challenge 3: Determining the Units of Web Server\nDecomposition\n\u000f Context: A production web server that uses abstraction and\ninformation hiding\n\u000f Problems:\n\u2013 Need to determine the appropriate units of decomposition, which\nshould\n\u0003 Possess well-speci\ufb01ed abstract interfaces and\n\u0003 Have high cohesion and low coupling\n20\nDesign Principles\nSolution: Component Modularity", "domains": ["Software Quality Attributes", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 6", "position": 6, "chunk_type": "semantic", "token_estimate": 55}
{"text": "\u000f A modular system is one that\u2019s structured: into identi\ufb01able abstractions called\ncomponents\n\u2013 A software entity that represents an\nabstraction\n\u2013 A \u201cwork\u201d assignment for developers\n\u2013 A unit of code that\n\u0003 has one or more names\n\u0003 has identi\ufb01able boundaries\n\u0003 can be (re-)used by other components\n\u0003 encapsulates data\n\u0003 hides unnecessary details\n\u0003 can be separately compiled\n21\nDesign Principles\nDesigning Component Interfaces\n\u000f A component interface consists of\nseveral types of ports:\n\u2013 Exports\n\u0003 Services provided to other\ncomponents, e.g., facets and\nevent sources\n\u2013 Imports\n\u0003 Services requested from\nother components, e.g.,\nreceptacles and event sinks\n\u2013 Access Control\n\u0003 Not all clients are equal, e.g.,\nprotected/private/public", "domains": ["Domain-Driven Design", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 6", "position": 6, "chunk_type": "semantic", "token_estimate": 115}
{"text": "\u000f De\ufb01ne components that: provide multiple interfaces\nand implementations\n\u000f Anticipate change\n22\nDesign Principles\nComponent Modularity Example: Stream Processing", "domains": ["Software Quality Attributes", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 6", "position": 6, "chunk_type": "semantic", "token_estimate": 20}
{"text": "open()=0: close()=0\nput()=0\nsvc()=0\n\u000f A Stream allows \ufb02exible\ncon\ufb01guration of layered\nprocessing modules\n\u000f A Stream component contains\na stack of Module components\n\u000f Each Module contains two\nTask components\n\u2013 i.e., read and write Tasks\n\u000f Each Task contains a\nMessage Queue component\nand a Thread Manager\ncomponent\n23", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 6", "position": 6, "chunk_type": "semantic", "token_estimate": 51}
{"text": "Design Principles: Bene\ufb01ts of Component Modularity\nModularity facilitates software\nquality factors, e.g.,:\n\u000f Extensibility\n! well-de\ufb01ned,\nabstract interfaces\n\u000f Reusability\n! low-coupling,\nhigh-cohesion\n\u000f Compatibility\n! design\n\u201cbridging\u201d interfaces\n\u000f Portability\n! hide machine\ndependencies\nModularity is important for\ngood designs since it:\n\u000f Enhances for separation of\nconcerns\n\u000f Enables developers to\nreduce overall system\ncomplexity via decentralized\nsoftware architectures\n\u000f Increases scalability by\nsupporting independent and\nconcurrent development by\nmultiple personnel\n24\nDesign Principles\nCriteria for Evaluating Modular Designs\nComponent decomposability\n\u000f Are larger components\ndecomposed into smaller\ncomponents? Component composability\n\u000f Are larger components\ncomposed from existing\nsmaller components? Component understandability\n\u000f Are components separately\nunderstandable? Component continuity\n\u000f Do small changes to the\nspeci\ufb01cation affect a\nlocalized and limited number\nof components? Component protection\n\u000f Are the effects of run-time\nabnormalities con\ufb01ned to a\nsmall number of related\ncomponents? 25\nDesign Principles\nPrinciples for Ensuring Modular Designs\nLanguage support for components\n\u000f Components should correspond to\nsyntactic units in the language\nFew interfaces\n\u000f Every component should\ncommunicate with as few others as\npossible\nSmall interfaces (weak coupling)\n\u000f If any two components communicate\nat all, they should exchange as little\ninformation as possible\nExplicit Interfaces\n\u000f Whenever two\ncomponents A and B\ncommunicate, this must\nbe obvious from the text\nof A or B or both\nInformation Hiding\n\u000f All information about a\ncomponent should be\nprivate unless it\u2019s\nspeci\ufb01cally declared\npublic\n26\nDesign Principles\nChallenge 4: \u201cFuture Proo\ufb01ng\u201d the Web Server\n\u000f Context: A production web server whose requirements will change\nover time\n\u000f Problems:\n\u2013 Certain design aspects seem constant until they are examined in\nthe overall structure of an application\n\u2013 Developers must be able to easily refactor the web server to\naccount for new sources of variation\n27", "domains": ["Software Quality Attributes", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 7", "position": 7, "chunk_type": "semantic", "token_estimate": 297}
{"text": "Design Principles: Solution: Extensibility\n\u000f Extensible software is important to support successions of quick\nupdates and additions to address new requirements and take\nadvantage of emerging opportunities/markets\n\u000f Extensible components must be both open and closed, i.e., the\n\u201copen/closed\u201d principle:\n\u2013 Open component\n! still available for extension\n\u0003 This is necessary since the requirements and speci\ufb01cations are\nrarely completely understood from the system\u2019s inception\n\u2013 Closed component\n! available for use by other components\n\u0003 This is necessary since code sharing becomes unmanageable\nwhen reopening a component triggers many changes\n28\nDesign Principles\nExtensibility Example: Active Object Tasks\nEvent\nHandler\nhandle_input()\nhandle_output()\nhandle_exception()\nhandle_signal()\nhandle_timeout ()\nhandle_close()\nget_handle()=0\nShared\nObject\ninit()=0\nfini ()=0\ninfo()=0\nSvc\nHandler\nService\nObject\nA\nAPPLICATION-", "domains": ["Software Quality Attributes", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 8", "position": 8, "chunk_type": "semantic", "token_estimate": 121}
{"text": "\u000f Features: \u2013 Tasks can register with a\nReactor\n\u2013 They can be dynamically\nlinked\n\u2013 They can queue data\n\u2013 They can run as \u201cactive\nobjects\u201d\n\u000f JAWS uses inheritance and\ndynamic binding to produce\ntask components that are\nboth open and closed\n29\nDesign Principles\nChallenge 5: Separating Concerns for Layered\nSystems\n\u000f Context: A production web server whose requirements will change\nover time\n\u000f Problems:\n\u2013 To enhance reuse and \ufb02exibility, it is often necessary to\ndecompose a web server into smaller, more manageable units\nthat are layered in order to\n\u0003 Enhance reuse, e.g., multiple higher-layer services can share\nlower-layer services\n\u0003 Transparently and incrementally enhancement functionality\n\u0003 Improve performance by allowing the selective omission of\nunnecessary service functionality\n\u0003 Improve implementations, testing, and maintenance\n30\nDesign Principles\nSolution: Virtual Machine Architectures\n\u000f A virtual machine provides an extended\n\u201csoftware instruction set\u201d\n\u2013 Extensions provide additional data types and\nassociated \u201csoftware instructions\u201d\n\u2013 Modeled after hardware instruction set\nprimitives that work on a limited set of data\ntypes\n\u000f A virtual machine layer provides a set of\noperations that are useful in developing a family\nof similar systems", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 8", "position": 8, "chunk_type": "semantic", "token_estimate": 192}
{"text": "www.cs.wustl.edu/: \u0018schmidt/ACE.html\n32\nDesign Principles\nOther Examples of Virtual Machines\nComputer architectures\n\u000f e.g., compiler\n! assembler\n! obj code\n! microcode\n! gates, transistors, signals, etc. Operating systems\n\u000f e.g., Linux\nHardware Machine\nSoftware Virtual Machine\ninstruction set\nset of system calls\nrestartable instructions\nrestartable system calls\ninterrupts/traps\nsignals\ninterrupt/trap handlers\nsignal handlers\nblocking interrupts\nmasking signals\ninterrupt stack\nsignal stack\nJava Virtual Machine (JVM)\n\u000f Abstracts away from details of the underlying OS\n33\nDesign Principles\nChallenge 6: Separating Concerns for Hierarchical\nSystems\n\u000f Context: A production web server whose requirements will change\nover time\n\u000f Problems:\n\u2013 Developers need to program components at different levels of\nabstraction independently\n\u2013 Changes to one set of components should be isolated as much\nas possible from other components\n\u2013 Need to be able to \u201cvisualize\u201d the structure of the web server\ndesign\n34\nDesign Principles\nSolution: Hierarchical Relationships\n\u000f Hierarchies reduce component interactions by restricting the\ntopology of relationships\n\u000f A relation de\ufb01nes a hierarchy if it partitions units into levels (note\nconnection to virtual machine architectures)\n\u2013 Level 0 is the set of all units that use no other units\n\u2013 Level\ni is the set of all units that use at least one unit at level\n<\ni\nand no unit at level\n\u0015\ni. \u000f Hierarchies form the basis of architectures and designs\n\u2013 Facilitates independent development\n\u2013 Isolates rami\ufb01cations of change\n\u2013 Allows rapid prototyping\n35", "domains": ["Code Organization"], "source": "design-principles4.pdf", "section": "Page 9", "position": 9, "chunk_type": "semantic", "token_estimate": 240}
{"text": "Options: s\ns\n HTTP\nHandler\n HTTP\nHandler\n HTTP\nHandler\n HTTP\nAcceptor\n Reactor\n HTTP\nProcessor\n Msg\nQueue\ns\nsvc_run\nsvc_run\nsvc_run\n QUEUEING\n LAYER\n I/O DEMUXING\n LAYER\n36\nDesign Principles\nDe\ufb01ning Hierarchies\n\u000f Relations that de\ufb01ne hierarchies include:\n\u2013 Uses\n\u2013 Is-Composed-Of\n\u2013 Is-A\n\u2013 Has-A\n\u000f The \ufb01rst two are general to all design methods,\nthe latter two are more particular to OO design\nand programming\nACE_IPC_SAP\nACE_Addr\nACE_SOCK_IO\nACE_SOCK\nACE_SOCK_Acceptor\nACE_INET_Addr\nACE_SOCK_Stream\nACE_SOCK_Connector\n37\nDesign Principles\nThe Uses Relation (1/3)\nClass X\nClass Y\n\u000f X Uses Y if the correct functioning of X depends on\nthe availability of a correct implementation of Y\n\u000f Note, uses is not necessarily the same as invokes:\n\u2013 Some invocations are not uses\n\u0003 e.g., error logging\n\u2013 Some uses don\u2019t involve invocations\n\u0003 e.g., message passing, interrupts, shared\nmemory access\n\u000f A uses relation does not necessarily yield a\nhierarchy (avoid cycles...)\n38\nDesign Principles\nThe Uses Relation (2/3)\n\u000f Allow X to use Y when:\n\u2013 X is simpler because it uses Y\n\u0003 e.g., Standard C++ library classes\n\u2013 Y is not substantially more complex because\nit is not allowed to use X\n\u2013 There is a useful subset containing Y and not\nX\n\u0003 i.e., allows sharing and reuse of Y\n\u2013 There is no conceivably useful subset\ncontaining X but not Y\n\u0003 i.e., Y is necessary for X to function\ncorrectly\n\u000f Uses relationships can exist between classes,\nframeworks, subsystems, etc. Acceptor-\nConnector\nReactor\nProactor\nService\nConfigurator\nStreams\nTask\n39", "domains": ["Software Quality Attributes"], "source": "design-principles4.pdf", "section": "Page 10", "position": 10, "chunk_type": "semantic", "token_estimate": 253}
{"text": "Acceptor: Sock\nAcceptor\nReactor\n41\nDesign Principles\nThe Is-Composed-Of Relation\n\u000f Many programming languages support the is-composed-of relation\nvia some higher-level component or record structuring technique\n\u000f However, the following are not equivalent:\n\u2013 level (virtual machine)\n\u2013 component (an entity that hides one or more \u201csecrets\u201d)\n\u2013 a subprogram (a code unit)\n\u000f Components and levels need not be identical, as a component may\nappear in several levels of a uses hierarchy\n42\nDesign Principles\nThe Is-A Relation\n\u000f This \u201cancestor/descendant\u201d relationship is\nassociated with object-oriented design and\nprogramming languages that possess\ninheritance and dynamic binding\n\u000f class X possesses Is-A relationship with class Y\nif instances of class X are specialization of class\nY. \u2013 e.g., an HTTP_1_0_Handler Is-A\nACE_Event_Handler that is specialized for\nprocessing HTTP 1.0 requests\nACE_Event_Handler\nhandle_input()\nget_handle()\nHTTP_1_0\nHandler\nHTTP_1_1\nHandler\n43", "domains": ["Domain-Driven Design", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 11", "position": 11, "chunk_type": "semantic", "token_estimate": 138}
{"text": "Acceptor: Reactor\nCV_Filesystem\n44\nDesign Principles\nChallenge 7: Enabling Expansion and Contraction of\nSoftware\n\u000f Context: A production web server whose requirements will change\nover time\n\u000f Problems:\n\u2013 It may be necessary to reduce the overall functionality of the\nserver to run in resource-constrained environments\n\u2013 To meet externally imposed schedules, it may be necessary to\nrelease the server without all the features enabled\n45\nDesign Principles\nSolution: Program Families and Subsets\n\u000f This principle should be applied to facilitate extension and\ncontraction of large-scale software systems, particularly reusable\nmiddleware infrastructure\n\u2013 e.g., JAWS, ACE, etc. \u000f Program families are natural way to detect and implement subsets\n\u2013 Minimize footprints for embedded systems\n\u2013 Promotes system reusability\n\u2013 Anticipates potential changes\n\u000f Heuristics for identifying subsets:\n\u2013 Analyze requirements to identify minimally useful subsets\n\u2013 Also identify minimal increments to subsets\n46\nDesign Principles\nExample of Program Families: JAWS\nand TAO\n(1) THE ACE ORB (TAO)", "domains": ["Software Quality Attributes"], "source": "design-principles4.pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 157}
{"text": "(2) The JAWS Web Server Framework: Service Configurator\nStrategy\nStrategy\nSingleton\nState\nState\nAcceptor\nPipes and Filters\nActive Object\nAdapter\nService Configurator\nEvent Dispatcher\nConcurrency\nStrategy\nFramework\nProtocol\nHandler\nProtocol\nFilter\nTilde\nExpander\n/home/...\n~\nReactor/Proactor\nMemento\nI/O Strategy\nFramework\nCached Virtual\nFilesystem\nProtocol Pipeline\nFramework\nAsynchronous Completon Token\n\u000f TAO is a high-performance, real-time\nimplementation of the CORBA speci\ufb01cation\n\u000f JAWS is a high-performance, adaptive Web\nserver that implements the HTTP speci\ufb01cation\n\u000f JAWS and TAO were developed using the\nwrapper facades and frameworks provided by\nthe ACE toolkit\n47", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "design-principles4.pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 91}
{"text": "Design Principles: Other Examples of Program Families\nand Subsets\n\u000f Different services for different markets\n\u2013 e.g., different alphabets, different vertical\napplications, different I/O formats\n\u000f Different hardware or software platforms\n\u2013 e.g., compilers or OSs\n\u000f Different resource trade-offs\n\u2013 e.g., speed vs space\n\u000f Different internal resources\n\u2013 e.g., shared data structures and library\nroutines\n\u000f Different external events\n\u2013 e.g., UNIX I/O device interface\n\u000f Backward compatibility\n\u2013 e.g., sometimes it is important to retain bugs! 48\nDesign Principles\nConventional Development Processes\n\u000f Waterfall Model\n\u2013 Specify, analyze, implement, test (in sequence)\n\u2013 Assumes that requirements can be speci\ufb01ed up front\n\u000f Spiral Model\n\u2013 Supports iterative development\n\u2013 Attempts to assess risks of changes\n\u000f Rapid Application Development\n\u2013 Build a prototype\n\u2013 Ship it :-)\n49\nDesign Principles\nAgile Processes\n\u000f Stresses customer satisfaction, and therefore, involvement\n\u2013 Provide what the customer wants, as quickly as possible\n\u2013 Provide only what the customer wants\n\u000f Encourages changes in requirements\n\u000f Relies on testing\n\u000f For example, eXtreme Programming practices\n\u2013 Planning, designing, coding, testing\n50\nDesign Principles\neXtreme Programming: Planning\nTechnology\nSpike\nSystem\nPrototype\nUser\nStory\nPlanning\nGame\nIteration\nCommitment\nSchedule\nChange in Requirements, Risk,\nor Developement Environment\nRisk Estimates\nTime\nRequirements\nbased on http://www.extremeprogramming.org/rules/planninggame.html\n\u000f Start with user stories\n\u2013 Written by customers, to\nspecify system\nrequirements\n\u2013 Minimal detail, typically\njust a few sentences on a\ncard\n\u2013 Expected development\ntime: 1 to 3 weeks each,\nroughly\n\u000f Planning game creates\ncommitment schedule for\nentire project\n\u000f Each iteration should take\n2-3 weeks\n51", "domains": ["Design Patterns", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 13", "position": 13, "chunk_type": "semantic", "token_estimate": 261}
{"text": "Design Principles: Rules of Design (2/8)\n\u000f Design external functionality before internal functionality. \u2013 First consider the solution as a black-box and decide how it\nshould interact with its environment\n\u2013 Then decide how the black-box can be internally organized. Likely\nit consists of smaller black-boxes that can be re\ufb01ned in a similar\nfashion\n\u000f Keep it simple. \u2013 Fancy designs are buggier than simple ones; they are harder to\nimplement, harder to verify, and often less ef\ufb01cient\n\u2013 Problems that appear complex are often just simple problems\nhuddled together\n\u2013 Our job as designers is to identify the simpler problems, separate\nthem, and then solve them individually\n60\nDesign Principles\nRules of Design (3/8)\n\u000f Work at multiple levels of abstraction\n\u2013 Good designers must be able to move between various levels of\nabstraction quickly and easily\n\u000f Design for extensibility\n\u2013 A good design is \u201copen-ended,\u201d i.e., easily extendible\n\u2013 A good design solves a class of problems rather than a single\ninstance\n\u2013 Do not introduce what is immaterial\n\u2013 Do not restrict what is irrelevant\n\u000f Use rapid prototyping when applicable\n\u2013 Before implementing a design, build a high-level prototype and\nverify that the design criteria are met\n61\nDesign Principles\nRules of Design (4/8)\n\u000f Details should depend upon abstractions\n\u2013 Abstractions should not depend upon details\n\u2013 Principle of Dependency Inversion\n\u000f The granule of reuse is the same as the granule of release\n\u2013 Only components that are released through a tracking system can\nbe effectively reused\n\u000f Classes within a released component should share common closure\n\u2013 That is, if one needs to be changed, they all are likely to need to\nbe changed\n\u2013 i.e., what affects one, affects all\n62\nDesign Principles\nRules of Design (5/8)\n\u000f Classes within a released component should be reused together\n\u2013 That is, it is impossible to separate the components from each\nother in order to reuse less than the total\n\u000f The dependency structure for released components must be a DAG\n\u2013 There can be no cycles\n\u000f Dependencies between released components must run in the\ndirection of stability\n\u2013 The dependee must be more stable than the depender\n\u000f The more stable a released component is, the more it must consist\nof abstract classes\n\u2013 A completely stable component should consist of nothing but\nabstract classes\n63", "domains": ["Design Patterns", "Design Principles", "Software Quality Attributes", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 16", "position": 16, "chunk_type": "semantic", "token_estimate": 395}
{"text": "Design Principles: Rules of Design (6/8)\n\u000f Where possible, use proven patterns to solve design problems\n\u000f When crossing between two different paradigms, build an interface\nlayer that separates the two\n\u2013 Don\u2019t pollute one side with the paradigm of the other\n64\nDesign Principles\nRules of Design (7/8)\n\u000f Software entities (classes, modules, etc) should be open for\nextension, but closed for modi\ufb01cation\n\u2013 The Open/Closed principle \u2013 Bertrand Meyer\n\u000f Derived classes must usable through the base class interface\nwithout the need for the user to know the difference\n\u2013 The Liskov Substitution Principle\n65\nDesign Principles\nRules of Design (8/8)\n\u000f Make it work correctly, then make it work fast\n\u2013 Implement the design, measure its performance, and if\nnecessary, optimize it\n\u000f Maintain consistency between representations\n\u2013 e.g., check that the \ufb01nal optimized implementation is equivalent to\nthe high-level design that was veri\ufb01ed\n\u2013 Also important for documentation . . . \u000f Don\u2019t skip the preceding rules! \u2013 Clearly, this is the most frequently violated rule!!! ;-)\n66\nDesign Principles\nConcluding Remarks\n\u000f Good designs can generally be distilled into a few key principles:\n\u2013 Separate interface from implementation\n\u2013 Determine what is common and what is variable with an interface\nand an implementation\n\u2013 Allow substitution of variable implementations via a common\ninterface\n\u0003 i.e., the \u201copen/closed\u201d principle\n\u2013 Dividing commonality from variability should be goal-oriented\nrather than exhaustive\n\u000f Design is not simply the act of drawing a picture using a CASE tool\nor using graphical UML notation!!! \u2013 Design is a fundamentally creative activity\n67", "domains": ["Design Principles", "Software Quality Attributes", "Code Organization"], "source": "design-principles4.pdf", "section": "Page 17", "position": 17, "chunk_type": "semantic", "token_estimate": 262}
